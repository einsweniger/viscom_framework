{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XsdcDr",
      "date": "1520336814",
      "viewed": 366,
      "name": "3D Motion Illusion",
      "username": "P_Malin",
      "description": "Inspired by patterns from @AkiyoshiKitaoka mapped on a 3D scene.\nhttps://twitter.com/AkiyoshiKitaoka/status/967758875649699841\nhttps://twitter.com/AkiyoshiKitaoka/status/970964297550520320\nhttps://twitter.com/AkiyoshiKitaoka/status/969510301925236736\n",
      "likes": 5,
      "published": 3,
      "flags": 0,
      "tags": [
        "illusion",
        "movement"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// 3D Motion Illusion Test - @P_Malin\n// https://www.shadertoy.com/view/XsdcDr\n\n// Inspired by patterns from @AkiyoshiKitaoka mapped on a 3D scene.\n// https://twitter.com/AkiyoshiKitaoka/status/967758875649699841\n// https://twitter.com/AkiyoshiKitaoka/status/970964297550520320\n// https://twitter.com/AkiyoshiKitaoka/status/969510301925236736\n\n//#define REVERSE_DIRECTION\n\nfloat MAX_DIST = 1000.0;\n\n#define PI 3.141592654\n#define TAU  (PI * 2.0)\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n    float fPersp = 3.0;\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fPersp);\n\n\treturn vDir;\n}\n\nvec2 Scene_GetDistance( vec3 vPos )\n{\n\tvec2 vResult = vec2( MAX_DIST, 0.0 );\n\n    float fFloorPlaneDist = 10.0 + vPos.y;\n    if ( fFloorPlaneDist < vResult.x )\n    {\n        vResult = vec2( fFloorPlaneDist, vPos.x * 1.5 );\n    }\n\n    float fCeilPlaneDist = 18.6 - vPos.y;\n    if ( fCeilPlaneDist < vResult.x )\n    {\n        vResult = vec2( fCeilPlaneDist, vPos.x * 1.5 );\n    }\n    \n    float fTunnelDist = 20.0 - length(vPos.xy);        \n    if ( fTunnelDist < vResult.x )\n    {\n        vResult = vec2( fTunnelDist, atan(vPos.x, vPos.y) * 150.0 / (3.14 * 2.0) );\n    }\n\n    vec3 vRailDomain = vPos;\n    vRailDomain.x = abs( vRailDomain.x );\n    \n    float fRailDist = length(vRailDomain.xy - vec2(10.0, -9.0)) - 1.0;\n    if ( fRailDist < vResult.x )\n    {\n        vResult = vec2( fRailDist, 0.0 );\n    }\n\n    float fSideRailDist = length(vRailDomain.xy - vec2(19.0, -1.5)) - 2.0;\n    if ( fSideRailDist < vResult.x )\n    {\n        vResult = vec2( fSideRailDist, 0.0 );\n    }\n        \n    return vResult;\n}\n\nvec3 Scene_GetNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).x * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).x * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).x * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).x * e.yyy;\n    \n    return normalize( vNormal );\n}   \n\nvec2 Scene_Trace( vec3 vRayOrigin, vec3 vRayDir, float minDist, float maxDist )\n{\t\n    vec2 vResult = vec2(0, 0);\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 64;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tvResult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(vResult.x) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist;\n            break;\n        }               \n        \n        t += vResult.x;\n\t}\n    \n    vResult.x = t;\n    \n    return vResult;\n}    \n\n\nvec3 MotionTextureGradient( float f )\n{\n#if 0\n    vec3 cols[] = vec3[](\n        vec3(1,0,0),\n        vec3(1,0,1),\n        vec3(0.95,0,1) * 0.75\n        );\n\n    f *= float( cols.length() );    \n\n    int c1 = int( floor(f) ) % cols.length();\n    int c2 = (c1 + 1) % cols.length();\n    float b = clamp( f - float(c1), 0.0, 1.0 );\n    \n    //b = smoothstep(0.0,1.0,b);\n    return mix( cols[c1], cols[c2], b );    \n#else    \n    vec3 vColA = vec3( 253, 27, 32 ) / 255.0;\n\tvec3 vColB = vec3( 198, 48, 249 ) / 255.0;\n    \n    //vec3 vColA = vec3(1,1,0);\n    //vec3 vColB = vec3(1,.1,0);\n        \n    float fCol = sin(f * TAU) * 0.5 + 0.5;\n    float fLum = sin((f + 0.25) * TAU) * 0.5 + 0.5;\n        \n    float fLumA = 0.9;\n    float fLumB = 1.0;\n\n    return mix( vColA, vColB, fCol ) * mix( fLumA, fLumB, fLum );\n#endif    \n}\n\nvec3 MotionTexture( vec2 vUV )\n{\n    float x = fract( vUV.x );\n\n    float fOffset = floor( x * 2.0 ) / 2.0;\n    float y = fract( vUV.y + fOffset );\n    \n\treturn MotionTextureGradient( y );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n    float theta = atan(vRayDir.x, vRayDir.y);\n    vec2 vScene = Scene_Trace( vRayOrigin, vRayDir, 0.0, MAX_DIST );\n    float fDist = vScene.x;\n\tvec3 vPos = vRayOrigin + vRayDir * fDist;\n\t\n    vec3 vNormal = Scene_GetNormal( vPos );\n    vec2 vUV = vScene.yx * vec2(0.1, 0.05); \n    \n    if ( fDist > 350.0 )\n    {\n        vUV = vec2(0);\n    }   \n\n#ifdef REVERSE_DIRECTION\n    vUV.y = 1.0 - vUV.y;\n#endif    \n    \n    vec3 vTex = MotionTexture(vUV + 0.25);\n    \n    vTex = vTex * vTex;\n    float t = fDist * fDist;\n    float fFog = 1.0 - exp2( -t * 0.00005 );\n    vec3 vFogColor = vec3(0.0);\n    vec3 vResult = mix( vTex, vFogColor, fFog );\n    \n    return sqrt(vResult);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 10.0);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tfragColor = vec4(vResult, 1.0);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}