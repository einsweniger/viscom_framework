{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4sXfR2",
      "date": "1496913232",
      "viewed": 436,
      "name": "Chromium kiss",
      "username": "grinist",
      "description": "First foray into raymarching. Tried to do something simple and soothing for the eyes. See comments for more info. \n",
      "likes": 14,
      "published": 3,
      "flags": 64,
      "tags": [
        "raymarch",
        "sdf",
        "material"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 9933,
            "src": "https://soundcloud.com/magic-sword/13-journeys-end-1",
            "ctype": "musicstream",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Tried to do something sensible with predefined materials per primitive.\n// Probably the interesting thing is material blending based on distances to primitives.\n// Materials are only solved once we know the final ray position, so the logic doesn't need to be\n// dragged around for all the marchers.\n// This and per-frame initialization of trivial trigonometry for the distance scene\n// helped performance quite a bit.\n// Tried to get a faux metal thing going to illustrate lerping better.\n// The surface shading is definitely not academic reference material worth studying. :D\n\n#define PI 3.1415926536\n#define TAU (2.0 * PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define time iTime\n#define RING_SPHERES 8\n#define RING_RADIUS 4.2\n#define SMIN_K 0.65\n\nstruct Material\n{\n    vec3 diffColor;\n    vec3 specColor;\n    float shininess;\n    float metallic;\n};\n\n// needs GLSL ES 3.0\nconst Material materials[6] = Material[6](\n  Material(vec3(0.7, 0.45, 0.25), vec3(1.0, 0.7, 0.5), 0.1, 0.25), \t// ground\n  Material(vec3(0.91, 0.13, 0.23), vec3(1.0, 0.82, 0.79), 0.5, 0.0),// ring spheres\n  Material(vec3(0.96, 0.57, 0.18), vec3(1.0, 0.85, 0.68), 0.4, 0.1),\n  Material(vec3(0.13, 0.72, 0.29), vec3(0.72, 1.0, 0.80), 0.6, 0.2),\n  Material(vec3(0.12, 0.51, 0.59), vec3(0.72, 0.94, 1.0), 0.3, 0.3),\n  Material(vec3(0.15, 0.5, 0.8), vec3(1.0, 1.0, 1.0), 1.0, 0.8)\t\t// orbiting sphere\n);\n#define ORBITER_MAT 5\n\n\n// ----- Incremental trigonometry\nfloat tsin = 0.0;\nfloat tcos = 0.0;\nfloat tcosd = 0.0;\nfloat tsind = 0.0;\n\nvoid trigInit(float startAngle, float increment)\n{\n\ttsin = sin(startAngle);\n\ttcos = cos(startAngle);\n\ttsind = sin(increment);\n\ttcosd = cos(increment);\n}\n\nvoid trigInc()\n{\n\tfloat sinn = tsin * tcosd + tcos * tsind;\n\tfloat cosn = tcos * tcosd - tsin * tsind;\n\ttsin = sinn;\n\ttcos = cosn;\n}\n// -----\n\nvec3 cosGradient(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b * cos(TAU * (c + d * t));\n}\n\nvec2 xmin(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec3 xmin(vec3 a, vec3 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec4 xmin(vec4 a, vec4 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// iq's polynomial smooth min\nfloat smin(float a, float b, float k)\n{\n    float h = saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// -----\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n#define HASHSCALE1 443.8975\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// -----\n\n// Returns the interpolant in [0.0, 1.0], inverse lerp\nfloat lerpstep(float a, float b, float x)\n{\n    if (a == b)\n        return step(x, a);\n    \n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\n// -----\n// Interpolating with 1/x: https://www.shadertoy.com/view/Xd2yRd\n\n// Interpolates from 0 to 1 with slope of k at x=0 and 1/k at x=1.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat invXEase(float x, float k)\n{\n\tx = saturate(x);\n\tk = clamp(k, 0.0001, 10000.0) - 1.0; // clamp optional, if you know your k\n    float kx = k * x;\n    return (x + kx) / (kx + 1.0);    \n}\n\n// Interpolates from 0 to 1 with slope of k at x=0 and x=1.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat invXEaseDual(float x, float k)\n{\n\treturn 0.5 * (invXEase(x * 2.0, k) + 1.0 - invXEase((1.0 - x) * 2.0, k));\n}\n// -----\n\n\nfloat invXStep(float a, float b, float x, float k)\n{\n    x = lerpstep(a, b, x);\n    return invXEaseDual(x, k);\n}\n\nfloat sWavyPlane(vec3 p)\n{\n    // this is still complex\n\treturn p.y + 0.03 * sin((p.z + 0.5 * p.x) * 3.0 - time * 3.0) + 0.06 * sin((0.4 * p.z + p.x) * 2.0 - time);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\n// Init frame global stuff for scene, to avoid doing it in distScene\nvec2 orbiterTrig;\nfloat sphereRadius;\nfloat tsinInit;\nfloat tcosInit;\nfloat tsindInit;\nfloat tcosdInit;\nvoid sceneInit()\n{\n    orbiterTrig = vec2(cos(time * 0.8), -sin(time * 0.9));\n    sphereRadius = 0.65 + sin(time * 2.0) * 0.1;\n    trigInit(PI * 0.125 + time * 0.2, TAU / float(RING_SPHERES));\n    tsinInit = tsin;\n    tcosInit = tcos;\n    tsindInit = tsind;\n    tcosdInit = tcosd;\n}\n\nvoid trigReset()\n{\n    tsin = tsinInit;\n    tcos = tcosInit;\n    tsind = tsindInit;\n    tcosd = tcosdInit;\n}\n\n// Distance equation scene, used by all marches (mainray, shadow, AO) and normal\nfloat distScene(vec3 pos)\n{\n    const float y = 0.6;\n    const float crad = RING_RADIUS;\n    float res = sWavyPlane(pos);\n    float os = sdSphere(pos - vec3(orbiterTrig.x * crad, y, orbiterTrig.y * crad), 0.65);\n\n\ttrigReset();\n    // could use polar domain repetition for rs or symmetry\n    for (int i = 0; i < RING_SPHERES; i++)\n    {\n\t    float rs = sdSphere(pos - vec3(tcos * crad, y, tsin * crad), sphereRadius + tcos * 0.15);\n        trigInc();\n\t    float ros = smin(rs, os, SMIN_K);\n\t    res = min(res, ros);\n    }\n\n    return res;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nvec3 matScene(vec3 pos)\n{\n    const float y = 0.6;\n    const float crad = RING_RADIUS;\n    vec4 res = vec4(sWavyPlane(pos), 0.0, 0.0, 0.0);\n    float os = sdSphere(pos - vec3(orbiterTrig.x * crad, y, orbiterTrig.y * crad), 0.65);\n\n\ttrigReset();\n    for (int i = 0; i < RING_SPHERES; i++)\n    {\n\t    float rs = sdSphere(pos - vec3(tcos * crad, y, tsin * crad), sphereRadius + tcos * 0.15);\n        trigInc();\n        float mat = 1.0 + mod(float(i), 4.0);\n        // lerp material based on distances to original primitives\n\t    vec4 ros = vec4(smin(rs, os, SMIN_K), mat, ORBITER_MAT, invXStep(0.0, max(rs, os), rs, 0.75));\n\t    res = xmin(res, ros);\n    }\n\n    return res.yzw;\n}\n\n// Calculates normal\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    distScene(pos + eps.xyy) - distScene(pos - eps.xyy),\n\t    distScene(pos + eps.yxy) - distScene(pos - eps.yxy),\n\t    distScene(pos + eps.yyx) - distScene(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\n// Main raymarch\nfloat mainray(vec3 ro, vec3 rd, float maxd)\n{\n\tfloat precis = 0.0005;\n    float h = precis * 2.0;\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        if (h <= precis || t >= maxd) break;\n        t += h;\n\t    h = distScene(ro + rd * t);\n    }\n\n    return t;\n}\n\n// Shadow raymarch\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt;)\n    {\n        float h = distScene(ro + rd * t);\n        if(h < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// AO raymarch\nfloat AO(vec3 pos, vec3 nor)\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for(float aoi = 0.0; aoi < 10.0; aoi += 1.0)\n    {\n        float hr = 0.01 + 0.05 * aoi;\n        vec3 aopos = nor * hr + pos;\n        float dd = distScene(aopos);\n        totao += -(dd - hr) * sca;\n        sca *= 0.65;\n    }\n    return saturate(1.0 - 2.5 * totao);\n}\n\nvec3 skycol(vec3 rd)\n{\n    vec3 col = cosGradient(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                  vec3(0.525, 0.408, 0.409), vec3(0.9, 0.97, 0.8), clamp(rd.y * 0.6 + 0.5, 0.3, 1.0));\n\treturn col * 0.7;\n}\n\nfloat nxorf(float a, float b)\n{\n    return abs(a + b - 1.0);\n}\n\nvoid matLerp(inout Material matr1, Material matr2, float lerp)\n{\n    matr1.diffColor = mix(matr1.diffColor, matr2.diffColor, lerp);\n    matr1.specColor = mix(matr1.specColor, matr2.specColor, lerp);\n    matr1.shininess = mix(matr1.shininess, matr2.shininess, lerp);\n    matr1.metallic = mix(matr1.metallic, matr2.metallic, lerp);\n}\n\n#define MAX_TRAVEL 25.0\nvec3 render(vec3 ro, vec3 rd, vec2 uv)\n{\n\tvec3 col = skycol(rd);\n    // sky only\n    if (uv.y > 0.1)\n        return col;\n    \n    // main raymarch\n\tfloat t = mainray(ro, rd, MAX_TRAVEL);\n    \n    // marched to sky\n    if (t >= MAX_TRAVEL)\n        return col;\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = normal(pos);\n    \n\t// materials\n    vec3 mats = matScene(pos);\n    int mat1Index = int(mats.x);\n    int mat2Index = int(mats.y);\n    float lerp = mats.z;\n    Material matr = materials[mat1Index];\n    Material matr2 = materials[mat2Index];\n    if (lerp > 0.0)\n\t    matLerp(matr, matr2, lerp);\n\n    vec3 surfcol = matr.diffColor;\n    vec3 specColor = matr.specColor;\n\n    if (mat1Index == 0)\n    {\n        float mul = 0.85 + 0.2 * hash12(pos.xz * 0.01);\n    \tvec2 check = floor(mod(pos.xz, 2.0));\n        mul *= 1.0 - saturate(1.0 - length(pos.xz) * 0.22) * 0.2 * nxorf(check.x, check.y);\n        surfcol *= mul;\n    }\n\n    float ao = AO(pos, nor);\n\n    // spot light orbiting the scene\n    vec3 lig = vec3(0.0 + cos(time * 0.4) * 9.0, 3.5, 0.0 + sin(time * 0.4) * 9.0);\n    vec3 spotDir = normalize(lig - vec3(0.0, 0.8, 0.0));\n    lig -= pos;\n    float ldistsq = dot(lig, lig);\n    float lint = 1.2 / (1.0 + 0.003 * ldistsq);\n    float ldist = sqrt(ldistsq);\n    lig /= ldist;\n    float cutoff = smoothstep(0.775, 0.875, saturate(dot(lig, spotDir)));\n    lint *= cutoff;\n    \n    float amb = 0.5 + 0.5 * nor.y;\n    vec3 refv = reflect(rd, nor);\n    vec3 refcol = skycol(refv);\n    float dotNL = dot(nor, lig);\n    float dotNR = dot(nor, rd);\n    float diff = saturate(dotNL);\n    float back = saturate(-dotNL);\n\n    float shn = clamp(matr.shininess, 0.01, 1.0);\n    float met = matr.metallic;\n    float sh = 1.0;\n    if(diff > 0.001)\n    {\n        sh = saturate(shadow(pos, lig, 0.01, ldist, 6.0));\n        diff *= sh;\n    }\n\n    vec3 brdf = vec3(0.0);\n    brdf += 0.25 * amb * ao;\n    brdf += 0.1 * back * ao;\n    brdf += lint * saturate(diff - met) * ao;\n    brdf += met * clamp(-dotNR, 0.6, 1.0);\n\n    float pp = saturate(dot(refv, lig));\n    float spe = lint * shn * sh * pow(pp, 64.0 * shn) * ao;\n    float fre = pow(saturate(1.0 + dotNR), 1.5) * ao;\n\n    float fog = exp(-0.009 * t * t);\n    surfcol = mix(surfcol, refcol * 0.6, met) * brdf + 0.6 * saturate(fre - met) * shn * (0.5 * vec3(0.5, 0.5, 0.5) + 0.5 * surfcol);\n    surfcol += specColor * spe;\n    col = mix(col, surfcol, fog);\n\treturn saturate(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 3.0 + sin(time * 0.5) * 1.3, 7.0 + sin(time * 0.5) * 0.5);\n\tvec3 ta = vec3(0.0, 2.0 + sin(time * 0.5) * 0.5, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 1.3 * cw);\n\n    sceneInit();\n    vec3 col = render(ro, rd, p);\n    fragColor = vec4(col * pow(2.0, 0.45), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}