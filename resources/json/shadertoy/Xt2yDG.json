{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "Xt2yDG",
      "date": "1509998110",
      "viewed": 271,
      "name": "snail branch.iq",
      "username": "ollj",
      "description": "branch of\nhttps://www.shadertoy.com/view/ld3Gz2\n\nmodified for fps and very slightly optimized.",
      "likes": 2,
      "published": 3,
      "flags": 0,
      "tags": [
        "sss",
        "water",
        "spiral",
        "transparent",
        "scattering",
        "leaf",
        "drop",
        "subsurface",
        "shell",
        "snail"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 10,
            "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
            "ctype": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 30,
            "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "ctype": "texture",
            "channel": 3,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 47,
            "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
            "ctype": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//sign 3d snail spiral iq 2\n//self  : https://www.shadertoy.com/view/Xt2yDG\n//parent: https://www.shadertoy.com/view/ld3Gz2\n// Created by inigo quilez - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//ichan1 is 2d.pebbles.monochrome\n//ichan2 is 2d.noise.organic.bark\n//ichan3 is 2d.noise.rgba\n\n//read noise from buffered textures (h\u00edgher detail costs a lot of fps)\n#define doBuffers\n\n//lazyAntiAliasing is not worth quater the performance.\n#define AA 1\n\n//samples of ambient occlusion\n#define iterAO 8.\n//samples of subsurface Scatter\n#define iterSSS 4.\n//samples of cubemap blur\n#define iterBlurCubeMap 2.\n\n//iterate ray-march (all root solving geometry)\n#define iterRmO 64.\n//epsilon precision for Raymarching\n#define epsShad .002\n\nvec3 sunDir=normalize( vec3(.2,.1,.02));\n\n/*  ollj edit notes:\n\nlowered a lot of iteration parameters, fps is more impoortant.\n\nwhen a function ends wwith *-1 \n I moved that our of the function.\n\ngetClosest() has some minor changes in order of operations.\ngetClosest() modified to a variant of itself (special case)\n... with less differentials.\n\nmapShell() made branchless and re-vectorized.\n\ncalcSoftShadow() speed improved with earlier break condition.\n\nseperated the g-buffer texturing resolve \n into their object branches.\n\nunintentionally flipped some signs in the leaf and shell texturing.\n nothing big though, its still a leaf and a snail.\n makes it look a little different from parent.\n\n---todo:\n\nsat(.../4.) is common enough for an alias\n\nthere seems to be one reletitive matrix\n, not sure how repeating it is.\n\nvarious places are annotated with simpler optimizations \n that are not done yet, because they end up context-biased.\n*/\n\n#define sat(a) clamp(a,0.,1.)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define nc(r) (r)*(1.-(r))*(1.-(r))*6.\n#define ssm(a,b) smoothstep(-(a),a,b)\n#define ssn(a,b) smoothstep(0.  ,a,b)\n\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec3 a){return min(a.x,miv(a.yz));}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\n#define mav(a) -miv(-a)\n\n#define sdEllipsoid(p,r) (length((p)/(r) )-1.)*miv(r)\n\n//only used once\nfloat sdTorus(vec3 p,float t)\n{return length(vec2(length(p.xz)-t,p.y));}\n\n//3d line segment really\nfloat sdCapsule(vec3 p,vec3 a,vec3 b){p-=a,b-=a\n;return length(p-b*sat(dot(p,b)/dot(b,b)));}\n\nvec2 udSegment( vec3 p, vec3 a, vec3 b ){p-=a,b-=a\n;float h=sat( dot(p,b)/dot(b,b))\n;return vec2(length(p-b*h),h);}\n\nfloat sdBox( vec3 p,vec3 b){ p=abs(p)-b\n;return min(mav(p),.0)+length(max(p,.0));}//rounded box\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 tra(vec2 a){return vec2(a.y,-a.x);}\nfloat det(vec2 a,vec2 b){return determinant(mat2(a,b));}\n//==return dot(a,tra(b));//return a.x*b.y-b.x*a.y;}\n//specialized variant has a lot of differentials cancel each other out\nvec3 getClosest(vec2 x,vec2 y,vec2 z){\n;vec2 xy=x+y,zy=z+y;\n;float a=det(xy,zy),b=det(y,xy)*2.,d=det(zy,y)*2.,f=b*d-a*a\n;vec2 g=tra(2.*((a+b)*z+(-d-a)*x)),p=xy+f*g/dot(g,g)\n;float t=sat((det(p,z-x)+det(-x,p)*2.)/(a*2.+b+d))\n;return vec3(mix(mix(xy,y,t),mix(y,zy,t),t),t);}\n\nvec4 sdBezier(vec3 a,vec3 b,vec3 c,vec3 p)\n{vec3 w=normalize(cross(c-b,a-b))\n,u=normalize(c-b),v=normalize(cross(w,u))\n;vec2 d=vec2( dot(a-b,u),dot(a-b,v))\n,e=vec2(dot(c-b,u),dot(c-b,v))\n;vec3 f=vec3(dot(p-b,u),dot(p-b,v),dot(p-b,w))\n;c=getClosest(d,-f.xy,e )\n;return vec4(sqrt(dot(c.xy,c.xy)+f.z*f.z),c.z,length(c.xy),f.z);}\n//the antennas only need .xy of its return value.\nvec2 sdBezierXy(vec3 a,vec3 b,vec3 c,vec3 p)\n{vec3 w=normalize(cross(c-b,a-b))\n,u=normalize(c-b),v=normalize(cross(w,u))\n;vec2 d=vec2( dot(a-b,u),dot(a-b,v))\n,e=vec2(dot(c-b,u),dot(c-b,v))\n;vec3 f=vec3(dot(p-b,u),dot(p-b,v),dot(p-b,w))\n;c=getClosest(d,-f.xy,e )\n;return vec2(sqrt(dot(c.xy,c.xy)+f.z*f.z),c.z);}\n\n\nfloat smin(float a,float b,float k){float h=sat(u5((b-a)/k))\n;return mix(b,a,h)-k*h*(1.-h);}\nfloat smax(float a,float b,float k){float h=sat(u5((b-a)/k))\n;return mix(a,b,h)+k*h*(1.-h);}\n\nvec2 smin(vec2 a,vec2 b,float k){float h=sat(u5((b.x-a.x)/k))\n;return vec2(mix(b.x,a.x,h)-k*h*(1.-h),mix(b.y,a.y,h));}\nvec3 smax(vec3 a,vec3 b, float k){vec3 h=sat(u5((b-a)/k))\n;return mix(a,b,h)+ k*h*(1.-h);}\nvec4 smin(vec4 a,vec4 b,float k){float h=sat(u5((b.x-a.x)/k))\n;return vec4(mix(b.x,a.x,h)- k*h*(1.0-h),mix(b.yzw,a.yzw,h));}\n\n\nconst float pi = 3.1415927;\n\n//---------------------------------------------------------------------------\n\nfloat hash1(float n){return fract(sin(n)*43758.5453123);}\nvec3 hash3(float n)\n{return fract(sin(n+vec3(.0,13.1,31.3))*158.5453123);}\n\nvec3 forwardSF(float i,float n)\n{const float PHI=1.618033988749894848\n;float p=2.*pi*fract(i/PHI)\n,z=1.-(2.*i+1.)/n\n;return vec3(vec2(cos(p),sin(p))*sqrt(1.-z*z),z);}\n\n//---------------------------------------------------------------------------\n\nfloat mapShell(vec3 p,out vec4 m)\n{const float sc =1.//some scaling\n,b=.1759,th=0.11 \n;p-=vec3(0.05,0.12,-0.09);p*=sc;vec3 q=mat3\n(-.6333234236,-.7332753384,.2474039592\n ,.7738444477,-.6034162289,.1924931824\n ,.0081370606, .3133626215,.9495986813)*p\n;float r=length(q.xy),t=atan(q.y,q.x)\n// https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n;float n=(log(r)/b-t)/(2.*pi)\n;n=min(n,(log(th)/b-t)/(2.*pi));n=floor(n)\n;vec2 s=vec2(1,3.019863)*exp(b*(t + 2.0*pi*n))\n;vec2 h=q.z+1.5*s-.5\n;vec2 e=sqrt((s-r)*(s-r)+h*h)-s \n;float dy=mix(s.y,s.x,step(e.x,e.y)),dx=r-dy//different stripes\n,d=min(e.x,e.y)\n#ifdef doBuffers\n;d+=0.002*textureLod(iChannel2,vec2(t+r,0.5),0.).x\n#endif\n;m=vec4(dx,dy,r/.4,t/3.14159)\n;vec3 w=q-vec3(.52,.0,.0)\n;q-=vec3(.34,-.1,.03)\n;q.xy=mat2(.8,.6,-.6,.8)*q.xy\n;d=smin(d,sdTorus(q,.28 )-.05,.06)\n;d=smax(d,-sdEllipsoid(q,vec3(.24,.36,.24)),.03)\n;d=smax(d,-sdEllipsoid(w,vec3(.42,.23,.5 )),.05)\n;return d/sc;}\n\nvec3 opTwist(vec3 p,float k)\n{float x=-.1;p.x-=x\n//todo simplyify thois rotation\n;vec2 c=vec2(cos(k),sin(k))\n;vec2 q=mat2(c.x,-c.y,c.y,c.x)*p.xz\n;return vec3(q.x+x,p.y,q.y);}\n\nvec2 mapSnail( vec3 p, out vec4 m )    \n{vec3 h = vec3(-.76,.6,-.3),q=p-h//scatter seperator\n#if 1\n ;vec4 b1=sdBezier(vec3(-.13,-.65,.0)\n                  ,vec3(.24,.9+.1,.0)\n                  ,h+vec3(.04,.01,.0),p)\n ;float a=b1.x-ssn(.2,b1.y)\n      *(.16-.07*smoothstep(.5,1.,b1.y))\n ;b1=sdBezier(vec3(-.085,.0,.0)\n             ,vec3(-.1,.85,.0)\n             ,h+vec3(.06,-.08,.0),p)\n ;float b=b1.x-.1+.06*b1.y\n ;a=smin(a,b,.03);m.xyz=b1.yzw\n#else\n ;vec4 b1=sdBezier(-vec3(.13,.65,.0)\n                   ,vec3(.24,1.01,.0)\n                   ,h+vec3(.05,-.01,.0),p)\n ;float a=b1.x-ssn(.2,b1.y)\n  *(.16-.75*.07*smoothstep(.5,1.,b1.y))\n ;m.xyz = b1.yzw;float b\n#endif\n;b=length(q-vec3(.0,-.06,.0))-.085;\n;a=smin(a,b,.03 );\n;a=smin(a,length(p-vec3(.05,.52,.0))-.13,.07);\n;q.xz=mat2(.8,.6,-.6,.8)*q.xz\n;vec3 sq=vec3(q.xy,abs(q.z))\n//top antenas:\n;vec3 af=.05*sin(.5*iTime+vec3(0,1,3)+vec3(2,1,0)*sign(q.z))\n;vec2 b2=sdBezierXy(vec3(0),vec3(-1,2,2)*.1,vec3(-3,2,3)*.1+af,sq)\n;a=smin(a,b2.x-.03+0.025*b2.y,.04)\n;a=smin(a,length(sq-vec3(-3,2,3)*.1-af)-.016,.01)  \n//bottom antenas:\n;vec3 bf=.02*sin(.3*iTime+vec3(4,1,2)+vec3(3,0,1)*sign(q.z))\n;vec2 b3=udSegment(sq,vec3(.06,-.05,0),vec3(-.04,-.2,.18)+bf)\n;a=smin(a,b3.x-.025+.02*b3.y,.06)\n;a=smin(a,length(sq-bf-vec3(-.04,-.2,.18))-.008,.02)\n// bottom\n;vec3 pp=p-vec3(-.17,.15,0)\n    //todo simplyify thoiis rotation\n;float co=.988771078,si=0.149438132;pp.xy=mat2(co,-si,si,co)*pp.xy\n;a=smin(a,sdEllipsoid(pp,vec3(.084,.3,.15)),.05)\n;a=smax(a,-sdEllipsoid(pp-vec3(-.08,0,0),vec3(.06,.55,.1)),.02)\n// disp\n#ifdef doBuffers\n ;float dis=textureLod(iChannel1,5.*p.xy,.0).x\n#else\n ;float dis=1.\n#endif\n//todo 1.-smoothstep is always fishy for potentially better efficiency!\n;float dx = u5(1.-smoothstep(.5,1.,b1.y));\n;a-=.005*dis*dx*.5\n;return vec2(a,1.);}\n\nfloat mapDrop(vec3 p){p+=vec3(.26,-.25,.02);p.x-=2.5*p.y*p.y\n;return sdCapsule(p,vec3(0,-.06,0),vec3(.014,.06,0))-.037;}\n\n\nfloat mapLeaf(vec3 p){p-=vec3(-1.8,.6,-.75)\n;p=mat3(.671212,.366685,-.644218,\n       -.479426,.877583, .0,\n        .565354,.308854, .764842)*p\n;p.y+=.2*exp(-abs(2.*p.z))\n;float h=.25*50.*p.x-.25*75.*abs(p.z)//+ 1.*sin(5.*p.x)*sin(5.*p.z);\n,s=sin(h),r=sat((p.x+2.)/4.)\n;p.y+=.005*s*s*s;r=.0001+nc(r);s=sin(h*2.)\n;float t=0.035*s*s*u5(sin(p.x*12.))\n,d=sdEllipsoid(p,vec3(2,.25*r,r+t))\n;return smax(d,-p.y+.02,.02);}\n\nvec2 mapO(vec3 p, out vec4 m){m=vec4(0)\n;vec2 r=mapSnail(p,m);vec4 tmpMatInfo\n;float d=mapShell(p,tmpMatInfo);if(d<r.x){r=vec2(d,2);m=tmpMatInfo;}\n;vec4 b=sdBezier(-vec3(.15,1.5,0),vec3(-.1,.5,0),vec3(-.6,1.5,0),p)\n;d=b.x-.04+.02*b.y             ;if(d<r.x) r=vec2(d,3)\n;d=mapLeaf(p)                  ;if(d<r.x) r=vec2(d,4);return r;}\n\nfloat mapLeafWaterDrops(in vec3 p){p-=vec3(-1.8,0.6,-0.75)\n;vec3 s=p\n;p=mat3(.671212,.366685,-.644218\n      ,-.479426,.877583,0.\n      , .565354,.308854, .764842)*p\n;vec3 q=p\n;p.y+=.2*exp(-abs(2.*p.z))\n;float r=sat((p.x+2.)/4.)\n;r=nc(r)\n//;float d0=sdEllipsoid(p,vec3(2,.25*r,r))\n;return miv(vec4\n(max(sdEllipsoid(s-vec3(.76,-0.8,.6),.5*vec3(.15,.2 ,.15)),p.y-.01)\n,sdEllipsoid(q-vec3(.5,0,.2),vec3(.15,.13,.15))\n,sdEllipsoid(q+vec3(-.8,.07,.15),.5*vec3(.15,.13,.15))\n,sdEllipsoid(q+vec3(.5,-.09,.2),vec3(.04,.03,.04))));}\n\n//2 passes and normal; opague, Transparent\nvec2 mapT(vec3 p,out vec4 m){m=vec4(0)\n;return vec2(min(mapDrop(p),mapLeafWaterDrops(p)),4);}\n\nvec3 normal(vec3 u,float f){vec4 k\n;vec2 e=vec2(1.,-1.)*.5773*f; return normalize\n(e.xyy*mapO(u+e.xyy,k).x\n+e.yyx*mapO(u+e.yyx,k).x\n+e.yxy*mapO(u+e.yxy,k).x\n+e.xxx*mapO(u+e.xxx,k).x);}\n\nvec3 normalT(vec3 u,float f){vec4 k\n;vec2 e=vec2(1,-1)*.5773*f;return normalize\n(e.xyy*mapT(u+e.xyy,k).x\n+e.yyx*mapT(u+e.yyx,k).x\n+e.yxy*mapT(u+e.yxy,k).x\n+e.xxx*mapT(u+e.xxx,k).x);}\n\n\nfloat calcAO(vec3 u,vec3 n){vec4 k;float a=.0\n;for(float i=.0;i<iterAO;i++\n){vec3 p=forwardSF(i,32.)\n ;float h=hash1(i)\n ;p*=sign(dot(p,n))*h*0.1\n ;a+=sat(mapO(u+n*.01+p,k).x*3.);}\n;return sat(a*6./iterAO);}\n\nfloat calcSSS(vec3 u,vec3 n){vec4 k;float a=.0\n;const float m=iterSSS-1.;\n;for(float i=.0;i<iterSSS;i++\n){float h=.002+.11*i/m\n ;vec3 d=normalize(sin(i*13.+vec3(0,2.1,4.2)))\n ;d*=sign(dot(d,n))\n ;a+=(h-mapO(u-h*d,k).x);}\n;a=sat(1.-11.*a/iterSSS);return a*a;}\n\nfloat calcSoftShadow(vec3 u,vec3 t,float k)\n{vec4 l;float a=1.,b=.01\n;for(int i=0;i<32;i++\n){float h=mapO(u+t*b,l).x\n ;a=min(a,ssn(1.,k*h/b)) \n ;if(a<.01)break\n ;b+=clamp(h,.04,.1);}return sat(a);}\n\nvoid snailBody(vec3 u,out vec3 s,out vec3 d,out vec2 k\n              ,vec3 t\n              ,vec3 n\n              ,out vec4 m\n              ,out float f)\n{float b=sdEllipsoid( u-vec3(-.3,-.5,-.1),vec3(.2,1,.5));\n#ifdef doBuffers\n float j=texture(iChannel1,5.*u.xy ).x;\n#else\n float j=.5;\n#endif\n//todo silly 1-smoothstep again\n;b=1.-ssm(.01,b)\n;float g=abs(m.x-0.20)\n;s=6.*mix(.7*vec3(2,1.2,.2),vec3(2.5,1.8,.9),g)\n;s+=2.*j;s*=1.5;s*=1.+.5*g*g;s*=1.-.5*b\n;d=vec3(1,.8,.4);d*=j;d*=.015;d+=vec3(.8,.4,.3)*0.15*b\n;k=vec2(60.,.7+2.*j)\n;float i=sat(dot(-t,n))\n;i=1.-pow(i,8.)\n#ifdef doBuffers\n;i=1.-(1.-i)*(1.-texture(iChannel2, 0.3*u.xy ).x);\n#endif\n;s*=vec3(.5,.1,0)+g*vec3(.5,.9,1)\n;f=.2+.8*ssn(.15,length(u-vec3(.05,.52,0))-.13);}\n\n\nvoid snailShell(vec3 u,out vec3 s,out vec3 d,out vec2 k,out vec4 m)\n{k=vec2(0)\n;float tip=1.-smoothstep(.05,.4,length(u-vec3(.17,.2,.35)))\n;d=mix(.7*vec3(.2,.21,.22),.2*vec3(.15,.1,0),tip)\n;vec2 uv=vec2(.5*atan(m.x,m.y)/pi, 1.5*m.w)\n#ifdef doBuffers\n ;d*=.25+.75*texture(iChannel1,vec2(2.0*m.w+m.z*0.5,0.5)).xxx\n#endif\n;float pa=ssm(.2,.3+sin(2.+40.*uv.x+3.*sin(11.*uv.x)))\n;float bar=mix(pa,1.,smoothstep(.7,1.,tip))\n;bar *=(m.z<.6) ? 1.:smoothstep(.17,.21,abs(m.w))\n;d*=vec3(2,1,0)*.03+vec3(.94,.97,1)*bar\n;k=vec2(64.,.2)\n;s=1.5*vec3(1,.65,.6)*(1.-tip);//*0.5;\n}\n\nvoid snailPlant(vec3 u,out vec3 s,out vec3 d,out vec2 k,out vec3 e,vec3 t,vec3 n)\n{d=vec3(.05,.1,0)*.2\n;s=vec3(.1,.2,.02)*25.\n;k=vec2(5,1)\n;float f=sat(1.+dot(n,t))\n;d+=.2*vec3(1,.5,.1)*f\n#ifdef doBuffers\n ;s*=.5+1.5*texture( iChannel2, u.xy*0.2 ).xyz\n#endif\n;e=.5*vec3(.1,.1,.03)*(.2+.8*t.x);}\n\nvoid snailLeaf(vec3 u,out vec3 s,out vec3 d\n     ,out vec2 k,out float o,out float h,vec3 n)\n{u-=vec3(-1.8,0.6,-0.75)\n;u=mat3(.671212,.366685,-.644218\n      ,-.479426,.877583,0.\n       ,.565354,.308854,.764842)*u\n;vec3 q=u\n;u.y+=.2*exp(-abs(2.*u.z))\n;float v=smoothstep(.01,.02,abs(u.z))\n;float rr=sin(50.*u.x-75.*abs(u.z))\n;float r=sat((u.x+2.0)/4.0)\n;r=nc(r)\n;float ff=length(u.xz/vec2(2.,r))\n;d=mix(vec3(.07,.1,0), vec3(.05,.2,.01)*.25,v)\n;d=mix(d,vec3(.16,.2,.01)*.25,ff)\n#ifdef doBuffers\n ;d*=1.+.25*texture(iChannel2,u.xz*.35).xyz  \n#endif\n;d*=.8\n;s=vec3(0.15,0.2,0.02)*0.8\n;s*=1.+.2*rr\n;s*=.8\n;k=vec2(64,.25)\n#ifdef doBuffers\n;n.xz += v*0.15*(u2(texture( iChannel3, 1.0*u.xz ).xy))\n#endif\n;n=normalize(n)\n;float dd=miv(vec3\n(sdEllipsoid(q-vec3(.5-0.07,0,.2),vec3(1.4*.15,.13,.15))\n,sdEllipsoid(q-vec3( 80-5,-7,-15)*.01,vec3(1.3*.15,.13,.15)*.5)\n,sdEllipsoid(q-vec3(-50-7, 9,-20)*.01,vec3(1.4*.04,.03,.04))))  \n;h=.05+.95*ssn(.05,dd)\n;dd=miv(abs(vec3  \n(sdEllipsoid(q.xz-vec2(.5, .2 ),vec2(.15))\n,sdEllipsoid(q.xz-vec2(.8,-.15),vec2(.15)*.5)\n,sdEllipsoid(q.xz+vec2(.5, .2 ),vec2(.04)))))\n;o*=.55+.45*ssn(.08,dd)\n;h+=1.5*((1.-ssn(.10,distance(q.xz,vec2(.5-.07, .20))))\n+(1.-ssn(.05,distance(q.xz,vec2(.8-.03,-.15)))))\n;}\n\nvec3 shadeOpaque(vec3 u,vec3 t,float v,float i,vec4 m)\n{u+=v*t;vec2 k=vec2(0)\n;vec3 n=normal(u,epsShad),d=vec3(0),s=vec3(0),e=vec3(0)\n;float focc =1.,fsha =1.\n;     if(i<1.5)snailBody (u,s,d,k  ,t,n,m,focc)\n;else if(i<2.5)snailShell(u,s,d,k      ,m)\n;else if(i<3.5)snailPlant(u,s,d,k,e,t,n)\n;else          snailLeaf (u,s,d,k        ,focc,fsha,n)\n//if(i<4.5)\n;vec3 hal=normalize(sunDir-t)\n;float fre=sat(1.+dot(n,t))\n;float occ=calcAO(u,n)*focc\n;float sss=calcSSS(u,n)\n;sss=sss*occ+fre*occ+u5(fre)*pow(abs(m.x-.2),1.)*occ\n;float dif1=sat( dot(n,sunDir))\n;float sha=calcSoftShadow(u,sunDir,20.)\n;dif1 *= sha*fsha\n;float spe1=sat(dot(n,hal))\n;float bou=sat(.3-.7*n.y)\n;float pf=pow(fre,4.);\n;vec3 c = 7.0*vec3(1.7,1.2,0.6)*dif1*2.0     // sun\n;c+=4.*vec3(.2,1.2,1.6)*occ*u5(n.y)// sky\n;c+=1.8*vec3(.1,2.0,0.1)*bou*occ          // bounce\n;c*=d\n;c+=.4*sss*(vec3(.15,.1,.05)+vec3(.85,.9,.95)*dif1)*(.05+.95*occ)*s // sss\n;c= pow(c,vec3(.6,.8,1))\n;c+=k.x*k.y*dif1*(.2*pow(spe1,1.+k.x)*(.04+.96*pf)  // sun lobe1\n +             .1*pow(spe1,1.+k.x/3.)*(.1 +.9 *pf));// sun lobe2\n;c+=.1*vec3(1.,max(1.5-.7*c.y,.0),2.)*occ*occ*ssn(.3,reflect( t, n ).y )*k.x*k.y*(0.04+0.96*pow(fre,5.0)); // sky\n;c+=e;return c;}\n\nvec3 shadeTransparent(vec3 u,vec3 t,float v,vec3 c,float w){\n;vec3 o=c,n=normalT(u+v*t,.002)\n;float f=sat(1.+dot(t,n))\n,spe1=sat(dot(n,normalize(sunDir-t)))\n,spe2=sat(dot(reflect(-t,n),sunDir))\n,d=1.6-c.y;\n;c *= vec3(.4,.6,.4)*sat((w-v)*50.);//ao\n;c+=d*1.5*vec3(1,.9,.8)*pow( spe1, 80.0 );\n;c+=d*.2*vec3(.9,1,1)*smoothstep(.4,.8,f);\n;c+=d*.9*vec3(.6,.7,1)*ssm(.5,-reflect(t,n).y)*smoothstep(.2,.4,f);    \n;c+=d*.5*vec3(1,.9,.8)*pow(spe2,80.);\n;c+=d*.5*vec3(1,.9,.8)*pow(spe2,16.);\n;c+=vec3(.8,1,.8)*.5*smoothstep(.3,.6,texture( iChannel1, 0.8*n.xy ).x)*(.1+.9*f*f);\n;c= mix(c,o,smoothstep(.6,1.,f) ) // hide aliasing a bit\n;return c;}\n\n\n//tracer with g-buffer\nvec2 intersectOpaque(vec3 u,vec3 t,float b,const float n,out vec4 m){\n;vec2 a=vec2(-1.)\n;for(float i=.0;i<iterRmO;i++\n){vec3 p=u+b*t\n ;vec2 h=mapO(p,m)\n ;a=vec2(b,h.y)\n ;if(h.x<(.001*b)||b>n)break\n ;b+=h.x*.9;}\treturn a;}\n//these 2 should be mixable and not as deferred:\nvec2 intersectTransparent(vec3 u,vec3 t,float b,const float n,out vec4 m)\n{vec2 a=vec2(-1.)\n;for(float i=.0;i<iterRmO;i++\n){vec3 p=u+b*t\n ;vec2 h=mapT(p,m)\n ;a=vec2(b,h.y)\n ;if(h.x<(.001*b)||b>n)break\n ;b+=h.x;}return a;}\n\nvec3 background(vec3 d)\n{vec3 n=abs(d)\n;vec2 u=(n.x>n.y && n.x>n.z) ? d.yz/d.x: \n        (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                               d.xy/d.z// cheap cubemap\n;vec3  c=vec3(0)\n#ifdef doBuffers\n ;for(float i=.0;i<iterBlurCubeMap; i++\n ){float h=i/iterBlurCubeMap,a=62.*h\n  ;c=smax(c,texture(iChannel2, u*.25+.0075*vec2(cos(a),sin(a))*h,4.).yxz,.5);}\n#endif\n;return pow(c,vec3(3.5,3,6))*.2;}\n\n\nvec3 render(vec3 u,vec3 t,vec2 q)\n{vec3 c=background(t)\n;float mindist=1.,maxdist=4.\n;vec4 matInfo\n;vec2 tm=intersectOpaque(u,t,mindist,maxdist,matInfo)\n;if( tm.y>-0.5 && tm.x < maxdist\n){c=shadeOpaque(u,t,tm.x,tm.y,matInfo)\n ;maxdist=tm.x;}\n;tm=intersectTransparent(u,t,mindist,maxdist,matInfo)\n;if( tm.y>-0.5 && tm.x<maxdist)\n  c=shadeTransparent(u,t,tm.x,c,maxdist)\n;c+=1.*vec3(1.5,.8,.7)*pow(sat(dot(t,sunDir)),4.)\n;c=pow(c,vec3(.45));\n;c=1.05*c + vec3(0,0,.04);\n;c*=.3+.7*pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.1);\n;return sat(c);}\n\nmat3 setCamera(vec3 u,vec3 t,float r)\n{vec3 w=normalize(t-u)\n;vec3 p=normalize(cross(w,vec3(sin(r),cos(r),.0)))\n;return mat3(p,normalize(cross(p,w)),-w);}\n\nvoid mainImage( out vec4 o, in vec2 P ){\n;P.x=iResolution.x-P.x//optional vertical flip, as easy difference from parent\n#if AA<2\n ;vec2 p=(-iResolution.xy+2.0*P.xy)/iResolution.y\n ;vec2  q=P.xy/iResolution.xy\n ;float a=1.87-.04*(1.-cos(.5*iTime))\n ;vec3 u=vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(a),.0,sin(a))//camera position\n ,t=vec3(-0.6,0.2,0.0)//camera target\n ,c = render( u, normalize(setCamera(u,t,.0)*vec3(p,-2.8)), q )\n#else\n ;vec3 c=vec3(0)\n ;float aa=1./float(AA)\n ;float a=1.87-.04*(1.-cos(.5*iTime))\n ;for(int m=0;m<AA;m++)\n   for(int n=0;n<AA;n++\n  ){vec2 rr=vec2(float(m),float(n))*aa\n   ;vec2 p=(-iResolution.xy+2.0*(P.xy+rr))/iResolution.y\n   ;vec2 q=(P.xy+rr)/iResolution.xy\n   ;vec3 u=vec3(-.4,.2,0)+2.2*vec3(cos(a),.0,sin(a))\n   ,t=vec3(-.6,.2,0)\n   ;t=normalize(setCamera(u,t,.0)*vec3(p,-2.8))\n   ;c+=render(u,t,q);}c*=aa*aa;\n#endif\n;o=vec4(c,1);}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}