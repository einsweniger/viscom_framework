{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4sKyDD",
      "date": "1522166260",
      "viewed": 183,
      "name": "Paper plane",
      "username": "qwertsol",
      "description": "Paper plane. Part of a larger shader project I'm currently working on. \nCommon section has some useful functions that may be used for other shaders.",
      "likes": 3,
      "published": 3,
      "flags": 0,
      "tags": [
        "paperplane"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Square root of number of samples used for super-sampling\n#define SAMPLES 2\n\nconst vec3[] points = vec3[](vec3(0, -1.2, 0), vec3(-1, 1, 0), vec3(-0.2, 1, 0), vec3(0, 0.9, -0.4), vec3(0.2, 1, 0), vec3(0.9, 1, 0));\nconst ivec3[] triangles = ivec3[](ivec3(0, 1, 2), ivec3(2, 3, 0), ivec3(3, 4, 0), ivec3(4, 5, 0));\nconst ivec2[] lines = ivec2[](ivec2(0, 1), ivec2(0, 2), ivec2(0, 3), ivec2(0, 4), ivec2(0, 5), ivec2(1, 2), ivec2(2, 3), ivec2(3, 4), ivec2(4, 5));\nconst int lenT = 4;\nconst int lenL = 9;\n\nbool intersectLine( Ray ray, vec3 pa, vec3 pb, float ra, out float t )\n{\n    float t0, trash;\n    \n    t = 100000.0;\n    \n    bool i = false;\n    if (intersectSphere(ray, vec4(pa, ra), t0, trash)) \n    {\n        t = t0;\n        i = true;\n    }\n    \n    if (intersectSphere(ray, vec4(pb, ra), t0, trash) && t0 < t) \n    {\n        t = t0;\n        i = true;\n    }\n    \n    if (intersectCylinder(ray, pa, pb, ra, t0) && t0 < t) \n    {\n        t = t0;\n        i = true;\n    }\n    \n\n\treturn i;\n}\n\nvec3 trace( Ray ray, vec2 uv )\n{\n    mat4 T = translationMatrix(vec3(0.0, 0.0, -10.0)) *\n        rotationMatrix(up, iTime) *\n        rotationMatrix(right, iTime * 0.3) *\n        rotationMatrix(forward, iTime * 0.5) *\n        scaleMatrix(vec3(0.4));\n    transform(ray, inverse(T));\n    \n    vec3 color = mix(vec3(0.2, 0.1, 1.0), vec3(0.0, 0.4, 1.0), uv.y);\n    color += rand3(uv) * .05;\n    \n    float t0 = 100000.0;\n    for (int i=0; i<lenT; i++) \n    {\n        ivec3 triangle = triangles[i];\n        vec3 a = points[triangle[0]];\n        vec3 b = points[triangle[1]];\n        vec3 c = points[triangle[2]];\n        \n        float t;\n        if (intersectTriangle(ray, a, b, c, t) && t < t0) \n    \t{\n            t0 = t;\n        \tcolor = vec3(1.0);\n    \t}\n    }\n    \n    for (int i=0; i<lenL; i++) \n    {\n        ivec2 line = lines[i];\n        vec3 a = points[line[0]];\n        vec3 b = points[line[1]];\n        \n        float t;\n        vec3 normal;\n        if (intersectLine(ray, a, b, 0.02, t) && t < t0)\n        {\n            t0 = t;\n            color = vec3(0.0);\n        }\n    }\n                                                                   \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    const float fov = pi / 2.0;\n    float step = 1.0 / float(SAMPLES);\n    \n \n    int i = 0;\n    int j = 0;\n    vec3 outColor = vec3(0.0, 0.0, 0.0);\n    \n    for (i=0; i<SAMPLES; i++) \n    {\n        for (j=0; j<SAMPLES; j++)\n        {\n            Ray ray = createRayOrtographic(iResolution, (fragCoord + vec2(float(i) * step, float(j) * step)));//, fov);\n            outColor += trace(ray, fragCoord / iResolution.xy);          \n        }\n    }\n    \n    outColor /= float(SAMPLES * SAMPLES);\n    \n\tfragColor = vec4(tosRGB(outColor), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "const float epsilon = 0.000001;\nconst float pi = 3.14159265359;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\n\nfloat rand( vec2 co )\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rand3( vec2 co )\n{\n    float v0 = rand(co);\n    float v1 = rand(vec2(co.y, v0));\n    float v2 = rand(vec2(co.x, v1));\n    \n    return vec3(v0, v1, v2);\n}\n\nvec3 tosRGB( vec3 color )\n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec4 hsvToRgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nmat4 rotationMatrix( vec3 axis, float angle ) \n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix( vec3 t ) \n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                t.x, t.y, t.z, 1.0);\n}\n\nmat4 scaleMatrix( vec3 s ) \n{\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\n    \nstruct AABB \n{\n    vec3 Min;\n    vec3 Max;\n};\n    \nRay createRay( vec3 iResolution, vec2 screenPos, float fov )\n{\n    vec2 topLeft = vec2(-iResolution.x, -iResolution.y) * .5;\n    float z = (iResolution.x * .5) / abs(tan(fov / 2.0));\n\n    return Ray(vec3(0.0, 0.0, 0.0), normalize(vec3(topLeft + screenPos, -z)));\n}\n\nRay createRayOrtographic( vec3 iResolution, vec2 screenPos )\n{\n    vec2 topLeft = vec2(-iResolution.x, -iResolution.y) * .5;\n    vec2 pos = topLeft + screenPos;\n    pos /= iResolution.y / 2.0;\n\n    return Ray(vec3(pos, -1.0), normalize(vec3(0.0, 0.0, -1.0)));\n}\n\nvoid transform( inout Ray ray, mat4 mat )\n{\n\tray.Origin = (mat * vec4(ray.Origin, 1.0)).xyz;\n    ray.Dir = normalize(mat * vec4(ray.Dir, 0.0)).xyz;\n}\n\nvoid transformNormal( inout vec3 normal, mat4 mat )\n{\n    normal = normalize((mat * vec4(normal, 0.0)).xyz);\n}\n\nvoid transformPosition( inout vec3 pos, mat4 mat )\n{\n    pos = (mat * vec4(pos, 1.0)).xyz;\n}\n\nvoid reflectRay( inout Ray ray, vec3 pos, vec3 normal )\n{\n    ray.Origin = pos + normal * epsilon;\n    ray.Dir = reflect(ray.Dir, normal);\n}\n\nvec3 evalRay( Ray ray, float t )\n{\n    return ray.Origin + t * ray.Dir;\n}\n\nAABB createAABB( vec3 middle, vec3 halfWidth )\n{    \n    return AABB(middle - halfWidth, middle + halfWidth);\n}\n\nbool intersectAABB( Ray r, AABB aabb, out float t0, out float t1 )\n{\n    vec3 invR = 1.0 / r.Dir;\n    \n    vec3 tbot = invR * (aabb.Min-r.Origin);\n    vec3 ttop = invR * (aabb.Max-r.Origin);\n    \n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    \n    vec2 t = max(tmin.xx, tmin.yz);\n    t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    t1 = min(t.x, t.y);\n    \n    return t0 <= t1;\n}\n\nbool intersectTriangle( Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t )\n{\n    vec3 edge1, edge2, h, s, q;\n    float a,f,u,v;\n    \n    edge1 = v1 - v0;\n    edge2 = v2 - v0;\n    \n    h = cross(ray.Dir, edge2);\n    a = dot(edge1, h);\n    \n    if (a > -epsilon && a < epsilon)\n        return false;\n    \n    f = 1.0 / a;\n    s = ray.Origin - v0;\n    u = f * dot(s, h);\n    \n    if (u < 0.0 || u > 1.0)\n        return false;\n    \n    q = cross(s, edge1);\n    v = f * dot(ray.Dir, q);\n    \n    if (v < 0.0 || u + v > 1.0)\n        return false;\n    \n    // At this stage we can compute t to find out where the intersection point is on the line.\n    t = f * dot(edge2, q);\n    if (t > epsilon) // ray intersection\n    {\n        return true;\n    }\n    \n    // This means that there is a line intersection but not a ray intersection.\n    return false;\n}\n\nvec3 middle( AABB aabb )\n{\n    return (aabb.Min + aabb.Max) * .5;\n}\n\nvec3 normal( AABB aabb, vec3 pos )\n{\n    vec3 d1 = abs(aabb.Min - pos);\n    vec3 d2 = abs(aabb.Max - pos);\n    \n    vec3 n = -1.0 * vec3(lessThan(d1, vec3(epsilon)));\n\tn += vec3(lessThan(d2, vec3(epsilon)));\n\n    return normalize(n);\n}\n\n// \"Borrowed\" from iq shader: https://www.shadertoy.com/view/MtcXRf\nbool intersectCylinder( Ray ray, vec3 pa, vec3 pb, float ra, out float t )\n{\n    vec3 ro = ray.Origin;\n    vec3 rd = ray.Dir;\n    \n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return false;\n    h = sqrt(h);\n    float t1 = (-b-h)/a;\n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch ) \n    {\n        t = t1;\n        return true;\n    }\n    \n    return false;\n}\n\nbool intersectSphere( Ray r, vec4 sphere, out float t0, out float t1 )\n{\n    vec3 dv = r.Origin - sphere.xyz;\n    \n    float b = dot(r.Dir, dv) * 2.0;\n    float c = dot(dv, dv) - (sphere.w * sphere.w);\n    \n    float d = b * b - 4.0 * c;\n    if (d < 0.0)\n    {\n        return false;\n    }\n    \n    d = sqrt(d);\n    \n    float ta = (-b - d) * 0.5;\n    float tb = (-b + d) * 0.5;\n    \n    t0 = min(ta, tb);\n    t1 = max(ta, tb);\n        \n    return t0 <= t1;\n}\n    ",
        "name": "Common",
        "description": "",
        "type": "common"
      }
    ]
  }
}