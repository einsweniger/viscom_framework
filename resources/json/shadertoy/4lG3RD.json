{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4lG3RD",
      "date": "1510195486",
      "viewed": 241,
      "name": "Fog and terrain testing",
      "username": "BeardThings",
      "description": "A test scene for fog and terrain",
      "likes": 2,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "struct Material\n{\n    vec4\tm_Color;\n    vec4\tm_EmissiveColor;\n    float \tm_Specular;\n    float \tm_Reflection;\n    float \tm_Opacity;\n    float\tm_Refraction;\n};\n\nstruct WorldObject\n{\n    vec3 \t\tm_Position;\n    float \t\tm_Scale;\n    Material \tm_Material;\n    float \t\tm_DistanceField;\n};\n    \n// Constants\nconst float EPSILON = 0.01;\nconst int MAX_STEPS = 64;\nconst float STEP_REDUCTION = 1.0;\nconst float PI = 3.14159;\n\nconst float FOGGINESS_FACTOR = 1.0 / 20.0;\nconst float CONSTANT_FOG_FACTOR = 1.0;\nconst vec4 SKY_COLOR = vec4(0.5,0.6,0.7, 1.0);\nconst vec4 SUN_COLOR = vec4(1.0,0.9,0.7, 1.0);\nconst vec3 SUN_DIRECTION = vec3(cos(PI * 1.25), sin(PI * 1.25), 0.0);\nconst float SUN_POWER_FACTOR = 2.0;\n\n// Declarations\nvec4 PointLight(in vec3 point, in vec3 lightPosition, in Material color);\nvoid RenderImage(in vec3 point, out float stepSize, out Material color);\n\n// Math methods\nfloat LengthSquared(in vec3 vector)\n{\n    return vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;\n}\n\nfloat ShiftRange(in vec2 sourceRange, \n                 in vec2 destRange, \n                 in float value)\n{\n    float sourceMagnitude \t= sourceRange.y - sourceRange.x;\n    float destMagnitude \t= destRange.y - destRange.x;\n    \n    float unitValue = (value - sourceRange.x) / sourceMagnitude;\n    float shiftedValue = (value * destMagnitude) + destRange.x;\n    \n    return shiftedValue;\n}\n\nfloat Rand(vec2 randInput)\n{ \n    return fract(sin(dot(randInput, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat Noise(vec2 noiseInput) \n{\n    const vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(noiseInput), f = smoothstep(vec2(0.0), vec2(1.0), fract(noiseInput));\n    return mix(mix(Rand(b), Rand(b + d.yx), f.x), mix(Rand(b + d.xy), Rand(b + d.yy), f.x), f.y);\n}\n\nfloat Equal(in float left, \n            in float right)\n{\n    float under = step(left - EPSILON * 0.001, right);\n    float over \t= step(right, left + EPSILON * 0.001);\n    \n    return under * over;\n}\n\nvec2 ShiftRange(in vec2 sourceRange, \n                 in vec2 destRange, \n                 in vec2 value)\n{\n    float sourceMagnitude \t= sourceRange.y - sourceRange.x;\n    float destMagnitude \t= destRange.y - destRange.x;\n    \n    vec2 unitValue = (value - sourceRange.x) / sourceMagnitude;\n    vec2 shiftedValue = (value * destMagnitude) + destRange.x;\n    \n    return shiftedValue;\n}\n\nstruct Camera\n{\n    vec3 \tm_Position;\n    vec3 \tm_Up;\n    vec3 \tm_Forward;\n    vec3 \tm_Right;\n    float \tm_FocalDistance;\n};\n    \n// Global\nCamera g_MainCamera;\n\nvec3 RayDirection(in vec3 \tforward,\n                  in float \tfocalDistance,\n                  in vec3 \tright,\n                  in vec3 \tup,\n                  in vec2 \tscreenSpaceCoord,\n                  in float \taspectRatioXOverY)\n{\n    return normalize(forward * focalDistance + \n                     right * screenSpaceCoord.x * aspectRatioXOverY +\n                     up * screenSpaceCoord.y);\n}\n\nvec3 CalculateWorldPoint(in vec3 origin, \n                         in vec3 direction, \n                         in float stepSize)\n{\n    return origin + direction * stepSize;\n}\n\n    \n// Distance Field Methods:\n    \nfloat SphereDistanceField(in vec3 point, \n                         in float radius)\n{\n    \n    return length(point) - radius;\n}\n\nfloat BoxDistanceField(in vec3 point,\n                       in vec3 bounds)\n{\n    return length(max(abs(point)-bounds, 0.0));\n}\n\nfloat PlaneDistanceField(in vec3 point,\n                         in vec3 axis)\n{\n    return distance(point * axis, axis);\n}\n\nfloat CylinderDistanceField( vec3 point, float bounds )\n{\n  return length(point.xz)-bounds;\n}\n\nfloat CappedCylinderDistanceField( vec3 point, vec2 bounds )\n{\n  vec2 dist = abs(vec2(length(point.xz),point.y)) - bounds;\n  return min(max(dist.x,dist.y),0.0) + length(max(dist,0.0));\n}\n\nfloat EllipsoidDistanceField( in vec3 point, in vec3 bounds )\n{\n    return (length( point/bounds ) - 1.0) * min(min(bounds.x,bounds.y),bounds.z);\n}\n\nfloat CapsuleDistanceField( vec3 point, vec3 capsuleStart, vec3 capsuleEnd, float radius )\n{\n    vec3 pa = point - capsuleStart, ba = capsuleEnd - capsuleStart;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - radius;\n}\n                         \n                         \n          \n// Distortion Methods\n\nvec3 Translate(in vec3 point,\n               in WorldObject object)\n{\n    return point - object.m_Position;\n}\n\nvec3 Scale(in vec3 point,\n           in WorldObject object)\n{\n    return point / object.m_Scale;\n}\n               \n\nvec3 Repeat(in vec3 point,\n            in vec3 axis,\n            in vec3 repeatFactor)\n{\n    vec3 repeatedPoint;\n    repeatedPoint = mod(point, repeatFactor) - repeatFactor * 0.5;\n    repeatedPoint = repeatedPoint * axis + (vec3(1) - axis) * point;\n    \n    return repeatedPoint;\n}\n\n// Scene creation\nfloat Union(float left, float right)\n{\n    return min(left, right);\n}\n\nfloat Substraction(float source, float substract)\n{\n    return max(source, -substract);\n}\n\nfloat Intersection(float left, float right)\n{\n    return max(left, right);\n}\n\n// Retrieve the normal for the world\nvec3 CalculateWorldNormal(in vec3 point)\n{\n    const float SAMPLE_SIZE = 0.1;\n    vec3 gradient = vec3(0);\n    \n    float leftStep = 0.0;\n    float rightStep = 0.0;\n    Material unusedColor;\n    \n    RenderImage(point + vec3(SAMPLE_SIZE, 0,0), leftStep, unusedColor);\n    RenderImage(point - vec3(SAMPLE_SIZE, 0,0), rightStep, unusedColor);\n    gradient.x = leftStep - rightStep;\n    \n    RenderImage(point + vec3(0, SAMPLE_SIZE,0), leftStep, unusedColor);\n    RenderImage(point - vec3(0, SAMPLE_SIZE,0), rightStep, unusedColor);\n    gradient.y = leftStep - rightStep;\n    \n    RenderImage(point + vec3(0, 0,SAMPLE_SIZE), leftStep, unusedColor);\n    RenderImage(point - vec3(0, 0,SAMPLE_SIZE), rightStep, unusedColor);\n    gradient.z = leftStep - rightStep;\n    \n    return normalize(gradient);\n}\n\nfloat Mandlebrot(vec2 uv)\n{\n\tvec2 z = vec2(0.0);\n\n    for(int i=1; i<64; i++) \n    {\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + uv; \n        if(length(z) > 2.) \n        {\n           return float(i) / 64.;\n        }\n   \t}\n    \n    return 1.0;\n}\n\n\nvoid RenderImage(in vec3 point, \n                 out float stepSize, \n                 out Material material)\n{\n    \n    vec3 shapePoint = point;\n    // Create a floor\n    WorldObject floorPlane;\n    floorPlane.m_Position = vec3(0, -2.5, 0);\n    floorPlane.m_Material.m_Color = vec4(0.6, 0.6, 0.6, 1.0);\n    floorPlane.m_Material.m_Specular = 40.0;\n    floorPlane.m_Material.m_Opacity = 1.0;\n    \n    shapePoint = Translate(shapePoint, floorPlane);\n    \n   \n    //shapePoint.y += noiseResult;\n\n    \n    float scale = 1.0 / 5.0;\n    floorPlane.m_DistanceField = shapePoint.y - (-1.0 + Mandlebrot(point.xz * scale) * 1.0);\n    \n    //+ Mandlebrot(point.xz * scale)* 5.0\n    \n    stepSize =  floorPlane.m_DistanceField + shapePoint.y;\n\n}\n\nstruct PointLightData\n{\n    vec3 \tm_Position;\n    float \tm_AttenuationRadius;\n    float \tm_AttenuationExponent;\n    vec4 \tm_Color;\n};\n\n\n\nstruct DirectionalLightData\n{\n    vec4 m_Color;\n    vec3 m_Direction;\n};\n\nvec4 CalculateDirectionalLight(in vec3 point,\n                in DirectionalLightData light,\n                in Material material,\n                in vec3 normal)\n{\n    vec3 worldNormal = normal;\n    vec3 surfaceToLight = -light.m_Direction;\n    \n    \n    // Calculate how much diffuse\n    float diffuseFactor = max(dot(surfaceToLight, worldNormal), 0.0);\n    vec4 diffuseColor = vec4(1.0) * diffuseFactor;\n    \n    \n    \n    return diffuseColor;\n    \n}\n\n\nvec4 RenderLighting(in vec3 point,\n                    in Material material,\n                    in vec3 normal)\n{\n    DirectionalLightData centerLight;\n    centerLight.m_Direction = SUN_DIRECTION;\n    centerLight.m_Color = vec4(1.0,1.0,1.0, 1.0);\n    \n    vec4 lighting = CalculateDirectionalLight(point, centerLight, material, normal);\n    \n    \n    return lighting;\n}\n\nconst vec4 WORLD_COLOR = vec4(0, 0, 0, 1);\n\n\nvoid mainImage(out vec4 fragColor, \n               in vec2 fragCoord )\n{\n    \n    vec4 finalColor = WORLD_COLOR;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenSpace = ShiftRange(vec2(0, 1), vec2(-1, 1), uv);\n    \n    Camera camera;\n    camera.m_Position \t\t= vec3(cos(iTime) * 7.0,2.0,sin(iTime)*7.0);\n    camera.m_Up \t\t\t= vec3(0,1,0);\n    camera.m_Forward \t\t= normalize(vec3(0) - camera.m_Position);\n    camera.m_Right\t\t\t= normalize(cross(camera.m_Up, camera.m_Forward));\n    camera.m_FocalDistance \t= 1.0;\n    vec3 cameraRay = RayDirection(camera.m_Forward,\n                                  camera.m_FocalDistance,\n                                  camera.m_Right,\n                                  camera.m_Up,\n                                  screenSpace,\n                                  iResolution.x / iResolution.y);\n    \n    g_MainCamera = camera;\n    \n    float previousStep = 0.0;\n    float currentStep = 0.0;\n    \n    vec3 worldPoint = vec3(0.0);\n    for(int i = 0; i < 64; ++i)\n    {\n        worldPoint = CalculateWorldPoint(camera.m_Position, cameraRay, currentStep);\n        \n        Material objectMaterial;\n        float renderStep = 0.0;\n        \n        RenderImage(worldPoint, renderStep, objectMaterial);\n        \n        // multiply the epsilon to be more lenient towards the back\n        if(renderStep < 0.01)\n        {\n            vec3 normal = CalculateWorldNormal(worldPoint);\n            vec4 lightingColor =  RenderLighting(worldPoint, objectMaterial, normal);\n            \n            finalColor = lightingColor;\n            \n           \n            break;\n        }\n        \n        previousStep = renderStep;\n        currentStep += renderStep * (float(i) / 64.0);\n    }\n    \n    \n    float sunAmount = max( dot( cameraRay, -SUN_DIRECTION ), 0.0 );\n    vec4  fogColor  = mix( vec4(0.4,0.6,0.7,1.0), // bluish\n                           vec4(1.0,0.9,0.7,1.0), // yellowish\n                           pow(sunAmount,10.0) );\n    \n    float b = 0.03;\n    finalColor = mix(finalColor, fogColor, 1.0 - exp(-currentStep*b));\n    \n\tfragColor = finalColor;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}