{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "lslcDH",
      "date": "1488193938",
      "viewed": 252,
      "name": "Raycast to a box sample",
      "username": "0xAA55",
      "description": "A simple sample demonstrates how to raycast a box.",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "math",
        "raycast",
        "box",
        "plane",
        "sample"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 36,
            "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm",
            "ctype": "video",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "\nfloat PI = 3.1415926535897932384626;\nvec3 eyepos = vec3(0.0, 0.0, -5.0);\nvec2 yawpitch = vec2(0, 0);\n\n#define FLT_MAX 10000.\n\nstruct box_t\n{\n    vec3 p, d;\n    mat3 r;\n};\n\nmat3 RotXAxis(float ang)\n{\n    return mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(ang),-sin(ang)),\n        vec3(0.0, sin(ang), cos(ang))\n    );\n}\n\nmat3 RotYAxis(float ang)\n{\n    return mat3\n    (\n        vec3(cos(ang), 0.0, sin(ang)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(ang), 0.0, cos(ang))\n    );\n}\n\nmat3 RotZAxis(float ang)\n{\n    return mat3\n    (\n        vec3( cos(ang), sin(ang), 0.0),\n        vec3(-sin(ang), cos(ang), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 RotAxis(vec3 v, float ang)\n{\n    return mat3\n    (\n        vec3\n        (\n            (1.0f - cos(ang)) * v.x * v.x + cos(ang),\n            (1.0f - cos(ang)) * v.x * v.y - sin(ang) * v.z,\n            (1.0f - cos(ang)) * v.x * v.z + sin(ang) * v.y\n        ),\n        vec3\n        (\n            (1.0f - cos(ang)) * v.y * v.x + sin(ang) * v.z,\n            (1.0f - cos(ang)) * v.y * v.y + cos(ang),\n            (1.0f - cos(ang)) * v.y * v.z - sin(ang) * v.x\n        ),\n        vec3\n        (\n            (1.0f - cos(ang)) * v.z * v.x - sin(ang) * v.y,\n            (1.0f - cos(ang)) * v.z * v.y + sin(ang) * v.x,\n            (1.0f - cos(ang)) * v.z * v.z + cos(ang)\n        )\n    );\n}\n    \nmat3 EulerRotation(vec3 ypr)\n{\n    return RotZAxis(ypr.z) * RotXAxis(ypr.y) * RotYAxis(ypr.x);\n}\n\nvec4 Plane_Normalize(vec4 p)\n{\n    float leng = length(p.xyz);\n    vec4 n = p / vec4(leng);\n    return n;\n}\n\n// n_plane stand for normalized plane\nfloat Plane_DistToPoint(vec4 n_plane, vec3 p)\n{\n    return abs(dot(n_plane.xyz, p) + n_plane.w);\n}\n\n// n_plane stand for normalized plane, n_ray stand for normalized ray\nfloat Plane_Raycast_Dist(vec4 n_plane, vec3 start, vec3 n_ray)\n{\n    float ratio = -dot(n_ray, n_plane.xyz);\n    return (dot(n_plane.xyz, start) + n_plane.w) / ratio;\n}\n\nvec3 Plane_Raycast_Point(vec4 n_plane, vec3 start, vec3 n_ray)\n{\n    return start + n_ray * Plane_Raycast_Dist(n_plane, start, n_ray);\n}\n\nbool Plane_Raycast_Point_Front(vec4 n_plane, vec3 start, vec3 n_ray, out vec3 castpoint, out float castdist)\n{\n\tcastdist = Plane_Raycast_Dist(n_plane, start, n_ray);\n\tif(castdist <= 0.)\n\t\treturn false;\n\tcastpoint = start + n_ray * castdist;\n    return true;\n}\n\nvec4 Plane_FromPointNormal(vec3 point, vec3 n_normal)\n{\n    float dist_to_org = dot(point, n_normal);\n    return vec4(n_normal, -dist_to_org);\n}\n\nbool Box_Raycast(box_t box, vec3 start, vec3 n_ray, out vec3 castpoint, out vec3 normal, out vec2 uv, out float castdist)\n{\n    vec4 planes[6];\n    vec4 cur_plane;\n    planes[0] = Plane_FromPointNormal(box.p + box.r[0] * box.d.x, +box.r[0]);\n    planes[1] = Plane_FromPointNormal(box.p + box.r[1] * box.d.y, +box.r[1]);\n    planes[2] = Plane_FromPointNormal(box.p + box.r[2] * box.d.z, +box.r[2]);\n    planes[3] = Plane_FromPointNormal(box.p - box.r[0] * box.d.x, -box.r[0]);\n    planes[4] = Plane_FromPointNormal(box.p - box.r[1] * box.d.y, -box.r[1]);\n    planes[5] = Plane_FromPointNormal(box.p - box.r[2] * box.d.z, -box.r[2]);\n    \n    float backdist = FLT_MAX;\n    float frontdist = 0.;\n    int curplane = 6;\n    for(int i = 0; i < 6; i++)\n    {\n    \tif(dot(planes[i].xyz, n_ray) < 0.)\n        {\n            float planedist = Plane_Raycast_Dist(planes[i], start, n_ray);\n            if(planedist >= frontdist)\n            {\n                frontdist = planedist;\n                curplane = i;\n                cur_plane = planes[i];\n            }\n        }\n        else\n        {\n            float planedist = Plane_Raycast_Dist(planes[i], start, n_ray);\n            if(backdist >= planedist)\n            {\n                backdist = planedist;\n            }\n        }\n    }\n\t\n    if(frontdist >= backdist || curplane == 6)\n        return false;\n    \n    castdist = frontdist;\n    castpoint = start + n_ray * frontdist;\n    normal = cur_plane.xyz;\n    if(curplane == 0)uv = vec2(Plane_DistToPoint(planes[5],castpoint) / box.d.z, Plane_DistToPoint(planes[4],castpoint) / box.d.y) * .5;\n    else if(curplane == 1)uv = vec2(Plane_DistToPoint(planes[3],castpoint) / box.d.x, Plane_DistToPoint(planes[2],castpoint) / box.d.z) * .5;\n    else if(curplane == 2)uv = vec2(Plane_DistToPoint(planes[0],castpoint) / box.d.x, Plane_DistToPoint(planes[4],castpoint) / box.d.y) * .5;\n    else if(curplane == 3)uv = vec2(Plane_DistToPoint(planes[2],castpoint) / box.d.z, Plane_DistToPoint(planes[4],castpoint) / box.d.y) * .5;\n    else if(curplane == 4)uv = vec2(Plane_DistToPoint(planes[3],castpoint) / box.d.x, Plane_DistToPoint(planes[5],castpoint) / box.d.z) * .5;\n    else uv = vec2(Plane_DistToPoint(planes[3],castpoint) / box.d.x, Plane_DistToPoint(planes[4],castpoint) / box.d.y) * .5;\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 mouse_rotation = ((iMouse.xy / iResolution.y) * 2. -1.) * PI;\n    \n    mat3 RotMat = RotXAxis(-mouse_rotation.y)\n        * RotYAxis(mouse_rotation.x)\n        * EulerRotation(vec3(iTime * .2, 0, 0));\n    \n    vec3 ray = normalize(vec3(xy, 1));\n    \n    vec4 color = vec4(.2, .5, 1., 1.);\n    \n    vec3 castpnt, castnormal;\n    vec2 castuv;\n    float castdist;\n\n    box_t bx=box_t(vec3(0, 0, 0), vec3(1, 1, 1), RotMat);\n    if(Box_Raycast(bx, eyepos, ray, castpnt, castnormal, castuv, castdist))\n\t{\n        color = texture(iChannel0, castuv);//vec4(castnormal * .5 + .5, 0);\n\t}\n    \n\tfragColor = color;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}