{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ldjBDh",
      "date": "1500324283",
      "viewed": 183,
      "name": "HDR HSV Colour Picker",
      "username": "TekF",
      "description": "Little prototype idea for an HDR colour picker, thought I'd share it in case someone found it useful.\nValue slider is HDR (logarithmic), and colours are normalized in actual brightness.\n",
      "likes": 1,
      "published": 3,
      "flags": 32,
      "tags": [
        "hdr",
        "tool"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "vec3 componentWeights = vec3(.2126,.7152,.0722); // from https://en.wikipedia.org/wiki/Relative_luminance\n\n// tone mapping functions - add with your own to get a more accurate preview\n\n// clamped linear tone mapping\nvec3 ToneMappingSRGB( vec3 col )\n{\n\treturn pow(col,vec3(1./2.2));\n}\n\n// tone mapping, from my Docking Spacecraft shader\nvec3 ToneMappingBQ( vec3 col )\n{\n    const float a = 1.; // exposure\n    const float p = 3.; // top curve - 1. = very smooth, higher = more squashed\n    const float r = 1.; // overflow - 1. = no clipping, higher => more clipping\n    \n    const float d = .05; // desaturation of bright colours\n    float brightness = dot(col,componentWeights);\n    col = mix( vec3(brightness), col, 1./(1.+d*brightness) );\n    col = r*pow(max(vec3(.0000001),1.-1./(1.+pow(a*col/r,vec3(p)))),vec3(1./p));\n    \n\treturn pow(col,vec3(1./2.2));\n}\n\nvec3 GetCol( vec2 uv, float val )\n{\n    float r = pow(length(uv),.5);\n\n    float a = atan(uv.x,uv.y);\n    vec3 col = smoothstep(-.5,1.,cos(a+6.28*vec3(0,1,2)/3.));\n    \n// test component brightness\n//a = fract(a*150./6.283); col = step(fract(a-vec3(0,componentWeights.x,componentWeights.x+componentWeights.y)),componentWeights);\n    \n    col = mix( vec3(1.), col, r );\n    col /= dot(col,componentWeights); // relative brightnesses\n\n\tcol *= exp2(val*8.-6.);\n    \n    return ToneMappingBQ( col );\n}\n\nfloat boxDist( vec2 uv )\n{\n    uv = abs(uv);\n    return max(uv.x,uv.y);\n}\n\nvec3 Dither( ivec2 coord )\n{\n    return (vec3( (coord.x&1)+2*(coord.y&1) )/4.-.5) / 256.;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float val = texelFetch(iChannel0,ivec2(0),0).x;\n    \n\tvec2 uv = 2. * fragCoord.xy / iResolution.y - 1.;\n    \n\tfragColour = vec4(GetCol(vec2(0),val),1);\n\n    // colour circle\n    float r = length(uv);\n    if ( r < 1. )\n    {\n        fragColour.rgb = GetCol(uv,val);\n    }\n    \n    // slider\n    if ( length(vec2(abs(uv.x-2.), max(abs(uv.y)-.7,.0))) < .1 )\n    {\n        fragColour = vec4(.5);\n        \n        float but = length(vec2( uv.x-2., uv.y-(val*2.-1.)*.7 ));\n\t\tif ( but < .1 )\n        {\n            fragColour = vec4(1);\n        }\n    }\n    \n    // selected colour box-out\n    vec4 uvm = 2.*iMouse/iResolution.y-1.;\n    r = boxDist(uv - vec2(1.4,-.16)); //uvm.xy);\n    if ( length(uvm.xy) < 1. && length(uvm.zw) < 1. && r < .25 )\n    {\n        fragColour.rgb = r < .24 ? GetCol(uvm.xy,val) : vec3(0);\n    }\n    \n    // last selected colour\n    r = boxDist(uv-vec2(1.4,-.65));\n    if ( r < .25 )\n    {\n        vec4 data = texelFetch(iChannel0,ivec2(1,0),0);\n        fragColour.rgb = r < .24 ? GetCol(data.xy,data.z) : vec3(0);\n    }\n    \n    fragColour.rgb += Dither(ivec2(fragCoord));\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "// user interface state\n\nvoid mainImage( out vec4 result, in vec2 index )\n{\n    result = vec4(0);\n    if ( index.y >= 1. ) return;\n\n    vec4 uvm = 2.*iMouse/iResolution.y-1.;\n        \n    if ( index.x < 1. )\n    {\n        // HDR slider\n    \tresult = texelFetch( iChannel0, ivec2(0), 0 );\n        \n        if ( abs(uvm.z-2.) < .1 && abs(uvm.w) < .8 )\n        {\n            result.x = clamp((uvm.y/.7)*.5+.5,.0,1.);\n        }\n    }\n    else if ( index.x < 2. )\n    {\n        // Last clicked colour\n        result = texelFetch( iChannel0, ivec2(1,0), 0 );\n        \n        if ( length(uvm.xy) < 1. && iMouse.z <= .0 )\n        {\n        \tresult.xy = uvm.xy;\n            result.z = texelFetch( iChannel0, ivec2(0), 0 ).x;\n        }\n    }\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}