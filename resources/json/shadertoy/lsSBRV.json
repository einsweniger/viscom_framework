{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "lsSBRV",
      "date": "1501128007",
      "viewed": 234,
      "name": "Single rotation",
      "username": "stduhpf",
      "description": "Tis cellular automata is reversible, and can produce oscillators, spaceships , and indestructible structures.\nIt does also have cool proporties due to its reversibility, for example when two structures collide, it can't make an oscillator, so it diverges.",
      "likes": 1,
      "published": 3,
      "flags": 48,
      "tags": [
        "2d",
        "cellularautomata",
        "revesible"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "#define zoom 4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv/zoom);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 33,
            "src": "/presets/tex00.jpg",
            "ctype": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "#define Speed 0\n\nfloat hash(vec2 p) {\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(iDate.w+ (p3.x + p3.y) * p3.z);\n}\n\nfloat getPoint(vec2 fc)\n{   return float( texture(iChannel0,fract(fc/iResolution.xy)).a > .9 ); }\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int speed = Speed*4+1;\n    float par = mod( float(iFrame/speed), 2.);\n    vec2 pos =  mod(U-.5+par ,2.)*2.-1.;\n       \n    float neighbohrs =  getPoint(U-vec2(0,1)*pos)\n                      + getPoint(U-          pos)\n                      + getPoint(U-vec2(1,0)*pos);\n    \n    float state = getPoint(U) *neighbohrs;\n    if(neighbohrs==1.&& state==0.)\n    {\tvec2  apos = floor( (U-.5+par) /2.) *2.,\n              pos2 = vec2(pos.y,-pos.x) *.5 + .5;\n        state = getPoint(.5+(apos+pos2-par));\n    }\n\n    O = iFrame < 1 || texture(iChannel1,vec2(.126,.1) ).r > 0. \n        ? vec4(hash(U)>.8)\n        : vec4(neighbohrs/3.,vec3(state));\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}