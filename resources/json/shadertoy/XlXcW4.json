{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XlXcW4",
      "date": "1504747362",
      "viewed": 473,
      "name": "Integer Hash - II",
      "username": "iq",
      "description": "Based on [url=https://www.shadertoy.com/view/4tfyW4]4tfyW4[/url]. but simpler and faster. See [url]https://www.shadertoy.com/view/llGSzw[/url] too.",
      "likes": 13,
      "published": 3,
      "flags": 0,
      "tags": [
        "2d",
        "hash"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// 2017 Inigo Quilez\n\n// Based on https://www.shadertoy.com/view/4tfyW4, but simpler and faster\n//\n// See these too: \n//\n// - https://www.shadertoy.com/view/llGSzw\n// - https://www.shadertoy.com/view/XlXcW4\n// - https://www.shadertoy.com/view/4tXyWN\n//\n// Not testes for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n\n\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 p = uvec3(fragCoord, iFrame);\n    \n    fragColor = vec4( hash(p), 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}