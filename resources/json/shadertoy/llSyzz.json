{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "llSyzz",
      "date": "1507157349",
      "viewed": 456,
      "name": "the ride never ends",
      "username": "ollj",
      "description": "quaternion Mouselook! (pitch yaw) lets you follow any path easily without gimbal lock\nArrow.Up-Down=accelerate\nArrow Left-Right=roll\n\nhttps://www.shadertoy.com/view/4tSyRz\nwith the distance field of\nhttps://www.shadertoy.com/view/llSyRR",
      "likes": 10,
      "published": 3,
      "flags": 48,
      "tags": [
        "truchet",
        "quaternion",
        "vr",
        "marbles",
        "fly",
        "dynamiceps",
        "edynvr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 33,
            "src": "/presets/tex00.jpg",
            "ctype": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n\nparent: https://www.shadertoy.com/view/llSyRR\n   truchet mable distance field gradient\n\n\nthe TnL of one parent doesnt work too well with the shape of the other parent.\nThis is a qquck merger that is not too much of an eyesore.\n\nAn odd mix of surface normal and phong?\nits fractal AO (cares for smalles last 4 marches)\n without shadows also makes it look uncanny.\n*/\n\n//- - resource hogs and StackHeap Crashers:\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .00001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 156\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n#define doFog\n//for the way that TnL is done here, fog is actually quite useful\n//normally i hate distance fog, but the TnL of this shader uses it nicely\n\n//- - shape and TnL:\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 4.\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n//do specular light, fake reflectio of sunlight\n#define doSpec\n//this sloppy merger is better doing doNormals AND doThuchetCoaster , or None!\n//mostly because the fractal shape has \"special\" defined \"normals\"\n//otherwise the [texturing and Lighting] does not match the [shape] too well.\n#if 1\n //truchet setting\n #define doNormals\n #define doThuchetCoaster\n#else\n //fratal setting\n //max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n #define iterDfFractal 4.\n //cut off half of the distance field along a plane that that the .y axis as its normal.\n #define cutY\n#endif\n\n//- - controls:\n#define THRUST 0.02*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//todo: TOO_CLOSE should internally scale with movement speed\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//---lib.core:\n#define sat(a) clamp(a,.0,1.)\n\n\n//---lib.buffer, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n//---lib.quaterion\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n/*\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nvec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\nvec4 qslerp(vec4 q1, vec4 q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*/\n\n//---lib.shape:\nvec3 Tile(vec3 p){vec3 a=vec3(8.0);return abs(mod(p,a)-a*0.5)-a*0.25;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\nfloat torus(vec3 p,vec2 r){\n return length(vec2(abs(abs(length(p.xy)-r.x)-.1),abs(p.z)-.1))-r.y;}\nfloat square(vec3 p,vec2 r){\n return length(vec2(abs(max(abs(p.x),abs(p.y))-r.x),p.z))-r.y;}\n\n//----lib.color\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//----lib.hash for scatter-noise\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p){p=fract(p*HASHSCALE3)\n;p+=dot(p,p.yxz+19.19);return fract((p.xxy+p.yxx)*p.zyx);}\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n\n\n\n//---lib.setting: (BVHs and fuzzy-boolean mixes of shapes)\n#define u2(a) ((a)*2.-1.)\n//truched3dcoaster\nfloat thuchetCoaster(vec3 p)\n{vec3 p2 = mod(p,2.)-1.\n;vec3 floorpos=floor(p*.5)\n;float len=1e10\n;vec3 orientation = u2(floor(hash33(floorpos)+0.5))\n;vec3 p3 = p2*orientation\n;mat3 truchet=mat3\n(vec3(p3.yz*vec2(1, 1)+vec2(-1,-1),p3.x)\n,vec3(p3.zx*vec2(1, 1)+vec2( 1, 1),p3.y)\n,vec3(p3.yx*vec2(1,-1)+vec2( 1, 1),p3.z))\n;vec3 lens=vec3\n(torus(truchet[0],vec2(1.0,0.02))\n,torus(truchet[1],vec2(1.0,0.02))\n,torus(truchet[2],vec2(1.0,0.02)))\n;vec3 mask = vec3(lessThan(lens,min(lens.yzx,lens.zxy)))\n;vec3 p4 = truchet[int(dot(mask,vec3(0,1,2)))]\n;float dir = u2(mod(dot(floorpos,vec3(1.0)),2.0))//*dot(mask,vec3(-1.0,1.0,-1.0));\n;p4=vec3(fract(dir*(atan(p4.x,p4.y)/6.28*4.0)+iTime*0.5)-0.5,length(p4.xy)-1.0,p4.z)\n;return min(dot(lens,mask),length(p4)-0.1);\n}//https://www.shadertoy.com/view/llSyRR\n\n\n//return signed euclidean distane of[u] to a surface, gradient3d (imagine static thermodynamics)\nfloat gd(vec3 u){//gradient differential, signed distance field:\n#ifdef doThuchetCoaster\nreturn thuchetCoaster(u);\n#else\nvec3 p=Tile(u)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;for(float n=.0;n<iterDfFractal;n++ //fractal\n){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==2.)dG=DERect(z,rcL);\n}\n;dG=min(dG,DERect(z,rc))\n#ifdef cutY\n;dG=max(dG,u.y);\n#endif\n;return dG;\n#endif\n;}\n\n//return first derivative of the gd()\n//FAST non-analytic 3pass estimate of first derivative of map() == normals3d\nvec3 normal(vec3 p, float l){vec2 e=vec2(.1,0)\n;return normalize(vec3\n(l-gd(p-e.xyy)\n,l-gd(p-e.yxy)\n,l-gd(p-e.yyx)));}//todo, replace with \"automatic differentiation\"\n//1passPerDoman is less precise than 2passPerDomain variant, but not by much.\n\n//A variant of gd(), that is HERE used to get a color and to derive a surface normal.\n//the inout vec4 mcol is a big difference.\n//gd1 exists because the fractal shape gets \"specual treatment\" for color\n//, due to \"nnormals being tricky within a KIFS\"\nfloat gd1(vec3 p,inout vec4 mcol)\n{p=Tile(p)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;vec4 mc=vec4(0)\n;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n ;else if(n==2.)dG=DERect(z,rcL);\n}float ds=DERect(z,rc)\n;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n;else mcol+=mc\n;return min(dG,ds);}\n\n//return [c]color, modified by distance fog\n//[ts] DistanceToCamera [is a delta [time since] photon got emmited]\n//there is no such thing as global distance, but there is a global speed if light.\n//[f] FogColor (assume a cosmic microwave background image pixel)\n//,designed for a zFar of 20, scales, but not too well.\nvec3 fog(float ts,vec3 c,vec3 f){\n//;float fog=min(pow(ts*.2,1.33)*.54,1.)//only for zFar=20.\n;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zFar=20.\n//must be reciprocal log() ?\n;return mix(c,f,fog);}\n\n//return ambient occlusion\n//[o] LightSourcePosition\n//[d] LightDirection\n//[s] ScatterHash\nfloat AO(in vec3 p,in vec3 d,float s){\n;float t=.0,a=1.,f,n=.01+.04*s\n;for(float i=.0;i<iterAO;i++ \n){f=max(gd(p+d*t)*1.5,n)\n ;a=min(a,f/t+t*0.5)\n ;t+=f;\n}return a;}//soft shadow with \"noisy lens\".\n\n#ifdef doShade\n //return occluded specular of [r]\n //[r]accumulator to return, ends up being \"phong glossy\"\n //[o]rigin\n //[d]direction\n //[p]point in space; p=o+d*ts.x\n //[N]surfaceNormal at [p]\n //[s]ScatterHash\n //[mcol] materialColor (diffuse)\n vec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 p,vec3 o,float s,vec4 mcol){\n ;float l=dot(N,sunDir)//sundir must be normalized\n #ifdef doAO\n ,shad=AO(p+N*.001,sunDir,s)//shadow\n #else\n ,shad=.5\n #endif\n #ifdef doSpec\n ;float v=dot(-d,N)\n ;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n ,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n ;float cd=exp(-distance(o,p))\n ;vec3 R=reflect(d,N)\n ;float spcl=pow(sat(dot(R,sunDir)),10.)\n ,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n ;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n #endif\n ;r=sat(r)\n ;return r;}\n#endif\n\n//-------------------------main renderer\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  #ifndef doNormals \n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  #else\n  ;vec3 N=normal(so,eps)*.5+.5\n   #endif\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qmulv(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u ){\n    ;vec4 p,qrot\n;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n}else{//next frame\n ;p=load(0);qrot=load(1)//load state from previous frame\n ;vec3 fw=vec3(0,0,1)\n ;fw=qmulv(qrot,fw) //this can be done simpler\n ;vec3 newp=p.xyz+fw*p.w*.2\n ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n ;else\n  {if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n  ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n  ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n }\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-iMouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}\n",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}