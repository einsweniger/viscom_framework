{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "Xlc3Dn",
      "date": "1468576136",
      "viewed": 396,
      "name": "multipass zoom/radial blur",
      "username": "seniltai",
      "description": "multipass radial/zoom blur based on ryg's comments on pouet in 2008",
      "likes": 8,
      "published": 3,
      "flags": 32,
      "tags": [
        "blur",
        "zoom",
        "radial",
        "multipass"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 260,
            "src": "/media/previz/buffer03.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "#define STEPSIZE_SEQ 3.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 28,
            "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 47,
            "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
            "ctype": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "// camera attributes\n// cameraDirection and cameraUp MUST be normalized\n// (ie. their length must be equal to 1)\nconst vec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\nfloat fovy = fovx * iResolution.y/iResolution.x;\nfloat ulen = tan(fovx);\nfloat vlen = tan(fovy);\n\n// epsilon-type values\nconst float S = 0.1;\nconst float EPSILON = 0.001;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    return length(p) - 1.0;\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\n\nfloat computeLambert(vec3 p, vec3 n, vec3 l){\n    float ndotl = clamp(dot(normalize(l-p), n), 0.0, 1.0);\n    return pow(ndotl, 1.0/2.2);\t// dirty srgb\n}\n\nvec2 computeLatLong(vec3 n)\n{\n \treturn vec2(atan(n.y,sqrt(dot(n.xz, n.xz))), atan(n.z,n.x));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            vec3 normal = computeSurfaceNormal(hit);\n            vec2 latlon = computeLatLong(normal);\n            float lighting = computeLambert(hit, normal, light);\n            latlon.xy += iTime;\n            vec3 tex = texture(iChannel0, latlon).xyz;\n            vec3 texInv =  texture(iChannel1, latlon).xyz;\n            result =  pow(mix(tex, texInv, lighting), vec3(4.0))*4.0;\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    // generate the ray for this pixel\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 258,
            "channel": 0
          }
        ],
        "code": "#define STEPSIZE_SEQ 0.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 16.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}",
        "name": "Buf B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 259,
            "channel": 0
          }
        ],
        "code": "#define STEPSIZE_SEQ 1.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}",
        "name": "Buf C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 260,
            "channel": 0
          }
        ],
        "code": "#define STEPSIZE_SEQ 2.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}",
        "name": "Buf D",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}