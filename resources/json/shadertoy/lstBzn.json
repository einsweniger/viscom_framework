{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "lstBzn",
      "date": "1524055261",
      "viewed": 140,
      "name": "Ink Thing",
      "username": "pendingchaos",
      "description": "Kind of mimicking Splatoon 2's ink I guess.\n\nHold LMB and drag to draw. Hold C while dragging to clear instead of draw.\n\nPress S to create a predetermined wavy line.\nPress F to fill the entire image with ink and E to empty the image of ink.",
      "likes": 4,
      "published": 3,
      "flags": 48,
      "tags": [
        "2d",
        "mouse",
        "draw",
        "ink"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 1,
            "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
            "ctype": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 260,
            "src": "/media/previz/buffer03.png",
            "ctype": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Copyright (C) 2018 pendingchaos\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n//Display\nvec3 getNormal(in vec2 fragCoord) {\n    vec3 val = vec3(0.0);\n    for (int x = -3; x<=3; x++)\n        for (int y = -3; y<=3; y++)\n            val += texelFetch(iChannel1, ivec2(fragCoord)+ivec2(x, y), 0).xyz;\n    return normalize(val);\n}\n\n//From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//From https://www.shadertoy.com/view/4djSRW\nvec4 hash42(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nbool box(in vec2 p, in vec2 center, in vec2 halfSize, in vec2 skew) {\n    p -= center;\n    p.x += tan(skew.x)*p.y;\n    p.y += tan(skew.y)*p.x;\n    return clamp(p, -halfSize, halfSize) == p;\n}\n\nvec4 speck(in vec2 fragCoord, in vec3 baseColor) {\n    fragCoord *= 2.5;\n    vec2 bucket = floor(fragCoord/20.0) * 20.0;\n    vec4 bh = hash42(bucket);\n    vec4 bh2 = hash42(bucket*bucket);\n    fragCoord -= bh.yz*14.0 - 7.0;\n    float skew = bh.x*1.2 - 0.6;\n    float size = pow(bh.w, 2.0) * 5.0;\n    bool res = box(fragCoord, bucket+vec2(10), vec2(size), vec2(-skew, skew));\n    if (res)\n        return vec4(baseColor*1.2*(bh2.x*0.8+0.6), 1.0);\n    else\n        return vec4(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 normal = getNormal(fragCoord);\n    vec3 color = vec3(0.4, 1.0, 0.1); //green\n    //color = vec3(1.0, 0.1, 1.0); //purple or something\n    //color = vec3(0.1, 0.4, 1.0); //blue\n    //color = vec3(1.0, 0.0, 0.0); //kinda-orangey red\n    //color = vec3(1.0, 0.5, 0.0); //yellowy orange\n    //color = hsv2rgb(vec3(0.93, 1.0, 1.0)); //pink or something\n    color = hsv2rgb(vec3(fragCoord.x/iResolution.x, 1.0, 1.0)); //all the colors\n    float depth = texture(iChannel0, fragCoord/iResolution.xy).y;\n    vec3 background = texture(iChannel2, fragCoord/iResolution.xy).rgb;\n    vec3 lightDir = normalize(vec3(1.0, 0.0, -1.0));\n    float light = dot(normal, -lightDir) * 0.25 + 0.75;\n    \n    vec3 halfwayDir = normalize(-lightDir + vec3(0.0, 1.0, 0.0));\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 16.0) * 0.5;\n    \n    vec4 speckRes = speck(fragCoord, color);\n    \n    fragColor.rgb = background;\n    fragColor.rgb = mix(fragColor.rgb, color*light+spec, depth);\n    fragColor.rgb = mix(fragColor.rgb, speckRes.rgb, speckRes.a*pow(depth, 16.0));\n    fragColor.a = 1.0;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "// Copyright (C) 2018 pendingchaos\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n//Mouse information\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 prev = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    if (iFrame == 0)\n        prev = iMouse;\n    \n    if (ivec2(fragCoord) == ivec2(0, 0))\n        fragColor = iMouse;\n    else if (ivec2(fragCoord) == ivec2(1, 0))\n        fragColor = prev;\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 33,
            "src": "/presets/tex00.jpg",
            "ctype": "keyboard",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 258,
            "channel": 0
          }
        ],
        "code": "// Copyright (C) 2018 pendingchaos\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n//Drawing and \"Simulation\"\n#define RADIUS 1.0\n#define DOWNSCALE 8.0\n\n#define GAIN 0.025\n\n//From http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//From https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getMax(in vec2 fragCoord) {\n    float v = 1.0;\n    float left = hash12(vec2(floor(fragCoord.x/v), fragCoord.y));\n    float right = hash12(vec2(ceil(fragCoord.x/v), fragCoord.y));\n    float f = fract(fragCoord.x/v);\n    return max(0.05 + mix(left, right, f)*0.6, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //Drawing\n    vec4 prevMouse = texelFetch(iChannel1, ivec2(1, 0), 0) / vec4(DOWNSCALE, DOWNSCALE, 1.0, 1.0);\n    vec4 curMouse = iMouse / vec4(DOWNSCALE, DOWNSCALE, 1.0, 1.0);\n    \n    bool wavyLine = texelFetch(iChannel2, ivec2(83, 1), 0).x>0.5;\n    if (wavyLine) {\n        vec2 res = iResolution.xy / DOWNSCALE;\n        vec3 p = vec3(fragCoord, 0.0);\n        p.y += sin(fragCoord.x/res.x*8.0) * res.y * 0.1;\n        vec3 start = vec3(res*vec2(0.1, 0.5), 0.0);\n        vec3 end = vec3(res*vec2(0.9, 0.5), 0.0);\n        if (sdCapsule(p, start, end, min(res.x, res.y)*0.015) < 0.0)\n            fragColor.xy = vec2(1.0);\n    }\n    \n    bool fill = texelFetch(iChannel2, ivec2(70, 1), 0).x>0.5;\n    if (fill)\n        fragColor.xy = vec2(1.0);\n    \n    bool empty = texelFetch(iChannel2, ivec2(69, 1), 0).x>0.5;\n    if (empty || iFrame==0)\n        fragColor.xy = vec2(0.0);\n    \n    if (prevMouse.z>0.5 && curMouse.z>0.5 && prevMouse.xy!=curMouse.xy) {\n        vec2 start = prevMouse.xy;\n        vec2 end = curMouse.xy;\n        if (sdCapsule(vec3(fragCoord, 0.0), vec3(start, 0.0), vec3(end, 0.0), RADIUS) <= 0.0) {\n            bool clear = texelFetch(iChannel2, ivec2(67, 0), 0).x>0.5;\n            fragColor.x = clear ? 0.0 : 1.0;\n            if (!clear) fragColor.y = 1.0;\n        }\n    }\n    \n    //Simulation\n    if (fragColor.x > getMax(fragCoord) && fragCoord.y>0.0)\n       fragColor.x = clamp(fragColor.x*(1.0-GAIN), 0.1, 1.0);\n    \n    float up = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,1), 0).x;\n    if (up > getMax(fragCoord+vec2(0,1)))\n       fragColor.x = clamp(fragColor.x+up*GAIN, 0.1, 1.0);\n    \n    if (fragColor.x >= 0.1)\n        fragColor.y = min(fragColor.y+iTimeDelta*0.25, 1.0);\n}",
        "name": "Buf B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 4,
            "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
            "ctype": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 15,
            "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
            "ctype": "texture",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 259,
            "channel": 0
          }
        ],
        "code": "// Copyright (C) 2018 pendingchaos\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n//Upscale and Noise\n#define DOWNSCALE 8.0\n\nvec2 doSubSample(in vec2 coord) {\n    return texture(iChannel0, coord / iResolution.xy / DOWNSCALE).xy;\n}\n\nfloat doSample(in vec2 coord) {\n    vec2 val = vec2(0.0);\n    int radius = 4;\n    for (int x = -radius; x<=radius; x++) {\n        for (int y = -radius; y<=radius; y++) {\n            vec2 s = doSubSample(coord+vec2(x, y));\n            s.x = step(s.x, 0.1);\n            val += s;\n        }\n    }\n    val *= 1.0 / float(radius*radius*4 + radius*4 + 1);\n    vec2 detailCoord = coord / iResolution.xy / vec2(textureSize(iChannel2, 0)) * 100.0;\n    float s = texture(iChannel2, detailCoord).x;\n    float res = smoothstep(max(s-0.15, 0.0), min(s+0.15, 1.0), val.x);\n    val.x = smoothstep(0.35, 0.65, val.x);\n    //detail is faded in to make movement look better\n    res = mix(val.x, res, step(0.001, val.y));\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float depth = 1.0 - doSample(fragCoord);\n    float noise = texture(iChannel1, fragCoord/iResolution.xy*0.5).x;\n    fragColor.y = depth;\n    depth = depth*0.75 + noise*depth;\n    depth = depth / (depth+0.2);\n    fragColor.x = depth;\n}",
        "name": "Buf C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 260,
            "channel": 0
          }
        ],
        "code": "// Copyright (C) 2018 pendingchaos\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n//Normal calculation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float h = 1.0 - texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    vec3 pos = vec3(fragCoord.x, h*50.0, fragCoord.y);\n    vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));\n    normal.y *= -1.0;\n    fragColor = vec4(normal, 0.0);\n}",
        "name": "Buf D",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}