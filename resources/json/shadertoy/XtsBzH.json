{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XtsBzH",
      "date": "1511019320",
      "viewed": 206,
      "name": "Sphere in a room of mirrors",
      "username": "qwertsol",
      "description": "Reflective sphere in a room with reflective walls,",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "raytracing",
        "sphere",
        "reflections"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Square root of number of samples used for super-sampling\n#define SAMPLES 1\n\n// Maximum number of reflections\n#define MAX_STEPS 16\n\nconst float epsilon = 0.0001;\nconst float pi = 3.14159265359;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst float fov = pi / 2.0;\nconst vec3 lightDir = normalize(vec3(0.0, 2.0, 10.0));\n    \nmat4 rotationMatrix( vec3 axis, float angle ) \n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix( vec3 t ) \n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                t.x, t.y, t.z, 1.0);\n}\n\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\n    \nstruct AABB \n{\n    vec3 Min;\n    vec3 Max;\n};\n    \nAABB createCube( vec3 middle, float halfWidth )\n{\n    vec3 hf = vec3(halfWidth);\n    \n    return AABB(middle - hf, middle + hf);\n}\n\nRay createRay( vec2 screenPos )\n{\n    vec2 topLeft = vec2(-iResolution.x, -iResolution.y) * .5;\n    float z = (iResolution.x * .5) / abs(tan(fov / 2.0));\n\n    return Ray(vec3(0.0, 0.0, 0.0), normalize(vec3(topLeft + screenPos, -z)));\n}\n\nvoid transformRay( inout Ray ray, mat4 mat )\n{\n\tray.Origin = (mat * vec4(ray.Origin, 1.0)).xyz;\n    ray.Dir = normalize(mat * vec4(ray.Dir, 0.0)).xyz;\n}\n\nvoid transformNormal( inout vec3 normal, mat4 mat )\n{\n    normal = normalize((mat * vec4(normal, 0.0)).xyz);\n}\n\nvoid transformPosition( inout vec3 pos, mat4 mat )\n{\n    pos = (mat * vec4(pos, 1.0)).xyz;\n}\n\nvoid reflectRay( inout Ray ray, vec3 pos, vec3 normal )\n{\n    ray.Origin = pos + normal * epsilon;\n    ray.Dir = reflect(ray.Dir, normal);\n}\n\nvec3 getRayPos( Ray ray, float t )\n{\n    return ray.Origin + t * ray.Dir;\n}\n\nvec3 boxMiddle( AABB aabb )\n{\n    return (aabb.Min + aabb.Max) * .5;\n}\n    \nbool intersectBox( Ray r, AABB aabb, out float t0, out float t1 )\n{\n    vec3 invR = 1.0 / r.Dir;\n    \n    vec3 tbot = invR * (aabb.Min-r.Origin);\n    vec3 ttop = invR * (aabb.Max-r.Origin);\n    \n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    \n    vec2 t = max(tmin.xx, tmin.yz);\n    t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    t1 = min(t.x, t.y);\n    \n    return t0 <= t1;\n}\n\nbool intersectSphere( Ray r, vec4 sphere, out float t0, out float t1 )\n{\n    vec3 dv = r.Origin - sphere.xyz;\n    \n    float b = dot(r.Dir, dv) * 2.0;\n    float c = dot(dv, dv) - (sphere.w * sphere.w);\n    \n    float d = b * b - 4.0 * c;\n    if (d < 0.0)\n    {\n        return false;\n    }\n    \n    d = sqrt(d);\n    \n    float ta = (-b - d) * 0.5;\n    float tb = (-b + d) * 0.5;\n    \n    t0 = min(ta, tb);\n    t1 = max(ta, tb);\n        \n    return t0 <= t1;\n}\n\nvec3 getNormal( AABB aabb, vec3 pos )\n{\n    vec3 d1 = abs(aabb.Min - pos);\n    vec3 d2 = abs(aabb.Max - pos);\n    \n    vec3 n = -1.0 * vec3(lessThan(d1, vec3(epsilon)));\n\tn += vec3(lessThan(d2, vec3(epsilon)));\n\n    return normalize(n);\n}\n\nvec3 getNormal( vec4 sphere, vec3 pos )\n{\n    return normalize(pos - sphere.xyz);\n}\n\nbool isCloseToEdge( AABB aabb, vec3 pos, float thickness )\n{\n    vec3 d1 = abs(aabb.Min - pos);\n    vec3 d2 = abs(aabb.Max - pos);\n    \n    bvec3 t1 = lessThan(d1, vec3(thickness));\n    bvec3 t2 = lessThan(d2, vec3(thickness));\n    bvec3 t = bvec3(t1.x || t2.x, t1.y || t2.y, t1.z || t2.z);\n\n    return all(t.xy) || all(t.xz) || all(t.yz);\n}\n\nvec3 tosRGB( vec3 color )\n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec3 boxColor = vec3(1.0);\nvec4 trace( Ray ray, mat4 transform ) \n{\n    mat4 transformI = inverse(transform);\n    mat4 transformIT = transpose(transformI);\n    transformRay(ray, transformI);\n    \n    AABB room = createCube(vec3(0.0), 3.0);\n    vec4 box = vec4(vec3(0.0), 1.0);\n    \n    float t0;\n    float t1;\n    \n    float m = 1.0;\n    \n    vec3 color = vec3(0.0);\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        if (intersectSphere(ray, box, t0, t1))\n        {\n            vec3 pos = getRayPos(ray, t0); \n            vec3 normal = getNormal(box, pos);\n            reflectRay(ray, pos, normal);\n            \n            transformNormal(normal, transformIT);\n            \n            float I = max(dot(normal, lightDir), 0.0) * 0.7 + .3;\n            vec3 newColor = clamp(boxColor * I * m, 0.0, 1.0) * .5;\n            \n            color += newColor;\n        }\n        \n        intersectBox(ray, room, t0, t1);\n        vec3 pos = getRayPos(ray, t1);\n        vec3 normal = -getNormal(room, pos);\n        reflectRay(ray, pos, normal);\n        m *= 0.8;\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tboxColor = hsv_to_rgb(iTime / 70.0, 1.0, 1.0, 1.0).rgb;\n    \n    float step = 1.0 / float(SAMPLES);\n    \n    mat4 transform = translationMatrix(vec3(0.0, 0.0, -6.0));\n    transform *= rotationMatrix(up, iTime * .5);\n    transform *= rotationMatrix(right, iTime * .1);\n    \n    int i = 0;\n    int j = 0;\n    vec4 outColor = vec4(0.0);\n    \n#if (SAMPLES > 1) \n    for (i=0; i<SAMPLES; i++) \n    {\n        for (j=0; j<SAMPLES; j++)\n        {\n#endif\n            Ray ray = createRay(fragCoord + vec2(float(i) * step, float(j) * step));\n            outColor += trace(ray, transform);            \n#if (SAMPLES > 1) \n        }\n    }\n#endif\n    \n    outColor /= float(SAMPLES * SAMPLES);\n    \n\tfragColor = vec4(tosRGB(outColor.rgb), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}