{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4tG3zW",
      "date": "1473371694",
      "viewed": 636,
      "name": "Geodesic domain manipulation",
      "username": "tdhooper",
      "description": "Handy for creating evenly distributed geometry around a sphere.",
      "likes": 35,
      "published": 3,
      "flags": 0,
      "tags": [
        "sdf",
        "geometry",
        "icosahedron",
        "dodecahedron",
        "subdivision",
        "spikes",
        "polyhedra",
        "geodesic"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "\n#define PI 3.14159265359\nfloat t;\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\nfloat fCone(vec3 p, float radius, float height, vec3 direction, float offset) {\n    p -= direction * offset;\n    p = reflect(p, normalize(mix(vec3(0,1,0), -direction, .5)));\n    //p -= vec3(0,height,0);\n    return fCone(p, radius, height);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\n// Repeat space to form subdivisions of an icosahedron\n// Return normal of the face\nvec3 pIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n        // Fold in corner A \n        \n        float d = .5;\n        \n        vec3 p1 = bToC(A, B, C, vec3(1.-d, .0, d));\n        vec3 p2 = bToC(A, B, C, vec3(1.-d, d, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            // Get corners of triangle created by fold\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n            \n            // Fold in corner A\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n            // Fold in corner B\n            \n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n    \n    return pca;\n}\n\n// Normal for the perpendicular bisector plane of two points\nvec3 bisector(vec3 a, vec3 b) {\n\treturn normalize(cross(\n\t\tmix(a, b, .5),\n        cross(a, b)\n    ));\n}\n\n// Repeat space to form subdivisions of a dodecahedron\n// Return normal of the face\nvec3 pDodecahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n\n\tvec3 A;\n\tvec3 B;\n\tvec3 n;\n    \n    if (subdivisions == 1) {\n\n\t\tA = pbc;\n        B = pab;\n        n = bisector(A, B);\n        pReflect(p, n, 0.);\n    }\n    \n    if (subdivisions == 2) {\n\n        vec3 pcai = pca * vec3(-1,-1,1);\n\n        A = pbc;\n        B = normalize(pcai + pca + pbc);\n        n = bisector(A, B);\n        pReflect(p, n, 0.);\n        \n\t\tA = pbc;\n        B = reflect(pca, n);\n        n = bisector(A, B);\n        pReflect(p, n, 0.);\n    }\n    \n    return pbc;\n}\n\nfloat face(vec3 p, vec3 n, float s) {\n    float d = 1000.;\n    float part;\n    \n    float spikeSize = .08 + (2. - s) * .13;\n    part = fCone(p, spikeSize, .8, n, .5);\n    d = min(d, part);\n\n    part = fPlane(p, n, -.9);\n    d = min(d, part);\n\n    return d;\n}\n\nfloat model(vec3 p) {\n    float spacing = 2.8;\n    p.x += spacing;\n\tfloat u = pModInterval1(p.x, spacing, 0., 2.);\n    float v = pMirror(p.y, spacing / 2.);\n    \n    if (v < 0.) {\n    \tvec3 n = pDodecahedron(p, int(u));\n\t\treturn face(p, n, u);\n    }\n\n   \tvec3 n = pIcosahedron(p, int(u));\n\treturn face(p, n, u);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\n\n\nvoid pRoll(inout vec3 p) {\n\t//return;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n}\n\nvec2 map( vec3 p ){  \n    pRoll(p);\n    vec2 res = vec2(model(p), 1.);\n    return res;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );   \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    \n    float x = mouse.x;\n    float y = mouse.y;\n        \n    float dist = 6.4;\n    float height = 0.;\n    camPos = vec3(0,0,-dist);\n    vec3 axisY = vec3(0,1,0);\n    vec3 axisX = vec3(1,0,0);\n    mat3 m = rotationMatrix(axisY, -x * PI * 2.);\n    axisX *= m;\n    camPos *= m;\n    m = rotationMatrix(axisX, -(y -.5) * PI*2.);\n    camPos *= m;\n    camPos.y += height;\n    camTar = -camPos + vec3(.0001);\n    camTar.y += height;\n    camRoll = 0.;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n\n\tvec3 color = vec3(.04,.045,.05);\n\n    vec3 pos = ro + rd * res.x;\n\n    if (res.y == 1.){\n    \tvec3 norm = calcNormal( pos );\n    \tvec3 ref = reflect(rd, norm);\n\t\tcolor = norm * 0.5 + 0.5;\n    }\n\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    //t = mod(t/2., 1.);\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( camPos , rd  );\n\n    vec3 color = render( res , camPos , rd );\n    \n    fragColor = vec4(color,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}