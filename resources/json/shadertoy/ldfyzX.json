{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ldfyzX",
      "date": "1489098137",
      "viewed": 312,
      "name": "[ #06 ] - Snow bouncing",
      "username": "Yrai",
      "description": "Random experiment.",
      "likes": 2,
      "published": 3,
      "flags": 32,
      "tags": [
        "3d",
        "raymarching",
        "balls",
        "lights",
        "snow",
        "bouncing",
        "linverse"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "#define time_ iTime\n#define res_  iResolution\n#define eps_  0.01\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / res_.xy;\n    \n    vec3 col = vec3(0.);\n    vec3 col0 = texture(iChannel0, p).xyz;\n    col = mix(col0, col0*atan(p.x, p.y), -.2*p.x-p.y)*vec3(1., 1., 1.1);\n\t\n    fragColor = vec4(col, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Raymarch params\n#define march_steps_   512\n#define march_range_   500.\n#define shadow_perc_   0.1\n#define dist_perc_     .5\n#define epsilon_       .0001\n\n\nstruct  t_object      { int id; float d; };\n\n// Constants, redefinitions\n#define mouse_x         (iMouse.xy / iResolution.xy).x\n#define mouse_y         (iMouse.xy / iResolution.xy).y\n#define mod3_           vec3(.1031, .11369, .13787)\n#define res_            iResolution\n#define time_           iTime\n#define pi_             3.14159265\n#define sqrt2_          1.41421356\n    \n// Primitives, objects\nfloat d_sphere(vec3 p, float r);\nfloat d_cuboid(vec3 p, vec3 s);\nfloat d_heart(vec3 p, float r);\nfloat d_crate(vec3 p);\n\n// Transformations\nvec2 domain(vec2 uv, float s);\nmat3 rot(vec3 ang);\n\n// Noise\nfloat perlin_noise3(vec3 p);\nvec3  hash3_3(vec3 p3);\nfloat squarew(vec2 p);\n\n// Geometrical calculations\nt_object march(vec3 ro, vec3 rd);\nt_object eval_scene(vec3 p);\nvec3     normal(vec3 p);\n\n// Camera\nvoid  camera(\n    vec2 p, out vec3 ro, out vec3 rd, float or,\n    float oh, vec3 target, float roll, float ll\n);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\n\n// Shading\nfloat oren_nayar(vec3 l, vec3 rd, vec3 nor, float roughness, float albedo);\nfloat gaussian(vec3 l, vec3 rd, vec3 nor, float shininess);\nvec3  material_builder(vec3 p, vec3 rd, float dis, int id);\nvec3  pixel_color(vec3 p, vec3 rd, float dis, int mal_id);\nfloat fog_exp2(float dist, float density);\nvec3  render(vec2 p, vec3 ro, vec3 rd);\nfloat soft_shadow(vec3 ro, vec3 rd);\n\n\n\n// Main \n// ------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n\tvec2 p = domain(fragCoord, 1.);\n    \n    vec3 ro, rd;\n    vec3 target = vec3(0.);\n    camera(p, ro, rd, 41.5, 40., target, 0.1, 1.5);\n    \n    vec3 col = render(p, ro, rd);\n    fragColor = vec4(col, 1.);\n}\n// ------------------------------------------------------\n\nt_object eval_scene(vec3 p) {\n    float bounce_h = 15.;\n    vec3 spath = vec3(sin(time_)*21., abs(10. * sin(3.*time_)), 0.);\n    vec3 spath2 = vec3(cos(time_)*21., abs(10. * sin(3.*time_*pi_/2.)), 0.);\n    vec3 spath3 = vec3(cos(time_)*30., abs(sin(4.*time_)*12.), sin(time_)*30.);\n    vec3 spath4 = vec3(\n        25.*cos(time_)*sin(time_),\n        25.*sin(time_)*sin(time_),\n        25.*cos(time_)\n    );\n    float a = 41.;\n    vec3 spath5 = vec3(\n        (a*sqrt2_*cos(time_)) / (sin(time_)*sin(time_) + 1.),\n        4.,\n        (a*sqrt2_*cos(time_)*sin(time_)) / (sin(time_)*sin(time_) + 1.)\n    );\n    \n    float s = d_sphere(p-spath, 4.);\n    float s2 = d_sphere(p-spath2, 4.);\n    float s3 = d_sphere(p-spath3, 4.);\n    float s4 = d_sphere(p-spath4, 2.);\n    float s5 = d_sphere(p-spath5, 8.);\n    \n    float pl = p.y + 4.;\n    pl += 3.*perlin_noise3(.1*p);\n    \n    const int scene_size = 6;\n    float objs[scene_size];\n    objs[0] = pl;\n\tobjs[1] = s;\n    objs[2] = s2;\n    objs[3] = s3;\n    objs[4] = s4;\n    objs[5] = s5;\n    \n    float m = objs[0]; int ind=0;\n    for(int i = 0; i < scene_size; i++) {\n        if(objs[i] < m) {\n            m = objs[i];\n        \tind = i;\n        }\n    }\n        \n    return t_object(ind, m);\n}\n\nvec3 pixel_color(vec3 p, vec3 rd, float dis, int mal_id) {\n    vec3 l   = normalize(vec3(0.345, 0.345, 0.345));\n    vec3 l2  = normalize(vec3(0.345, 0.345, -0.345));\n    vec3 mrd = normalize(-rd);\n    vec3 nor = normal(p);\n    \n    vec3 lin = vec3(0.);\n    vec3 lcw = vec3(1.);\n    vec3 lcy = vec3(2., 2., 1.0);\n    \n    float al = 0.05;\n    float spec  = gaussian(l, mrd, nor, -1.);\n   \tfloat spec2 = gaussian(l2, mrd, nor, -1.);\n    float diff  = max(0., oren_nayar(l, mrd, nor, .12, 6.) );\n    float diff2 = max(0., oren_nayar(l2, mrd, nor, .12, 6.) );\n    float refl  = 4.*dot(l, reflect(mrd, nor));\n    float sha = soft_shadow(p+shadow_perc_*nor, l);\n    \n    vec3 brightness = vec3(0.2);\n    vec3 mal = material_builder(p, rd, dis, mal_id);\n    \n    lin  += (refl+spec+diff+spec2+diff2)*sha*brightness;\n    lin  += al;\n    \n    vec3 col = mal * lin * lcy;\n\tcol = mix(col, .01+vec3(0., 0., .0), fog_exp2(dis, .0052));\n    \n    return .9-col;\n}\n\nvec3 material_builder(vec3 p, vec3 rd, float dis, int id) {\n    if(id == 0) {        \n\t\tvec3 col = vec3(.7);\n        return col;\n    }\n    else if(id == 1) {\n    \tvec3 col = vec3(1.3, .2, .1);        \n        return col;\n    }\n    else if(id == 2) {\n    \tvec3 col = vec3(1.3, .4, .8);\n        return col;\n    }\n    else if(id == 3) {\n        vec3 col = vec3(.3, 1., 4.8);\n        return col;\n    }\n    else if(id == 4) {\n        vec3 col = vec3(.1, .9, .9);\n        return col;\n    }\n    else if(id == 5) {\n        vec3 col = vec3(1.1, .1, 1.2);\n        return col;\n    }\n}\n\nvec3 render(vec2 p, vec3 ro, vec3 rd) {\n    vec3 fpc = vec3(0.);\n    \n    t_object mh = march(ro, rd);\n    vec3 extray = vec3(ro + mh.d * rd); \n    if(mh.d < march_range_) {\n        return pixel_color(extray, rd, mh.d,  mh.id);\n    }\n    else {\n    \tfpc = vec3(1.);\n    \treturn fpc;\n    }\n        \n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(epsilon_, 0.);\n    return normalize(vec3(\n        eval_scene(p+e.xyy).d-eval_scene(p-e.xyy).d,\n        eval_scene(p+e.yxy).d-eval_scene(p-e.yxy).d,\n        eval_scene(p+e.yyx).d-eval_scene(p-e.yyx).d\n    ));\n}\n\nt_object march(vec3 ro, vec3 rd) {\n\tfloat hit = 1.;\n    float raydst = 0.;\n    int ind;\n    \n    t_object mp;\n    for(int i=0; i < march_steps_; i++) {\n        if(hit < epsilon_ || raydst > march_range_) break;\n        mp = eval_scene(ro + raydst*rd);\n        hit = mp.d*dist_perc_;\n        ind = mp.id;\n        raydst += hit;\n    }\n    \n    mp.d = raydst;\n    return mp;\n}\n\n// Camera\n// ----------------------------------------------------------------------------------------------------------------------------------\nvoid camera(\n    vec2 p, out vec3 ro, out vec3 rd, float or,\n    float oh, vec3 target, float roll, float ll\n)\n{\n    float mx = 2. * mouse_x;\n    float my = 5. * mouse_y;\n    float t = time_/30.;\n    ro = vec3(or * sin(mx*t), oh - my, or * cos(mx*t));\n    \n    mat3 lam = look_at(ro, target, roll);    \n\trd = normalize(lam * vec3(p.xy, ll)); \n}\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Lighting, color calculations\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat oren_nayar(vec3 l, vec3 rd, vec3 nor, float roughness, float albedo) {  \n  float ldrd = dot(l, rd);\n  float nordl = dot(l, nor);\n  float nordrd = dot(nor, rd);\n\n  float s = ldrd - nordl * nordrd;\n  float t = mix(1., max(nordl, nordrd), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float a = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float b = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(.0, nordl) * (a + b * s / t) / pi_;\n}\n\nfloat gaussian(vec3 l, vec3 rd, vec3 nor, float shininess) {\n  vec3 h = normalize(l + rd);\n  float theta = acos(dot(h, nor));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nfloat fog_exp2(float dist, float dens) {\n  const float log2v = -1.442695;\n  float d = dens * dist;\n  return 1. - clamp(exp2(d * d * log2v), 0., 1.);\n}\n\nfloat soft_shadow(vec3 ro, vec3 rd) {\n    float res = 1.;\n    float t = .0001;                     \n\tfloat h = 1.;\n    for(int i = 0; i < 20; i++) {         \n        h = eval_scene(ro + rd*t).d;\n        res = min(res, .5*h/t);          \n\t\tt += clamp(h, .1, 4.);          \n    }\n    return clamp(res, 0., 1.);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Noise\n// ----------------------------------------------------------------------------------------------------------------------------------\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3. - 2. * pf);\n    \n    return \tmix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Domain transformations\n// ----------------------------------------------------------------------------------------------------------------------------------\nvec2 domain(vec2 uv, float s) {\n    return (2.*uv.xy-res_.xy) / res_.y*s;\n}\nmat3 rot(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Primitives\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat d_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat d_cuboid(vec3 p, vec3 s) {\n  vec3 d = abs(p) - s;\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}