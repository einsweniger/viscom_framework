{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XtySDz",
      "date": "1495767973",
      "viewed": 164,
      "name": "Shadertoy \ud29c\ud1a0\ub9ac\uc5bc \ud55c\uae00\ubc88\uc5ed",
      "username": "ho4040",
      "description": "Korean version of https://www.shadertoy.com/view/Md23DV ",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "tutorial",
        "korean"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "/*\n\uc6d0\ubb38 : https://www.shadertoy.com/view/Md23DV \n\ubc88\uc5ed : General Choi (github: ho4040)\n\n\uc548\ub155\ud558\uc138\uc694, \ud55c\ub2ec\uc804\uc5d0 GLSL\uc744 \uc2dc\uc791\ud588\uc2b5\ub2c8\ub2e4. GPU\ub97c \uc774\uc6a9\ud55c \ube60\ub978 \ub9ac\uc5bc\ud0c0\uc784 \uadf8\ub798\ud53d\ub4e4\uc774 \ub180\ub78d\ub124\uc694.\n\uc250\uc774\ub354\ub97c \uc791\uc131\ud558\ub294 \uac83\uc744 \ubc30\uc6b0\uace0 \uc2f6\uc73c\uc2e0 \ubd84\ub4e4\uaed8 \uc774 \ud29c\ud1a0\ub9ac\uc5bc\uc740 \uc88b\uc740 \uc2dc\uc791\uc810\uc774 \ub420 \uac81\ub2c8\ub2e4.\n\ub2e8\uc5b4\uc5d0\ub7ec\ub098 \ucf54\ub529\uc5d0\ub7ec\uac00 \uc788\ub2e4\uba74 \uace0\uccd0\uc8fc\uc138\uc694. :-)\n\n*/\n\n// \uc544\ub798 \ubc88\ud638\ub97c \ubc14\uafb8\uace0 \ub2e4\uc2dc \ucef4\ud30c\uc77c\ud558\uba74 \ud29c\ud1a0\ub9ac\uc5bc\uc744 \uc120\ud0dd\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n#define TUTORIAL 0\n\n/* \ud29c\ud1a0\ub9ac\uc5bc \ubaa9\ub85d\n 1 \ube48 \ud654\uba74.\n 2 \uade0\uc77c \uc0c9\uc0c1.\n 3 GLSL \ubca1\ud130\n 4 RGB \uc0c9\uc0c1 \ubaa8\ub378\uacfc \ubca1\ud130\uc758 \uc694\uc18c\ub4e4\n 5 \uc88c\ud45c\uacc4\n 6 \ud574\uc0c1\ub3c4\uc640 \ud504\ub808\uc784 \uc0ac\uc774\uc988 \n 7 \uc88c\ud45c\uac8c \ubcc0\ud658\n 8 \uc218\ud3c9\uc120, \uc218\uc9c1\uc120\n 9 VISUALISING THE COORDINATE SYSTEM\n10 MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n11 MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n12 DISK\n13 FUNCTIONS\n14 BUILT-IN FUNCTIONS: STEP\n15 BUILT-IN FUNCTIONS: CLAMP\n16 BUILT-IN FUNCTIONS: SMOOTHSTEP\n17 BUILT-IN FUNCTIONS: MIX\n18 ANTI-ALIASING WITH SMOOTHSTEP\n19 FUNCTION PLOTTING\n20 COLOR ADDITION AND SUBSTRACTION\n21 COORDINATE TRANSFORMATIONS: ROTATION\n22 COORDINATE TRANSFORMATIONS: SCALING\n23 SUCCESSIVE COORDINATE TRANSFORMATIONS\n24 TIME, MOTION AND ANIMATION\n25 PLASMA EFFECT\n26 TEXTURES\n27 MOUSE INPUT\n28 RANDOMNESS\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#if TUTORIAL == 1\n// \ube48\ud654\uba74.\n//\n// \"main\" \ud568\uc218\ub294 \uc250\uc774\ub354 \ud6a8\uacfc\ub97c \ucd9c\ub825\ud558\uae30 \uc704\ud574\uc11c \ub9e4\ucd08 \ub9c8\ub2e4 \uc218\uc2ed\ud68c \ud638\ucd9c\ub429\ub2c8\ub2e4. \n// \ucef4\ud4e8\ud130 \uc2dc\uc2a4\ud15c\uc740 \ucd08\ub2f9 60 \ud504\ub808\uc784(60FPS)\uc744 \ucd9c\ub825\ud558\ub824\uace0 \ub178\ub825\ud569\ub2c8\ub2e4.\n// \ud558\uc9c0\ub9cc GLSL \uc2a4\ud06c\ub9bd\ud2b8\uac00 \uacc4\uc0b0\uc774 \ube61\uc138\uc9c0\uba74 \uc774 \uc22b\uc790\ub294 \ub354 \ub0ae\uc544\uc9c8 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n// (FPS\ub294 \ud654\uba74 \uc544\ub798\ucabd \uc815\ubcf4 \ubc14 \uc5d0 \ud45c\uc2dc\ub429\ub2c8\ub2e4.)\n//\n// \uc6b0\ub9ac\uac00 \uc544\ubb34\uac83\ub3c4 \uc548\ud560\uac70\uae30 \ub54c\ubb38\uc5d0 \uc774 \uc250\uc774\ub354\ub294 \uadf8\ub0e5 \uac80\uc740 \ud654\uba74\uc744 \ubcf4\uc5ec\uc90d\ub2c8\ub2e4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#elif TUTORIAL == 2\n// \uade0\uc77c \uc0c9\uc0c1\n//\n// \"fragColor\" \ub294 \uc250\uc774\ub354\uc758 \ucd9c\ub825\uc785\ub2c8\ub2e4.\n// \uc774 \uac12\uc774 \ud654\uba74\uc5d0 \ubcf4\uc5ec\uc9c0\ub294 \uc774\ubbf8\uc9c0\ub97c \uacb0\uc815\ud558\uac8c \ub429\ub2c8\ub2e4.\n// \uc774 \uc250\uc774\ub354\ub294 \uc774 \uac12\uc744 \ub178\ub780\uc0c9\uc73c\ub85c \uc9c0\uc815\ud569\ub2c8\ub2e4.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1.0, 1.0, 0.0 ,1.0);\n}\n\n\n#elif TUTORIAL == 3\n// GLSL \ubca1\ud130\ub4e4\n// \n// \"fragColor\" \ub294 vec4 \uac1d\uccb4\uc5d0 \ud560\ub2f9\ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\n// \uc774\uac74 0~1 \uc0ac\uc774 \uc2e4\uc218 \uac12\uc774 \ub2f4\uae34 4\uac1c \uc9dc\ub9ac \ubc30\uc5f4 \uc785\ub2c8\ub2e4.\n// \uc55e\uc5d0 3 \uac1c\uc758 \uc22b\uc790\ub294 \uc0c9\uc0c1\uc744 \uc9c0\uc815 \ud558\uace0 4\ubc88\uc9f8 \uc22b\uc790\ub294 \n// \ubd88\ud22c\uba85\ub3c4(opactiy) \ub97c \uc9c0\uc815 \ud569\ub2c8\ub2e4.\n// (\ub2f9\uc7a5\uc740 4 \ubc88\uc9f8 \ud22c\uba85\ub3c4 \uac12\uc740 \uc544\ubb34\ub7f0 \ud6a8\uacfc\ub3c4 \uc5c6\uc2b5\ub2c8\ub2e4.)\n// \ud558\ub098\uc758 vec2 \uac1d\uccb4\ub294 4\uac1c\uc758 float \uc744 \uc778\uc790\ub85c \ubc1b\uc544 \uc0dd\uc131\ub418\uac70\ub098.\n// \uc544\ub798\ucc98\ub7fc, vec3 \uc640 float. 2\uac1c\uc758 \uc778\uc790\ub97c \uc0dd\uc131\uc790 \uc778\uc790\ub85c \ubc1b\uc544 \uc0dd\uc131\ub429\ub2c8\ub2e4.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Here we are seperating the color and transparency parts\n\t// of the vec4 that represents the pixels.\n\tvec3 color = vec3(0.0, 1.0, 1.0);\n\tfloat alpha = 1.0;\n\t\n\tvec4 pixel = vec4(color, alpha);\n\tfragColor = pixel;\n}\n\n#elif TUTORIAL == 4\n// RGB \uc0c9\uc0c1 \ubaa8\ub378 \uacfc \ubca1\ud130\uc758 \uad6c\uc131\uc694\uc18c\ub4e4\n//\n// \ubca1\ud130\ub97c \ucd08\uae30\ud654 \ud558\uace0\ub098\uba74, \uac01 \uc694\uc18c\ub4e4\uc740 \".\" \ud45c\ud604\uc744 \uc774\uc6a9\ud574\uc11c \uc811\uadfc \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n//\n// RGB: http://en.wikipedia.org/wiki/RGB_color_model\n// \uc0c9\uc0c1 \ud558\ub098\ub294 3\uac1c\uc758 \uc22b\uc790(0\ubd80\ud130 1\uc0ac\uc774 \uac12)\ub85c \ud45c\ud604\ub429\ub2c8\ub2e4. \n// \uc774 \ubaa8\ub378\uc740 \uc21c\uc218\ud55c \ube68\uac15, \ucd08\ub85d, \ud30c\ub791 \uc0c9\uc758 \ube5b\uc744 \uac01\uac01 \uac15\ub3c4\ub97c \ub2ec\ub9ac \ud558\uc5ec \ud569\ud55c \uac83\uc73c\ub85c \ucde8\uae09\ud569\ub2c8\ub2e4.\n// \n// \ub9cc\uc57d\uc5d0 \uc800\ucc98\ub7fc \ub514\uc790\uc778 \uc2a4\ud0ac\uc774 \ud6c4\uc9c0\uace0, \uc0c9\uc0c1\uc758 \uc870\ud569\uc774 \uac04\uc9c0\ub098\uac8c \ub9cc\ub4e4\uae30\uac00 \ud798\ub4e4\ub2e4\uba74\n// \uc774 \uc6f9\uc0ac\uc774\ud2b8\ub4e4\uc744 \ucc38\uace0\ud574\ubcf4\uc138\uc694 \uc5ec\ub7ec\uac00\uc9c0 \uc0c9\uc0c1 \uc870\ud569\uc744 \uc0b4\ud3b4 \ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n// https://kuler.adobe.com/create/color-wheel/\n// http://www.colourlovers.com/palettes\n// http://www.colourlovers.com/colors\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// \uc544\ub798 \uc22b\uc790\ub4e4\uc744 \ubc14\uafd4\uac00\uba70 \ub180\uc544\ubcf4\uc138\uc694:\n\tfloat redAmount = 0.6; // \ube68\uac04\uc0c9\uc758 \uc138\uae30\n\tfloat greenAmount = 0.2; // \ucd08\ub85d\uc0c9\uc758 \uc138\uae30\n\tfloat blueAmount = 0.9; // \ud30c\ub780\uc0c9\uc758 \uc138\uae30\n\t\n\tvec3 color = vec3(0.0); \n\t\n\t// \uc774\uac74 \uc778\uc790 \ud558\ub098\ub9cc \uc4f0\ub294 \uc138\ubc88\uc9f8 \ubca1\ud130 \uc0dd\uc131 \ubc29\ubc95\uc785\ub2c8\ub2e4.\n\t// \"vec3(x)\" \uc740 \"vec3(x, x, x)\" \ub791 \ub611\uac19\uc2b5\ub2c8\ub2e4.\n\t// \uc774 \ubca1\ud130\ub294 \uc544\ub798 \ubc29\ubc95\uc73c\ub85c \ucd08\uae30\ud654 \ud588\uc2b5\ub2c8\ub2e4.\n\t// color.x = 0.0, color.y = 0.0; color.z = 0.0;\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\t\n\tfloat alpha = 1.0;\n\tvec4 pixel = vec4(color, alpha);\t\n\tfragColor = pixel;\n}\n\n\n#elif TUTORIAL == 5\n// \uc88c\ud45c\uacc4\n//\n// \"fragCoord\", \"fragment coordinate\" \ub294 \uc785\ub825 \ubcc0\uc218\uc785\ub2c8\ub2e4.\n// \uc774\uac78 \ud1b5\ud574\uc11c \uc9c0\uae08 \uacc4\uc0b0\ud558\ub294 \uac12\uc774 \uc5b4\ub290 \uc704\uce58\uc5d0 \ubcf4\uc5ec\uc904 \ud53d\uc140\uc778\uc9c0 \uc54c \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n// \uc774 \uc88c\ud45c\uacc4\uc758 \uc911\uc2ec\uc740 \uc88c\uce21 \ud558\ub2e8 \uc774\uace0 \uc624\ub978\ucabd \uc0c1\ub2e8\uc774 \uac12\uc774 \uc99d\uac00\ud558\ub294 \ubc29\ud5a5\uc785\ub2c8\ub2e4.\n// \n// main \ud568\uc218\ub294 \ub294 \ud654\uba74\uc758 \ubaa8\ub4e0 \ud53d\uc140\uc5d0 \ub300\uc751\ub418\uc5b4\uc11c \uc2e4\ud589\uc774 \ub429\ub2c8\ub2e4.\n// \uac01 \ud638\ucd9c\uc5d0\uc11c \"gl_FragCoord\"\ub294 \uac01 \ud53d\uc140\uc758 \uc704\uce58\uc5d0 \ud574\ub2f9\ud569\ub2c8\ub2e4.\n//\n// GPUs \ub294 \uc5ec\ub7ec\uac1c\uc758 \ucf54\uc5b4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc11c \ub3d9\uc2dc\uc5d0 \ubcd1\ub82c \ud638\ucd9c\ub418\uc5b4\uace0 \uc5ec\ub7ec\uac1c\uc758\n// \ud53d\uc140\uc774 \ub3d9\uc2dc\uc5d0 \uacc4\uc0b0\ub418\ub294\uac8c \uac00\ub2a5\ud569\ub2c8\ub2e4.\n// \ub530\ub77c\uc11c CPU\uc5d0\uc11c \ud558\ub098 \ud558\ub098\uc529 \uacc4\uc0b0\ud558\ub294 \uac83\ubcf4\ub2e4 \ube60\ub978 \uc18d\ub3c4\ub97c \ubcf4\uc5ec\uc904 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n// \ud558\uc9c0\ub9cc \uc774 \ub54c\ubb38\uc5d0 \uc5ec\uae30\uc5d0\ub294 \uc911\uc694\ud55c \uc81c\uc57d\uc774 \ub530\ub77c\uc635\ub2c8\ub2e4.\n// \ud558\ub098\uc758 \ud53d\uc140\uac12\uc740 \ub2e4\ub978 \ud53d\uc140\uac12\uc5d0 \uc758\ud574\uc11c \uacb0\uc815 \ub420 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. (\uac01 \ud53d\uc140\uc774 \ub3d9\uc2dc\uc5d0 \ubcd1\ub82c\ub85c \n// \uacc4\uc0b0\uc774 \ub418\uae30 \ub54c\ubb38\uc5d0 \uc5b4\ub5a4 \ud53d\uc140\uc774 \uba3c\uc800 \uacc4\uc0b0 \ub420\uc9c0 \uc54c \uc218 \uc5c7\uc2b5\ub2c8\ub2e4.)\n// \ud53d\uc140\uc758 \ucd9c\ub825\uc740 \ud53d\uc140\uc758 \uc88c\ud45c\uc5d0 \uc758\ud574 \uacb0\uc815\ub429\ub2c8\ub2e4. (\uadf8\ub9ac\uace0 \ucd94\uac00 \ub2e4\ub978 \uc778\ud48b\ub4e4)\n// \uc774\uac83\uc774 \uc250\uc774\ub354 \ud504\ub85c\uadf8\ub798\ubc0d\uc5d0\uc11c \uac00\uc7a5 \uc911\uc694\ud55c \ucc28\uc774\uc810\uc785\ub2c8\ub2e4. \uc774 \uac83\uc744 \uc544\ub9c8 \uacc4\uc18d \ub9c8\uc8fc\uce58\uac8c \ub420 \uac83 \uc785\ub2c8\ub2e4.\n//\n// \uade0\uc77c \uc0c9\uc0c1\uc774 \uc544\ub2cc \ubb54\uac00\ub97c \uadf8\ub824\ubcf4\ub3c4\ub85d \ud558\uc8e0.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// \uc0dd\uc0c1\uc744 \uc120\ud0dd\ud569\ub2c8\ub2e4.\n\tvec3 color1 = vec3(0.886, 0.576, 0.898);\n\tvec3 color2 = vec3(0.537, 0.741, 0.408);\n\tvec3 pixel;\n\n\t// x \uc88c\ud45c\uac00 100 \ubcf4\ub2e4 \ud06c\uba74 color1\uc744 \ucc0d\uc2b5\ub2c8\ub2e4.\n\t// \uc544\ub2c8\uba74 color 2\ub97c \ucc0d\uc2b5\ub2c8\ub2e4.\n\tfloat widthOfStrip = 100.0;\n\tif( fragCoord.x > widthOfStrip ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 6\n// \ud574\uc0c1\ub3c4, \ud504\ub808\uc784 \uc0ac\uc774\uc988\n//\n// \ube0c\ub77c\uc6b0\uc800 \ud06c\uae30\ub97c \uc870\uc808\ud558\uac70\ub098 \ud480\uc2a4\ud06c\ub9b0\ubaa8\ub4dc\ub85c \uac14\ub2e4\uac00 \ub3cc\uc544\uc624\uba74\n// \uccab\ubc88\uc9f8 \uc0c9\uacfc \ub450\ubc88\uc9f8\uc0c9 \ud3ed\uc758 \ube44\uc728\uc774 \ub2ec\ub77c\uc9c0\ub294 \uac78 \ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n// \uc774\uac74 \ud654\uba74 \ube44\uc728\uc5d0 \ub530\ub77c\uc11c \uac12\uc744 \uc9c0\uc815\ud558\uc9c0 \uc54a\uace0 \uba87 \ud53d\uc140\uc778\uc9c0 \uc808\ub300\uac12\uc744 \uc9c0\uc815\ud558\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4.\n// \n// \uc6b0\ub9ac\uac00 \ub450\uac00\uc9c0 \uc0c9\uc73c\ub85c \ud654\uba74\uc744 \uc774\ub4f1\ubd84 \ud55c\ub2e4\uace0 \ud574\ubcf4\uba74,\n// \ud654\uba74 \ud06c\uae30\ub97c \uc54c\uae30 \uc804\uae4c\uc9c0\ub294 \uba87 \ud53d\uc140\ub85c \ud574\uc57c\ud560\uc9c0 \uacb0\uc815\uc744 \ud560 \uc218\uac00 \uc5c6\uac8c \ub429\ub2c8\ub2e4.\n//  \n// \uc5b4\ub5bb\uac8c \ud654\uba74 \ud06c\uae30(\ud3ed\uacfc \ub192\uc774)\ub97c \ud53d\uc140\ub2e8\uc704\ub85c \uc5bb\uc5b4\uc62c\uae4c\uc694.\n// \uc774\uac74 \"iResolution\" \uc774\ub77c\ub294 \ubcc0\uc218\ub85c \uc8fc\uc5b4\uc9c0\uac8c \ub429\ub2c8\ub2e4.\n// \"iResolution.x\" \ub294 \ud654\uba74 \ud504\ub808\uc784\uc758 \ud3ed\n// \"iResolution.y\" \ub294 \ud654\uba74 \ud504\ub808\uc784\uc758 \ub192\uc774\uac00 \ub429\ub2c8\ub2e4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(0.741, 0.635, 0.471);\n\tvec3 color2 = vec3(0.192, 0.329, 0.439);\n\tvec3 pixel;\n\n\t// if \ubb38 \ub300\uc2e0 3\ud56d \uc5f0\uc0b0\uc790\ub85c \ud3b8\ud558\uac8c \ud45c\ud604\ud569\ub2c8\ub2e4.\n\t// x \uc88c\ud45c\uac00 \ud654\uba74 \ud3ed\uc758 \uc808\ubc18\uc774 \ub118\uc5b4\uac00\uba74 color1\uc744 \uc0ac\uc6a9\ud558\uace0\n\t// \uc544\ub2c8\uba74 color2\ub97c \uc0ac\uc6a9.\n\tpixel = ( fragCoord.x > iResolution.x / 2.0 ) ? color1 : color2;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 7\n// \uc88c\ud45c\uacc4 \ubcc0\ud615\n// \ud654\uba74 \uc88c\ud45c \uc2dc\uc2a4\ud15c \ubcf4\ub2e4\ub294 \uc6b0\ub9ac\uac00 \uc9c1\uc811 \uc9c0\uc815\ud55c \uc88c\ud45c\uacc4\uac00 \n// \ub354 \ud3b8\ud55c \uacbd\uc6b0\uac00 \ub300\ubd80\ubd84\uc77c\uac81\ub2c8\ub2e4.\n//\n// \"fragCoord\"\ub77c\ub294 \ud654\uba74\uc758 \uc808\ub300\uc88c\ud45c\uacc4 \ub300\uc2e0\uc5d0\"r\" \uc774\ub77c\ub294 \uc0c8\ub85c\uc6b4 \uc88c\ud45c\uacc4\ub97c \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4.\n// \"r\" \uc5d0\uc11c\ub294 x\uac12\uacfc y\uac12\uc740 \ub294 0 \uc5d0\uc11c 1 \uc0ac\uc774 \uac12\uc744 \uac00\uc9d1\ub2c8\ub2e4.\n// x\uac12\uc774 0 \uc774\uba74 \uc88c\uce21\ub05d\uc744 1\uc774\uba74 \uc6b0\uce21\ub05d\uc744 \uc758\ubbf8\ud569\ub2c8\ub2e4. y \uac12\uc774 0\uc774\uba74 \uc544\ub798\ucabd\ub05d\uc744\n// 1\uc774\uba74 \uc704\ucabd\ub05d\uc744 \uc758\ubbf8\ud569\ub2c8\ub2e4.\n//\n// \"r\" \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud654\uba74\uc744 3 \ub465\ubd84 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\t\n\t// r \uc740 vec2 \uc785\ub2c8\ub2e4. \uc774 \ubca1\ud130\uc758 \uccab\ubc88\uc9f8 \uac12(x\uac12) \ud53d\uc140\uc758x\uac12(fragCoord.x)\uac12\uc744 \ud654\uba74\ud3ed\uc73c\ub85c \ub098\ub208 \uac12 \uc785\ub2c8\ub2e4.\n\t// \ubca1\ud130\uc758 \ub450\ubc88\uc9f8 \uac12(y\uac12)\uc740 \ud53d\uc140\uc704\uce58(fragCoord.y) \uc744 \ud654\uba74 \ub192\uc774\ub85c \ub098\ub208 \uac12 \uc774\ub2c8\ub2e4.\n\n\t// \uc608\ub97c\ub4e4\uc5b4, \uc81c \ub178\ud2b8\ubd81\uc5d0\uc11c\ub294, \uc804\uccb4\ud654\uba74\uc2dc \ud654\uba74\ud06c\uae30\ub294 \n\t// 1440 x 900 \uc785\ub2c8\ub2e4. \uadf8\ub798\uc11c iResolution \uc740 (1440.0, 900.0) \uc774 \ub429\ub2c8\ub2e4.\n\t// \ud55c \ud504\ub808\uc784\uc744 \uadf8\ub9ac\uae30 \uc704\ud574\uc11c 1400*1900=1296000 \ubc88\uc774\ub098 \uba54\uc778\ud568\uc218\uac00 \ud638\ucd9c\ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\n\t// fragCoord.x \ub294 0\uc5d0\uc11c 1439 \uc0ac\uc774\uc758 \uac12\uc744 \uac00\uc9c8 \uc218 \uc788\uc744 \uac83\uc774\uad50\n\t// fragCoord.y \ub294 0\uc5d0\uc11c 899, r.x \uc640 r.y\ub294 0\uc5d0\uc11c 1 \uc0ac\uc774 \uac12 \uc774 \ub420 \uac83\uc785\ub2c8\ub2e4.\n\t\n\tvec3 color1 = vec3(0.841, 0.582, 0.594);\n\tvec3 color2 = vec3(0.884, 0.850, 0.648);\n\tvec3 color3 = vec3(0.348, 0.555, 0.641);\n\tvec3 pixel;\n\t\n\t\n\t// 1:1:1 \ub85c \ud654\uba74\ube44\uc728\uc5d0 \ub530\ub77c\uc11c \uc0c9\uc744 \uc9c0\uc815\ud569\ub2c8\ub2e4.\n\t// (\uc5ed\uc8fc) \uc6d0\uae00\uc5d0 \uc8fc\uc11d\uc774 \uc798\ubabb\ub2ec\ub824\uc788\ub124\uc694.\n\n\tif( r.x < 1.0/3.0) {\n\t\tpixel = color1;\n\t} else if( r.x < 2.0/3.0 ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color3;\n\t}\n\t\t\t\n\t// pixel = ( r.x < 1.0/3.0 ) ? color1 : (r.x<2.0/3.0) ? color2: color3;\n\t// \uc704\ucc98\ub7fc 3\ud56d \uc5f0\uc0b0\uc790\ub97c \uc774\uc6a9\ud574\uc11c \uac04\ub2e8\ud558\uac8c \ud45c\ud604\ub3c4 \uac00\ub2a5\ud569\ub2c8\ub2e4.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 8\n// \uc218\ud3c9\uc120\uacfc \uc218\uc9c1\uc120\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t// \uc9e7\uc740 \ubc84\uc83c\uc758 \uc88c\ud45c\uacc4\ubc88\ud658.\n\t// \"aVector.xy\" \uc740 \"aVector\" \uc758 \ucc98\uc74c \ub450\ubc88\uc9f8 \uc694\uc18c\ub85c \ub9cc\ub4e4\uc5b4\uc9c4 \uc0c8\ub85c\uc6b4 \ubca1\ud130\uc785\ub2c8\ub2e4. \n\t// \uadf8\ub9ac\uace0 \ub098\ub204\uae30 \uc5f0\uc0b0\uc744 \ubca1\ud130\ub07c\ub9ac \ud558\uac8c\ub418\uba74\n\t// \uccab\ubc88\uc9f8 \ubca1\ud130\uc758 \uac01 \uc694\uc18c\ub294 \ub450\ubc88\uc9f8 \ubca1\ud130\uc758 \uac01 \uc694\uc18c\ub85c \ub098\ub204\uc5b4 \uc9c0\uac8c \ub429\ub2c8\ub2e4. (x\ub294 x\ub07c\ub9ac y\ub294 y\ub07c\ub9ac)\n\t// \uadf8\ub798\uc11c \uc774 \ud29c\ud1a0\ub9ac\uc5bc\uc758 \uccab\ubc88\uc9f8\uc904\uc740 \uc774\uc804 \ud29c\ud1a0\ub9ac\uc5bc\uc758 \uccab\ubc88\uc9f8 \uc904\uacfc \uac19\uc2b5\ub2c8\ub2e4.\n\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(0.216, 0.471, 0.698);\n\tvec3 color2 = vec3(1.00, 0.329, 0.298);\n\tvec3 color3 = vec3(0.867, 0.910, 0.247);\n\t\n\t// \uba3c\uc800 \ubc30\uacbd\uc0c9(backgroundColor)\uc744 \uc9c0\uc815\ud569\ub2c8\ub2e4. \ub2e4\ub978 \uc0c9\uc774 \uc0ac\uc6a9\ub418\uc9c0 \uc54a\uc73c\uba74 \uc774 \uc0c9\uc744 \uc0ac\uc6a9\ud569\ub2c8\ub2e4.\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// \ud604\uc7ac \ud53d\uc140\uc758 x\uac12\uc774 \uc544\ub798 \uac12\ub4e4\uc758 \uc0ac\uc774 \uac12 \uc774\ub77c\uba74 color1 \uc744 \uc0ac\uc6a9\ud569\ub2c8\ub2e4.\n\t// 0.55\uc640 0.54\uc758 \ucc28\uac00 \ub77c\uc778\uc758 \ud3ed\uc744 \uacb0\uc815\ud558\uac8c \ub429\ub2c8\ub2e4.\n\t\n\tfloat leftCoord = 0.54;\n\tfloat rightCoord = 0.55;\n\tif( r.x < rightCoord && r.x > leftCoord ) pixel = color1;\n\t\n\t\n    // \uc218\uc9c1\uc120\uc744 \ub2e4\ub978 \ubc29\uc2dd\uc758 \ud45c\ud604\ud55c \uac83 \uc785\ub2c8\ub2e4.\n    // x \uc88c\ud45c\uc640 \ub450\uaed8 \ub97c \uc774\uc6a9\ud55c \ud45c\ud604:\n\tfloat lineCoordinate = 0.4;\n\tfloat lineThickness = 0.003;\n\tif(abs(r.x - lineCoordinate) < lineThickness) pixel = color2;\n\t\n\t// \uc218\ud3c9\uc120\n\tif(abs(r.y - 0.6)<0.01) pixel = color3;\n\t\n\t// 3\ubc88\uc9f8 \uc218\ud3c9\uc120\uc774 \uc704\uc758 \ub450 \uc120 \uc704\ub85c \uc5b4\ub5bb\uac8c \uc9c0\ub098\uac00\ub294\uc9c0 \ud655\uc778\ud574\ubcf4\uc138\uc694.\n\t// \ub9c8\uc9c0\ub9c9\uc73c\ub85c \"pixel\" \uac12\uc774 \uc9c0\uc815\ub418\uc5c8\uae30 \ub54c\ubb38\uc5d0 \uc81c\uc77c \uc704\uc5d0 \ub193\uc778 \uc120\uc774 \ub429\ub2c8\ub2e4.\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 9\n// \uc88c\ud45c\uacc4 \uc2dc\uac01\ud654\n//\n// for \ub8e8\ud504\uc640 \uc218\ud3c9\uc120, \uc218\uc9c1\uc120\uc744 \uc774\uc6a9\ud558\uc5ec \uadf8\ub9ac\ub4dc(\uaca9\uc790\ubb34\ub2ac) \uadf8\ub824\ubcf4\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// \ubc30\uacbd\uc0c9\uc744 \uc9c0\uc815\ud558\uba74\uc11c \uc2dc\uc791\ud569\ub2c8\ub2e4. \ub9cc\uc57d\uc5d0 \ub2e4\ub978 \uac12\uc73c\ub85c \ud560\ub2f9 \ub418\uc9c0 \uc54a\uc73c\uba74\n\t// \uc774 \uc0c9\uc774 \ud654\uba74\uc5d0 \ubcf4\uc5ec\uc9c0\uac8c \ub429\ub2c8\ub2e4.\n\tvec3 pixel = backgroundColor;\n\t\n\t// \uadf8\ub9ac\ub4dc\uc758 \uc120\uc744 \uadf8\ub9bd\ub2c8\ub2e4.\n\t// \ub8e8\ud504\ub294 \uc0c1\uc218 \ud45c\ud604\uc73c\ub85c\ub9cc \uc870\uc808 \ud560 \uc218 \uc788\uc5b4\uc11c 'const' \ub97c \uc0ac\uc6a9\ud558\uac8c \ub429\ub2c8\ub2e4.\n\tconst float tickWidth = 0.1;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\t// \"i\" \ub77c\uc778 \uc88c\ud45c\uc785\ub2c8\ub2e4.\n\t\tif(abs(r.x - i)<0.002) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.002) pixel = gridColor;\n\t}\n\t// \ucd95\uc744 \uadf8\ub9bd\ub2c8\ub2e4.\n\tif( abs(r.x)<0.005 ) pixel = axesColor;\n\tif( abs(r.y)<0.006 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 10\n// \uc88c\ud45c\uacc4 \uc911\uc2ec\uc744 \ud504\ub808\uc784\uc911\uc2ec\uc73c\ub85c \uc62e\uae30\uae30\n//\n// [0, iResolution.x]x[0, iResolution.y]\uc601\uc5ed \ub300\uc2e0\n// [0,1]x[0,1]\uc601\uc5ed\uc744 [-1,1]x[-1,1] \ub85c \ub9f5\ud551\ud569\ub2c8\ub2e4.\n// \uc774 \ubc29\ubc95\uc744 \uc4f0\uba74 (0,0)\uc740 \uc67c\ucabd \ud558\ub2e8\uc774 \uc544\ub2c8\uace0 \ud654\uba74 \uc911\uc559\uc774 \ub429\ub2c8\ub2e4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tr = 2.0 * r.xy / iResolution.xy;\n\t// [-0.5*iResolution.x, 0.5*iResolution.x] -> [-1.0, 1.0]\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// \ubc30\uacbd\uc0c9\uc744 \uc9c0\uc815\ud558\uba74\uc11c \uc2dc\uc791\ud569\ub2c8\ub2e4. \ub9cc\uc57d\uc5d0 \ub2e4\ub978 \uac12\uc73c\ub85c \ud560\ub2f9 \ub418\uc9c0 \uc54a\uc73c\uba74\n\t// \uc774 \uc0c9\uc774 \ud654\uba74\uc5d0 \ubcf4\uc5ec\uc9c0\uac8c \ub429\ub2c8\ub2e4.\n\tvec3 pixel = backgroundColor;\n\t\n\t// \uadf8\ub9ac\ub4dc\ub97c \ucd9c\ub825.\n\t// \uc774\ubc88\uc5d0\ub294 \ub8e8\ud504\ub97c \uc774\uc6a9\ud574 \ubaa8\ub4e0 \ud53d\uc140\uc744 \uac80\uc0ac\ud558\uc9c0 \uc54a\uace0\n    // \ub098\uba38\uc9c0 \uc5f0\uc0b0\uc744 \uc774\uc6a9\ud574\uc11c \ud55c\ubc88\uc758 \uacc4\uc0b0\uc73c\ub85c \uac19\uc740 \uacb0\uacfc\ub97c \uc5bb\uc5b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. (mikatalk\ub2d8 \uac10\uc0ac\ud569\ub2c8\ub2e4.)\n\tconst float tickWidth = 0.1;\n\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n    if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n    // Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 11\n//\uc88c\ud45c\uacc4\uc5d0 \ud654\uba74\ube44\uc728 \ub9cc\ub4e4\uae30 1.0\n//\n// \uc774\uc804 \uc608\uc81c\uc5d0\uc11c\ub294 \ud654\uba74\uc5d0 \uc815\uc0ac\uac01\ud615\uc774 \uadf8\ub824\uc9c0\uc9c0 \uc54a\uace0 \uc9c1\uc0ac\uac01\ud615\uc774 \uadf8\ub824\uc9c0\uac8c \ub429\ub2c8\ub2e4.\n// \uc774\uac83\uc740 \uc218\uce58\uc801\uc73c\ub85c\ub294 [0,1]\ub85c \ub450 \ucd95\uc774 \uac19\uc9c0\ub9cc \ubb3c\ub9ac\uc801 \uac70\ub9ac\ub294 \ub2e4\ub974\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4.\n// \uc0ac\uc2e4 \uac00\ub85c\uac00 \uc138\ub85c\ubcf4\ub2e4 \ub354 \ud07d\ub2c8\ub2e4.\n// \ub530\ub77c\uc11c \ud654\uba74\ube44\uc728\uc744 \uc720\uc9c0\ud558\uae30 \uc704\ud574\uc11c\ub294 \uc2e4\uc81c \uac70\ub9ac\uc778 \n// [0,iResolution.x] \uc640 [0, iResolution.y] \ub97c \uac19\uc740 \uac04\uaca9\uc73c\ub85c \ub9f5\ud551\ud558\uba74 \uc548\ub429\ub2c8\ub2e4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 2.0 * r.xy / iResolution.y;\n\t// r.x\ub97c iResolution.x \ub85c \ub098\ub204\uace0 r.y\ub97c iResolution.y\ub85c \ub098\ub204\ub294 \uac83 \ub300\uc2e0\n\t// \ub458\ub2e4 iResolution.y\ub85c \ub098\ub215\ub2c8\ub2e4.\n\t// \uc774 \ubc29\ubc95\uc73c\ub85c \ud558\uba74 r.y\ub294 [-1.0, 1.0] \uc774 \ub418\uace0\n\t// r.x \ub294 \ud504\ub808\uc784 \uc0ac\uc774\uc988\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4.\n\t// \uc804\uccb4\ud654\uba74\uc774 \uc544\ub2cc \uacbd\uc6b0\uc5d0\ub294 r.x \ub294 [-1.78,1.70] \uc815\ub3c4\uc77c\uac70\uace0, \uc81c\uac00 \uac00\uc9c4 \ub178\ud2b8\ubd81 \uc804\uccb4\ud654\uba74 \ubaa8\ub4dc\uc5d0\uc120\n\t// [-1.6, 1.6]\uc774 \ub429\ub2c8\ub2e4.(1440./900=1.6)\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// \uadf8\ub9ac\ub4dc\ub97c \uadf8\ub9bd\ub2c8\ub2e4.\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" \ub294 \ub77c\uc778\uc758 \uc88c\ud45c\uc785\ub2c8\ub2e4.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// \ucd95\uc744 \uadf8\ub9bd\ub2c8\ub2e4.\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 12\n// DISK\n//\n// Let's draw disks\n//\n// So, in GLSL we don't give a command of \"draw this disk here with that\n// color\". Instead we use an indirect command such as \"if the pixel \n// coordinate is inside this disk, put that color for the pixel\"\n// The indirect commands are a bit counter intuitive until you\n// get used to that way of thinking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\t// To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n\tfloat radius = 0.8;\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n\t\tpixel = col1;\n\t}\n\t\n\t// There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\tif( length(r) < 0.3) {\n\t\tpixel = col3;\n\t}\n\t\n\t// draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n\tvec2 center = vec2(0.9, -0.4);\n\tvec2 d = r - center;\n\tif( length(d) < 0.6) {\n\t\tpixel = col2;\n\t}\n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// Note how the latest disk is shown and previous ones are left\n// behind it. It is because the last if condition changes the pixel\n// value at the end.\n// If the coordinates of pixel fits multiple if conditions, the last\n// manipulation will remain and fragColor is set to that one.\n\n\n#elif TUTORIAL == 13\n// FUNCTIONS\n//\n// Functions are great for code reuse. Let's put the code for disks\n// into a function and use the function for drawing.\n// There are so many different ways of writing a function to draw a shape.\n//\n// Here we have a void function that does not return anything. Instead,\n// \"pixel\" is taken as an \"inout\" expression. \"inout\" is a unique\n// keyword of GLSL.\n// By default all arguments are \"in\" arguments. Which\n// means, the value of the variable is given to the function scope\n// from the scope the function is called. \n// An \"out\" variable gives the value of the variable from the function\n// to the scope in which the function is called.\n// An \"inout\" argument does both. First the value of the variable is\n// sent to the function as its argument. Then, that variable is\n// processed inside the function. When the function ends, the value\n// of the variable is updated where the function is called.\n//\n// Here, the \"pixel\" variable that is initialized with the background\n// color in the \"main\" function. Then, \"pixel\" is given to the \"disk\"\n// function. When the if condition is satisfied the value of the \"pixel\"\n// is changed with the \"color\" argument. If it is not satified, the\n// \"pixel\" is left untouched and keeps it previous value (which was the\n// \"bgColor\".\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tdisk(r, vec2(0.1, 0.3), 0.5, col3, pixel);\n\tdisk(r, vec2(-0.8, -0.6), 1.5, col1, pixel);\n\tdisk(r, vec2(0.8, 0.0), .15, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// As you see, the borders of the disks have \"jagged\" curves, where\n// individual pixels can be seen. This is called \"aliasing\". It occurs\n// because pixels have finite size and we want to draw a continuous\n// shape on a discontinuous grid.\n// There is a method to reduce the aliasing. It is done by mixing the\n// inside color and outside colors at the border. To achieve this\n// we have to learn some built-in functions.\n\n// And, again, note the order of disk function calls and how they are\n// drawn on top of each other. Each disk function manipulates\n// the pixel variable. If a pixel is manipulated by multiple disk\n// functions, the value of the last one is sent to fragColor.\n\n// In this case, the previous values are completely overwritten.\n// The final value only depends to the last function that manipulated\n// the pixel. There are no mixtures between layers.\n\n\n#elif TUTORIAL == 14\n// BUILT-IN FUNCTIONS: STEP\n//\n// \"step\" function is the Heaviside step function :-)\n// http://en.wikipedia.org/wiki/Heaviside_step_function\n// \n// f(x0, x) = {1 x>x0, \n//            {0 x<x0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(r.x < -0.6*xMax) { // Part I\n\t\tvariable = r.y;\n\t\tedge = 0.2;\n\t\tif( variable > edge ) { // if the \"variable\" is greater than \"edge\"\n\t\t\tret = 1.0;          // return 1.0\n\t\t} else {                // if the \"variable\" is less than \"edge\"\n\t\t\tret = 0.0;          // return 0.0\n\t\t}\n\t} \n\telse if(r.x < -0.2*xMax) { // Part II\n\t\tvariable = r.y;\n\t\tedge = -0.2;\n\t\tret = step(edge, variable); // step function is equivalent to the\n\t\t                            // if block of the Part I\n\t} \n\telse if(r.x < 0.2*xMax) { // Part III\n\t\t// \"step\" returns either 0.0 or 1.0.\n\t\t// \"1.0 - step\" will inverse the output\n\t\tret = 1.0 - step(0.5, r.y); // Mirror the step function around edge\n\t} \n\telse if(r.x < 0.6*xMax) { // Part IV\n\t\t// if y-coordinate is smaller than -0.4 ret is 0.3\n\t\t// if y-coordinate is greater than -0.4 ret is 0.3+0.5=0.8\n\t\tret = 0.3 + 0.5*step(-0.4, r.y);\n\t}\n\telse { // Part V\n\t\t// Combine two step functions to create a gap\n\t\tret = step(-0.3, r.y) * (1.0 - step(0.2, r.y));\n\t\t// \"1.0 - ret\" will create a gap\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 15\n// BUILT-IN FUNCTIONS: CLAMP\n//\n// \"clamp\" function saturates the input below and above the thresholds\n// f(x, min, max) = { max x>max\n//                  { x   max>x>min\n//                  { min min>x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 0.25) { // Part I\n\t\tret = p.y; // the brightness value is assigned the y coordinate\n\t\t           // it'll create a gradient\n\t} \n\telse if(p.x < 0.5) { // Part II\n\t\tfloat minVal = 0.3; // implementation of clamp\n\t\tfloat maxVal = 0.6;\n\t\tfloat variable = p.y;\n\t\tif( variable<minVal ) {\n\t\t\tret = minVal;\n\t\t}\n\t\tif( variable>minVal && variable<maxVal ) {\n\t\t\tret = variable;\n\t\t}\n\t\tif( variable>maxVal ) {\n\t\t\tret = maxVal;\n\t\t}\n\t} \n\telse if(p.x < 0.75) { // Part III\n\t\tfloat minVal = 0.6;\n\t\tfloat maxVal = 0.8;\n\t\tfloat variable = p.y;\n\t\tret = clamp(variable, minVal, maxVal);\n\t} \n\telse  { // Part IV\n\t\tfloat y = cos(5.*TWOPI*p.y); // oscillate between +1 and -1\n\t\t                             // 5 times, vertically\n\t\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\tret = clamp(y, 0.2, 0.8);\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 16\n// BUILT-IN FUNCTIONS: SMOOTHSTEP\n//\n// \"smoothstep\" function is like step function but instead of a\n// sudden jump from 0 to 1 at the edge, it makes a smooth transition\n// in a given interval\n// http://en.wikipedia.org/wiki/Smoothstep\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\tfloat edge = 0.5;\n\t\tret = step(edge, p.y); // simple step function\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// linearstep (not a builtin function)\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = (p.y - edge0)/(edge1 - edge0);\n\t\t// when p.y == edge0 => t = 0.0\n\t\t// when p.y == edge1 => t = 1.0\n\t\t// RHS is a linear function of y\n\t\t// so, between edge0 and edge1, t has a linear transition\n\t\t// between 0.0 and 1.0\n\t\tfloat t1 = clamp(t, 0.0, 1.0);\n\t\t// t will have negative values when t<edge0 and\n\t\t// t will have greater than 1.0 values when t>edge1\n\t\t// but we want it be constraint between 0.0 and 1.0\n\t\t// so, clamp it!\t\t\n\t\tret = t1;\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// implementation of smoothstep\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = 3.0*t*t - 2.0*t*t*t;\n\t\t// previous interpolation was linear. Visually it does not\n\t\t// give an appealing, smooth transition.\n\t\t// To achieve smoothness, implement a cubic Hermite polynomial\n\t\t// 3*t^2 - 2*t^3\n\t\tret = t1;\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tret = smoothstep(0.45, 0.55, p.y);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// smootherstep, a suggestion by Ken Perlin\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\t\t\n\t\t// 6*t^5 - 15*t^4 + 10*t^3\n\t\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\t\tret = t1;\n\t\t// faster transition and still smoother\n\t\t// but computationally more involved.\n\t}\t\n\t\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 17\n// BUILT-IN FUNCTIONS: MIX\n//\n// A shader can be created by first constructing individual parts\n// and composing them together.\n// There are different ways of how to combine different parts.\n// In the previous disk example, different disks were drawn on top\n// of each other. There was no mixture of layers. When disks\n// overlap, only the last one is visible.\n//\n// Let's learn mixing different data types (in this case vec3's\n// representing colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow \n\t\n\tvec3 ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\t// implementation of mix\n\t\tfloat x0 = 0.2; // first item to be mixed\n\t\tfloat x1 = 0.7;  // second item to be mixed\n\t\tfloat m = 0.1; // amount of mix (between 0.0 and 1.0)\n\t\t// play with this number\n\t\t// m = 0.0 means the output is fully x0\n\t\t// m = 1.0 means the output is fully x1\n\t\t// 0.0 < m < 1.0 is a linear mixture of x0 and x1\n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// try all possible mix values \n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// use the mix function\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = mix(x0, x1, m);\n\t\tret = vec3(val);\t\t\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\t// mix colors instead of numbers\n\t\tfloat m = p.y;\n\t\tret = mix(col1, col2, m);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// combine smoothstep and mix for color transition\n\t\tfloat m = smoothstep(0.5, 0.6, p.y);\n\t\tret = mix(col1, col2, m);\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 18\n// ANTI-ALIASING WITH SMOOTHSTEP\n//\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\tfloat m;\n\t\n\tfloat radius = 0.4; // increase this to see the effect better\n\tif( r.x < -0.5*xMax ) { // Part I\n\t\t// no interpolation, yes aliasing\n\t\tm = step( radius, length(r - vec2(-0.5*xMax-0.4,0.0)) );\n\t\t// if the distance from the center is smaller than radius,\n\t\t// then mix value is 0.0\n\t\t// otherwise the mix value is 1.0\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < -0.0*xMax ) { // Part II\n\t\t// linearstep (first order, linear interpolation)\n\t\tm = linearstep( radius-0.005, radius+0.005, length(r - vec2(-0.0*xMax-0.4,0.0)) );\n\t\t// mix value is linearly interpolated when the distance to the center\n\t\t// is 0.005 smaller and greater than the radius.\n\t\tpixel = mix(col1, bgCol, m);\n\t}\t\n\telse if( r.x < 0.5*xMax ) { // Part III\n\t\t// smoothstep (cubical interpolation)\n\t\tm = smoothstep( radius-0.005, radius+0.005, length(r - vec2(0.5*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < 1.0*xMax ) { // Part IV\n\t\t// smootherstep (sixth order interpolation)\n\t\tm = smootherstep( radius-0.005, radius+0.005, length(r - vec2(1.0*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 19\n// FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) {\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tvec3 col1 = vec3(0.841, 0.582, 0.594);\n\tvec3 col2 = vec3(0.884, 0.850, 0.648);\n\tvec3 col3 = vec3(0.348, 0.555, 0.641);\t\n\n\tvec3 pixel = bgCol;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridCol;\n\t\tif(abs(r.y - i)<0.004) pixel = gridCol;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesCol;\n\tif( abs(r.y)<0.007 ) pixel = axesCol;\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\t// pink functions\n\t// y = 2*x + 5\n\tif( abs(2.*x + .5 - y) < 0.02 ) pixel = col1;\n\t// y = x^2 - .2\n\tif( abs(r.x*r.x-0.2 - y) < 0.01 ) pixel = col1;\n\t// y = sin(PI x)\n\tif( abs(sin(PI*r.x) - y) < 0.02 ) pixel = col1;\n\t\n\t// blue functions, the step function variations\n\t// (functions are scaled and translated vertically)\n\tif( abs(0.25*step(0.0, x)+0.6 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*linearstep(-0.5, 0.5, x)+0.1 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smoothstep(-0.5, 0.5, x)-0.4 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smootherstep(-0.5, 0.5, x)-0.9 - y) < 0.01 ) pixel = col3;\n\t\n\t// yellow functions\n\t// have a function that plots functions :-)\n\tplot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, col2, pixel);\n\t// bell curve around -0.5\n\tplot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// in the future we can use this framework to see the plot of functions\n// and design and find functions for our liking\n// Actually using Mathematica, Matlab, matplotlib etc. to plot functions\n// is much more practical. But they need a translation of functions \n// from GLSL to their language. Here we can plot the native implementations\n// of GLSL functions.\n\n\n#elif TUTORIAL == 20\n// COLOR ADDITION AND SUBSTRACTION\n//\n// How to draw a shape on top of another, and how will the layers\n// below, affect the higher layers?\n//\n// In the previous shape drawing functions, we set the pixel\n// value from the function. This time the shape function will\n// just return a float value between 0.0 and 1.0 to indice the\n// shape area. Later that value can be multiplied with some color\n// and used in determining the final pixel color.\n\n// A function that returns the 1.0 inside the disk area\n// returns 0.0 outside the disk area\n// and has a smooth transition at the radius\nfloat disk(vec2 r, vec2 center, float radius) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-0.005, radius+0.005, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 gray = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\t\n\tvec3 ret;\n\tfloat d;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\t// opaque layers on top of each other\n\t\tret = gray;\n\t\t// assign a gray value to the pixel first\n\t\td = disk(r, vec2(-1.1,0.3), 0.4);\n\t\tret = mix(ret, col1, d); // mix the previous color value with\n\t\t                         // the new color value according to\n\t\t                         // the shape area function.\n\t\t                         // at this line, previous color is gray.\n\t\td = disk(r, vec2(-1.3,0.0), 0.4);\n\t\tret = mix(ret, col2, d);\n\t\td = disk(r, vec2(-1.05,-0.3), 0.4); \n\t\tret = mix(ret, col3, d); // here, previous color can be gray,\n\t\t                         // blue or pink.\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\t// Color addition\n\t\t// This is how lights of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Additive_color\n\t\tret = black; // start with black pixels\n\t\tret += disk(r, vec2(0.1,0.3), 0.4)*col1; // add the new color\n\t\t                                         // to the previous color\n\t\tret += disk(r, vec2(-.1,0.0), 0.4)*col2;\n\t\tret += disk(r, vec2(.15,-0.3), 0.4)*col3;\n\t\t// when all components of \"ret\" becomes equal or higher than 1.0\n\t\t// it becomes white.\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\t// Color substraction\n\t\t// This is how dye of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Subtractive_color\n\t\tret = white; // start with white\n\t\tret -= disk(r, vec2(1.1,0.3), 0.4)*col1;\n\t\tret -= disk(r, vec2(1.05,0.0), 0.4)* col2;\n\t\tret -= disk(r, vec2(1.35,-0.25), 0.4)* col3;\t\t\t\n\t\t// when all components of \"ret\" becomes equals or smaller than 0.0\n\t\t// it becomes black.\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 21\n// COORDINATE TRANSFORMATIONS: ROTATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tvec2 q;\n\tfloat angle;\n\tangle = 0.2*PI; // angle in radians (PI is 180 degrees)\n\t// q is the rotated coordinate system\n\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\n\tret = bgCol;\n\t// draw the old and new coordinate systems\n\tret = mix(ret, col1, coordinateGrid(r)*0.4 );\n\tret = mix(ret, col2, coordinateGrid(q) );\n\t\n\t// draw shapes in old coordinate system, r, and new coordinate system, q\n\tret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\tret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\t// as you see both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\t\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 22\n// COORDINATE TRANSFORMATIONS: SCALING\n//\n// Scaling the coordinate system.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\t\n\t// original\n\tfloat scaleFactor = 2.0; // zoom in this much\n\tret = mix(ret, col1, coordinateGrid(r)/2.0);\n\t// scaled\n\tvec2 q = 0.3*r;\n\tret = mix(ret, col2, coordinateGrid(q));\n\n\tret = mix(ret, col2, disk(q, vec2(0.0, 0.0), 0.1));\t\n\tret = mix(ret, col1, disk(r, vec2(0.0, 0.0), 0.1));\n\t\n\tret = mix(ret, col1, rectangle(r, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\tret = mix(ret, col2, rectangle(q, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\t\n\t// not how the rectangle that are not centered at the coordinate origin\n\t// changed its location after scaling, but the disks at the center\n\t// remained where they are.\n\t// This is because scaling is done by multiplying all pixel\n\t// coordinates with a constant.\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 23\n// SUCCESSIVE COORDINATE TRANSFORMATIONS\n//\n// Drawing a shape on the desired location, with desired size, and\n// desired orientation needs mastery of succesive application of\n// transformations.\n//\n// In general, transformations do not commute. Which means that\n// if you change their order, you get different results.\n//\n// Let's try application of transformations in different orders.\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\n\tfloat angle = 0.6;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\tif(p.x < 1./2.) { // Part I\n\t\t// put the origin at the center of Part I\n\t\tr = r - vec2(-xMax/2.0, 0.0); \n\n\t\tvec2 rotated = rotationMatrix*r;\n\t\tvec2 rotatedTranslated = rotated - vec2(0.4, 0.5);\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(rotated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(rotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(rotatedTranslated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t} \n\telse if(p.x < 2./2.) { // Part II\n\t\tr = r - vec2(xMax*0.5, 0.0); \n\n\t\tvec2 translated = r - vec2(0.4, 0.5);\n\t\tvec2 translatedRotated = rotationMatrix*translated;\n\t\t\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(translated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(translated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(translatedRotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\t\t\n\t} \t\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 24\n// TIME, MOTION AND ANIMATION\n//\n// One of the inputs that a shader gets can be the time.\n// In ShaderToy, \"iTime\" variable holds the value of the\n// time in seconds since the shader is started.\n//\n// Let's change some variables in time!\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\t\n\tif(p.x < 1./5.) { // Part I\n\t\tvec2 q = r + vec2(xMax*4./5.,0.);\n\t\tret = vec3(0.2);\n\t\t// y coordinate depends on time\n\t\tfloat y = iTime;\n\t\t// mod constraints y to be between 0.0 and 2.0,\n\t\t// and y jumps from 2.0 to 0.0\n\t\t// substracting -1.0 makes why jump from 1.0 to -1.0\n\t\ty = mod(y, 2.0) - 1.0;\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), 0.1) );\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\tvec2 q = r + vec2(xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\t// oscillation\n\t\tfloat amplitude = 0.8;\n\t\t// y coordinate oscillates with a period of 0.5 seconds\n\t\tfloat y = 0.8*sin(0.5*iTime*TWOPI);\n\t\t// radius oscillates too\n\t\tfloat radius = 0.15 + 0.05*sin(iTime*8.0);\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), radius) );\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\tvec2 q = r + vec2(xMax*0./5.,0.);\n\t\tret = vec3(0.4);\n\t\t// booth coordinates oscillates\n\t\tfloat x = 0.2*cos(iTime*5.0);\n\t\t// but they have a phase difference of PI/2\n\t\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n\t\tfloat radius = 0.2 + 0.1*sin(iTime*2.0);\n\t\t// make the color mixture time dependent\n\t\tvec3 color = mix(col1, col2, sin(iTime)*0.5+0.5);\n\t\tret = mix(ret, color, rect(q, vec2(x-0.1, y-0.1), vec2(x+0.1, y+0.1)) );\t\t\n\t\t// try different phases, different amplitudes and different frequencies\n\t\t// for x and y coordinates\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tvec2 q = r + vec2(-xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\tfor(float i=-1.0; i<1.0; i+= 0.2) {\n\t\t\tfloat x = 0.2*cos(iTime*5.0 + i*PI);\n\t\t\t// y coordinate is the loop value\n\t\t\tfloat y = i;\n\t\t\tvec2 s = q - vec2(x, y);\n\t\t\t// each box has a different phase\n\t\t\tfloat angle = iTime*3. + i;\n\t\t\tmat2 rot = mat2(cos(angle), -sin(angle), sin(angle),  cos(angle));\n\t\t\ts = rot*s;\n\t\t\tret = mix(ret, col1, rect(s, vec2(-0.06, -0.06), vec2(0.06, 0.06)) );\t\t\t\n\t\t}\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\tvec2 q = r + vec2(-xMax*4./5., 0.);\n\t\tret = vec3(0.2);\n\t\t// let stop and move again periodically\n\t\tfloat speed = 2.0;\n\t\tfloat t = iTime*speed;\n\t\tfloat stopEveryAngle = PI/2.0;\n\t\tfloat stopRatio = 0.5;\n\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\t\t\n\t\tfloat x = -0.2*cos(t1);\n\t\tfloat y = 0.3*sin(t1);\n\t\tfloat dx = 0.1 + 0.03*sin(t*10.0);\n\t\tfloat dy = 0.1 + 0.03*sin(t*10.0+PI);\n\t\tret = mix(ret, col1, rect(q, vec2(x-dx, y-dy), vec2(x+dx, y+dy)) );\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 25\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./10.) { // Part I\n\t\t// vertical waves\n\t\tret = vec3(v1);\n\t} \n\telse if(p.x < 2./10.) { // Part II\n\t\t// horizontal waves\n\t\tret = vec3(v2);\n\t} \n\telse if(p.x < 3./10.) { // Part III\n\t\t// diagonal waves\n\t\tret = vec3(v3);\n\t}\n\telse if(p.x < 4./10.) { // Part IV\n\t\t// circular waves\n\t\tret = vec3(v4);\n\t}\n\telse if(p.x < 5./10.) { // Part V\n\t\t// the sum of all waves\n\t\tret = vec3(v);\n\t}\t\n\telse if(p.x < 6./10.) { // Part VI\n\t\t// Add periodicity to the gradients\n\t\tret = vec3(sin(2.*v));\n\t}\n\telse if(p.x < 10./10.) { // Part VII\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t}\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\n\n\n#elif TUTORIAL == 26\n// TEXTURES\n//\n// ShaderToy can use upto four textures. \n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\tret = texture(iChannel1, p).xyz;\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\tret = texture(iChannel1, 4.*p+vec2(0.,iTime)).xyz;\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\tr = r - vec2(xMax*2./3., 0.);\n\t\tfloat angle = iTime;\n\t\tmat2 rotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tvec2 q = rotMat*r;\n\t\tvec3 texA = texture(iChannel1, q).xyz;\n\t\tvec3 texB = texture(iChannel2, q).xyz;\n\t\t\n\t\tangle = -iTime;\n\t\trotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tq = rotMat*r;\t\t\n\t\tret = mix(texA, texB, rect(q, vec2(-0.3, -0.3), vec2(.3, .3)) );\n\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 27\n// MOUSE INPUT\n//\n// ShaderToy gives the mouse cursor coordinates and button clicks\n// as an input via the iMouse vec4.\n//\n// Let's write a shader with basic Mouse functionality.\n// When clicked on the frame, the little disk will follow the\n// cursor. The x coordinate of the cursor changes the background color.\n// And if the cursor is inside the bigger disk, it'll color will change.\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\t// background color depends on the x coordinate of the cursor\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec2 center;\n\t// draw the big yellow disk\n\tcenter = vec2(100., iResolution.y/2.);\n\tfloat radius = 60.;\n\t// if the cursor coordinates is inside the disk\n\tif( length(iMouse.xy-center)>radius ) {\n\t\t// use color3\n\t\tret = mix(ret, col3, disk(fragCoord.xy, center, radius));\n\t}\n\telse {\n\t\t// else use color2\n\t\tret = mix(ret, col2, disk(fragCoord.xy, center, radius));\n\t}\t\n\t\n\t// draw the small blue disk at the cursor\n\tcenter = iMouse.xy;\n\tret = mix(ret, col1, disk(fragCoord.xy, center, 20.));\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n#elif TUTORIAL == 28\n// RANDOMNESS\n//\n// I don't know why, but GLSL does not have random number generators.\n// This does not pose a problem if you are writing your code in\n// a programming language that has random functions. That way\n// you can generate the random values using the language and send\n// those values to the shader via uniforms.\n//\n// But if you are using a system that only allows you to write\n// the shader code, such as ShaderToy, then you need to write your own\n// pseuo-random generators.\n//\n// Here is a pattern that I saw again and again in many different\n// shaders at ShaderToy.\n// Let's draw N different disks at random locations using this pattern.\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 hashPosition(float x)\n{\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec2(hash(x), hash(x * 1.1));\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.005, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.y));\n\treturn ret;\n}\n\nfloat plot(vec2 r, float y, float thickness) {\n\treturn ( abs(y - r.y) < thickness ) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec3 white = vec3(1.);\n\tvec3 gray = vec3(.3);\n\tif(r.y > 0.7) {\n\t\t\n\t\t// translated and rotated coordinate system\n\t\tvec2 q = (r-vec2(0.,0.9))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// just the regular sin function\n\t\tfloat y = sin(5.*q.x) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.1));\n\t}\n\telse if(r.y > 0.4) {\n\t\tvec2 q = (r-vec2(0.,0.6))*vec2(1.,20.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\t// take the decimal part of the sin function\n\t\tfloat y = fract(sin(5.*q.x)) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\t\n\telse if(r.y > 0.1) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0.,0.25))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// scale up the outcome of the sine function\n\t\t// increase the scale and see the transition from\n\t\t// periodic pattern to chaotic pattern\n\t\tfloat scale = 10.0;\n\t\tfloat y = fract(sin(5.*q.x) * scale) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.2));\n\t}\t\n\telse if(r.y > -0.2) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0., -0.0))*vec2(1.,10.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\tfloat seed = q.x;\n\t\t// Scale up with a big real number\n\t\tfloat y = fract(sin(seed) * 43758.5453) * 2.0 - 1.0;\n\t\t// this can be used as a pseudo-random value\n\t\t// These type of function, functions in which two inputs\n\t\t// that are close to each other (such as close q.x positions)\n\t\t// return highly different output values, are called \"hash\"\n\t\t// function.\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\n\telse {\n\t\tvec2 q = (r-vec2(0., -0.6));\n\t\t\n\t\t// use the loop index as the seed\n\t\t// and vary different quantities of disks, such as\n\t\t// location and radius\n\t\tfor(float i=0.0; i<6.0; i++) {\n\t\t\t// change the seed and get different distributions\n\t\t\tfloat seed = i + 0.0; \n\t\t\tvec2 pos = (vec2(hash(seed), hash(seed + 0.5))-0.5)*3.;;\n\t\t\tfloat radius = hash(seed + 3.5);\n\t\t\tpos *= vec2(1.0,0.3);\n\t\t\tret = mix(ret, col1, disk(q, pos, 0.2*radius));\n\t\t}\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n\n\n/* End of tutorials */\n\n#elif TUTORIAL == 0\n// WELCOME SCREEN\nfloat square(vec2 r, vec2 bottomLeft, float side) {\n\tvec2 p = r - bottomLeft;\n\treturn ( p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side ) ? 1.0 : 0.0;\n}\n\nfloat character(vec2 r, vec2 bottomLeft, float charCode, float squareSide) {\n\tvec2 p = r - bottomLeft;\n\tfloat ret = 0.0;\n\tfloat num, quotient, remainder, divider;\n\tfloat x, y;\t\n\tnum = charCode;\n\tfor(int i=0; i<20; i++) {\n\t\tfloat boxNo = float(19-i);\n\t\tdivider = pow(2., boxNo);\n\t\tquotient = floor(num / divider);\n\t\tremainder = num - quotient*divider;\n\t\tnum = remainder;\n\t\t\n\t\ty = floor(boxNo/4.0); \n\t\tx = boxNo - y*4.0;\n\t\tif(quotient == 1.) {\n\t\t\tret += square( p, squareSide*vec2(x, y), squareSide );\n\t\t}\n\t}\n\treturn ret;\n}\n\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat G = 990623.; // compressed characters :-)\n\tfloat L = 69919.;\n\tfloat S = 991119.;\n\t\n\tfloat t = iTime;\n\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t//vec2 rL = rot(t)*r+0.0001*t;\n\t//vec2 rL = r+vec2(cos(t*0.02),sin(t*0.02))*t*0.05;\n\tfloat c = 0.05;//+0.03*sin(2.5*t);\n\tvec2 pL = (mod(r+vec2(cos(0.3*t),sin(0.3*t)), 2.0*c)-c)/c;\n\tfloat circ = 1.0-smoothstep(0.75, 0.8, length(pL));\n\tvec2 rG = rot(2.*3.1415*smoothstep(0.,1.,mod(1.5*t,4.0)))*r;\n\tvec2 rStripes = rot(0.2)*r;\n\t\t\t\t\n\tfloat xMax = 0.5*iResolution.x/iResolution.y;\n\tfloat letterWidth = 2.0*xMax*0.9/4.0;\n\tfloat side = letterWidth/4.;\n\tfloat space = 2.0*xMax*0.1/5.0;\n\t\n\tr += 0.001; // to get rid off the y=0 horizontal blue line.\n\tfloat maskGS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskG = character(rG, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskL1 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*1.0, L, side);\n\tfloat maskSS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0, S, side);\n\tfloat maskS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0 + vec2(0.01*sin(2.1*t),0.012*cos(t)), S, side);\n\tfloat maskL2 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*3.0, L, side);\n\tfloat maskStripes = step(0.25, mod(rStripes.x - 0.5*t, 0.5));\n\t\n\tfloat i255 = 0.00392156862;\n\tvec3 blue = vec3(43., 172., 181.)*i255;\n\tvec3 pink = vec3(232., 77., 91.)*i255;\n\tvec3 dark = vec3(59., 59., 59.)*i255;\n\tvec3 light = vec3(245., 236., 217.)*i255;\n\tvec3 green = vec3(180., 204., 18.)*i255;\n\n\tvec3 pixel = blue;\n\tpixel = mix(pixel, light, maskGS);\n\tpixel = mix(pixel, light, maskSS);\n\tpixel -= 0.1*maskStripes;\t\n\tpixel = mix(pixel, green, maskG);\n\tpixel = mix(pixel, pink, maskL1*circ);\n\tpixel = mix(pixel, green, maskS);\n\tpixel = mix(pixel, pink, maskL2*(1.-circ));\n\t\n\tfloat dirt = pow(texture(iChannel0, 4.0*r).x, 4.0);\n\tpixel -= (0.2*dirt - 0.1)*(maskG+maskS); // dirt\n\tpixel -= smoothstep(0.45, 2.5, length(r));\n\tfragColor = vec4(pixel, 1.0);\n}\n#endif",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}