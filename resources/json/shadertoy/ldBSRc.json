{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ldBSRc",
      "date": "1414280399",
      "viewed": 150,
      "name": "Nyan Kitten",
      "username": "4rknova",
      "description": "nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "nyancat"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 14,
            "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// by Nikos Papadopoulos, 4rknova / 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define CAMERA_ANIMATION\n#define CAMERA_ANIMATION_ROTATE\n#define CAMERA_ANIMATION_ZOOM\n#define RAINBOW_TRAIL_QUANTIZATION\n#define RAINBOW_TRAIL_FADING\n\n#define SUPERSAMPLING\n#define AA\t4.\n\n#define SZ 12.                 // Stars size\n#define RP 8.5                 // Rainbow wave length\n#define RS 13.5                // Rainbow wave speed\n#define RA 0.013               // Rainbow wave amplitude\n#define R6 vec4(.5, .0, .9, 1) // Rainbow wave color 6\n#define R5 vec4(.0, .4, .9, 1) // Rainbow wave color 5\n#define R4 vec4(.0, .9, .0, 1) // Rainbow wave color 4\n#define R3 vec4(.9, .9, .0, 1) // Rainbow wave color 3\n#define R2 vec4(.9, .6, .0, 1) // Rainbow wave color 2\n#define R1 vec4(.9, .0, .0, 1) // Rainbow wave color 1\n#define BG vec3(.0, .2, .4567) // Background color\n#define SS 0.15625             // Size of sprite segment\n#define SC 6.0                 // Number of sprite segments\n#define SU RS                  // Animation speed\n#define BT iTime         // Base time\n\nvec3 background(vec2 p, inout vec4 fragColor)\n{\n    fragColor = vec4(BG, 1);\n    return BG;\n}\n\nvec2 grid(vec2 p, vec2 sz)\n{\n    return floor(p * sz);\n}\n\nvoid rainbow(vec2 p, inout vec4 fragColor)\n{\n    float x = \n#ifdef RAINBOW_TRAIL_QUANTIZATION\n    \tfloor(RP * p.x);\n#else\n        p.x;\n#endif\n\n    // Transformation\n    p.y += sin(x * RP + RS * BT) * RA; // Wavy line\n    p.y = p.y * 1.2 - .22;             // Scale\n\n    // Bounds test\n    if (p.y >= .7 || p.y <= 0.1 || p.x > .33) return;\n    else if (p.y > .6) fragColor = R6; // Color 6\n    else if (p.y > .5) fragColor = R5; // Color 5\n    else if (p.y > .4) fragColor = R4; // Color 4\n    else if (p.y > .3) fragColor = R3; // Color 3\n    else if (p.y > .2) fragColor = R2; // Color 2\n\telse               fragColor = R1; // Color 1\n        \n#ifdef RAINBOW_TRAIL_FADING\n    fragColor.xyz = abs(mix(BG, fragColor.xyz,\n                               pow(clamp(1.2 + p.x, 0., 1.), 1.4)));\n#endif\n}\n\nvoid nyan(vec2 p, inout vec4 fragColor)\n{\n    p.x *=0.7; \n    if (p.x >= 1. || p.x <= 0. || p.y >= 1. || p.y <= 0. ) return;\n    float x = (floor(mod(BT * SU, SC)) + p.x) * SS;\n\tvec4 s = texture(iChannel0, vec2(x, p.y));\n\tif (s.w > 0.) fragColor = s;\n}\n\nvoid draw(vec2 p, inout vec4 fragColor)\n{\n    // Draw elements using the painter's algorithm.\n    background(p, fragColor);\n    rainbow(p, fragColor);\n    nyan(p, fragColor);\n}\n\nvec2 camera(vec2 p)\n{\n#ifdef CAMERA_ANIMATION_ZOOM\n    p *= (3.5 + 0.5 * cos(RP + BT * 0.42 + 0.92));\n#else\n    p *= 3.;\n#endif\n    \n    p -= vec2(1.2 + .3 * cos(1.29 + BT), 1. + sin(0.3 * BT) * .6);\n    \n#ifdef CAMERA_ANIMATION_ROTATE\n    float bt = 0.1 * cos(BT);\n    float st = sin(bt);\n    float ct = cos(bt);\n    p = vec2(p.x * ct - p.y * st, p.y * ct + p.x * st);\n#endif\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(\n        fragCoord.x / iResolution.y, \n        1.0 - fragCoord.y / iResolution.y);\n\t\n    vec2 p = uv;\n\n#ifdef CAMERA_ANIMATION\n    p = camera(uv);\n#else\n    p = p * 3. - vec2(1.2, 1.);\n#endif\n    \n#ifdef SUPERSAMPLING\n    // Antialiasing via supersampling\n    vec3 col = vec3(0);    \n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\t\n            draw(p + vec2(i, j) * (e/AA), fragColor);\n            \n            col += fragColor.xyz / (4.*AA*AA);\n        }\n    }\n    \n    fragColor = vec4(col, 1);\n#else\n    draw(p);\n#endif /* SUPERSAMPLING */\n\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}