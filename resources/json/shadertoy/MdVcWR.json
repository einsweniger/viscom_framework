{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "MdVcWR",
      "date": "1521916367",
      "viewed": 188,
      "name": "Source and Sink in Uniform Flow",
      "username": "ttg",
      "description": "Models streamlines of a 2D inviscid, incompressible flow consisting of\n  uniform flow, source, sink, and vortex.\nMouse controls source/sink separation (left/right) and\n  magnitude of vortex (up/down).\n\nSee source for full description.",
      "likes": 4,
      "published": 3,
      "flags": 0,
      "tags": [
        "fluid"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "/*\nSource and Sink in Uniform Flow\n\nModels streamlines of a 2D inviscid, incompressible flow consisting of\n  uniform flow, source, sink, and vortex.\nMouse controls source/sink separation (left/right) and\n  magnitude of vortex (up/down).\n\nStreamlines are obtained by finding contours of a stream function.\n\nCopyright 2018 Theron Tarigo\n*/\n\n// length(r), atan2(r) - convert a vector in xy to radial and angular polar components\n\nconst float pi = 3.141592653589793;\nfloat atan2 (vec2 v) { return atan(v.y, v.x); }\n\nvec2 r_mouse;\n\n// Number of streamlines per unit of stream function\nconst float linefreq = 16.0;\n\n// Define stream function\nfloat phi (vec2 r) {\n    float phi = 0.;\n\n    // Magnitude of uniform flow velocity\n    float v_0 = 1.;\n\n    // Let source/sink separation distance depend on mouse x-coordinate\n    float source_sink_distance = r_mouse.x;\n    \n    // Magnitude of source and sink flow rate\n    //   Inversely proportional to source/sink separation distance.\n    float VdL = -0.5/source_sink_distance;\n    // Select values which will not cause breaks in visualized streamlines:\n    VdL = floor(linefreq*VdL)/linefreq;\n\n    // Magnituded of vortex\n    //   Dependent (nonlinearly) on mouse y-coordinate\n    float vortex_k = pow(abs(r_mouse.y),3.)*4.*sign(r_mouse.y);\n    \n    // Add steady flow\n    phi += v_0 * r.y;\n\n    // Add source\n    phi += VdL/(2.*pi) * atan2(r - r_mouse*vec2(1.,0.));\n\n    // Add sink\n    phi -= VdL/(2.*pi) * atan2(r + r_mouse*vec2(1.,0.));\n\n    // Add vortex\n    phi -= vortex_k * log(length(r));\n\n    return phi;\n}\n\n\n\n\n\n//////////////////////////////\n// Following expressions are used to extract contours from the stream function phi\n\nvec2 d_phi_d_r (vec2 r) {\n    float delta = 0.001;\n    for (int i = 0; i < 2; i++) {\n        vec2 d_phi = vec2(\n            phi(r+delta*vec2(1,0)) - phi(r-delta*vec2(1,0)),\n            phi(r+delta*vec2(0,1)) - phi(r-delta*vec2(0,1))\n          );\n        if (length(d_phi) < 0.1) return d_phi / delta;\n        r.y+=0.01;\n    }\n    return vec2(1./0.);\n}\n\nfloat lensq (vec2 x) { return dot(x,x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy*2.;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.yy*2.;\n    r_mouse = mouse+1e-3;\n    if (length(iMouse.xy)<5.) r_mouse = vec2(-0.001,0.0);\n    \n    float phi = phi(uv);\n\n    float gradm = lensq(d_phi_d_r(uv));\n    vec3 col = clamp(-1.+2.*vec3(pow(abs(cos(phi*linefreq*pi)),25./gradm)), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}