{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "Ms2yWz",
      "date": "1491738424",
      "viewed": 342,
      "name": "[ #11 ] - Perlin morph",
      "username": "Yrai",
      "description": "Experiment with Perlin noise space transformation and triplanar mapping.",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "3d",
        "raymarching",
        "noise",
        "perlin",
        "triplanar"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 6,
            "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
            "ctype": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 45,
            "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Raymarch params\n#define march_steps_   1024\n#define march_range_   1000.\n#define shadow_perc_   1e-1\n#define dist_perc_     1.\n#define epsilon_       1e-4\nstruct  t_object      { int id; float d; };\n\n// Constants, redefinitions\n#define mouse_x         (iMouse.xy / iResolution.xy).x\n#define mouse_y         (iMouse.xy / iResolution.xy).y\n#define mod3_           vec3(.1031, .11369, .13787)\n#define res_            iResolution\n#define time_           iTime\n#define pi_             3.14159265\n\n// Primitives, objects\nfloat d_sphere(vec3 p, float r);\nfloat d_ellipsoid(vec3 p, vec3 r);\nfloat d_cylinder6(vec3 p, vec2 h);\nfloat d_rounded_cuboid(vec3 p, vec3 b, float r);\nfloat length6(vec2 p);\n    \n// Operators\nfloat _union_stairs(float a, float b, float r, float n);\n\n// Transformations\nvec2 domain(vec2 uv, float s);\nmat3 rot(vec3 ang);\n\n// Noise\nfloat perlin_noise3(vec3 p);\nvec3  hash3_3(vec3 p3);\n\n// Geometrical calculations\nt_object march(vec3 ro, vec3 rd);\nt_object eval_scene(vec3 p);\nvec3     normal(vec3 p);\n\n// Camera\nvoid  camera(\n    vec2 p, out vec3 ro, out vec3 rd, float or,\n    float oh, vec3 target, float roll, float ll\n);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\n\n// Shading\nvec3  render(vec2 p, vec3 ro, vec3 rd);\nvec3  pixel_color(vec3 p, vec3 rd, float dis, int mal_id);\nvec3  material_builder(vec3 p, vec3 rd, float dis, int id);\n\nfloat oren_nayar(vec3 l, vec3 rd, vec3 nor, float roughness, float albedo);\nfloat gaussian(vec3 l, vec3 rd, vec3 nor, float shininess);\nfloat fog_exp2(float dist, float density);\nfloat soft_shadow(vec3 ro, vec3 rd);\n\n\n// Main \n// ------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n\tvec2 p = domain(fragCoord, 1.);\n    \n    vec3 ro, rd;\n    vec3 target = vec3(0.);\n    camera(p, ro, rd, 15., 8., target, 0., 1.5);\n    \n    vec3 col = render(p, ro, rd);\n    fragColor = vec4(col, 1.);\n}\n// ------------------------------------------------------\n\nt_object eval_scene(vec3 p) {\n    vec3 q = p;\n    float s = length(q - .6*perlin_noise3(q+time_) ) - 3.;\n    \n    \n    float pl = p.y+3.;\n\n    const int scene_size = 2;\n    float objs[scene_size];\n    objs[0] = s;\n\tobjs[1] = _union_stairs(pl, s, 1., 4.1);\n    \n    float d = objs[0]; int id=0;\n    for(int i = 0; i < scene_size; i++) {\n        if(objs[i] < d) {\n            d = objs[i];\n        \tid = i;\n        }\n    }\n        \n    return t_object(id, d);\n}\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n){\n    n = max((abs(n) - 0.2)*7., 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n\nvec3 material_builder(vec3 p, vec3 rd, float dis, int id) {\n    vec3 n = normal(p);\n    if(id == 0) { // Sphere        \n\t\tvec3 col = vec3(0.05);\n\t\t\n        col = mix(col, tex3D(iChannel0, p / 16., n), 1.);\n        return col;\n    }\n    else if(id == 1) { // Plane\n        vec3 col = vec3(0.5);\n        col = mix(col, tex3D(iChannel1, p/32., n), 1.);\n        col = mix(col, vec3(0.0, 1.1, 1.5) * rd.y, fog_exp2(dis, .03) );\n        return col;\n    }\n    else if(id == 2) { // Sky\n    \treturn vec3(0.2, 1.1, 1.4)*rd.y;\n    }\n}\n\nvec3 pixel_color(vec3 p, vec3 rd, float dis, int mal_id) {\n    vec3 l   = normalize(vec3(0.345));\n    vec3 mrd = normalize(-rd);\n    vec3 nor = normal(p);\n    \n    vec3 lin = vec3(0.1);\n  \tvec3 brigh = vec3(.3);\n    vec3 mal = material_builder(p, rd, dis, mal_id);\n    \n    float al = 0.05;\n    float spec = gaussian(l, mrd, nor, -1.);\n    float diff = max(0., oren_nayar(l, mrd, nor, .1, 5.) );\n    float sha = soft_shadow(p+shadow_perc_*nor, l);\n   \n    lin  += (spec + diff + al) * brigh * (mal_id != 0 ? sha : 1.);\n    \n    vec3 col = mal * lin;\n    return col;\n}\n\nt_object march(vec3 ro, vec3 rd) {\n\tfloat d = 1.;\n    float curd = 0.;\n    int id;\n    \n    t_object obj;\n    for(int i=0; i < march_steps_; i++) {\n        if(d < epsilon_ || curd > march_range_) break;\n        obj = eval_scene(ro + curd*rd);\n        d = obj.d*dist_perc_;\n        curd += d;\n    }\n    \n    obj.d = curd;\n    return obj;\n}\n\nvec3 render(vec2 p, vec3 ro, vec3 rd) {\n    t_object obj = march(ro, rd);\n    vec3 pos = ro + obj.d * rd;\n    \n    if(obj.d < march_range_) {\n        return pixel_color(pos, rd, obj.d,  obj.id);\n    }\n    else {\n        return pixel_color(pos, rd, obj.d,  2);\n    }\n    \n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(epsilon_, 0.0);\n    return normalize(vec3(\n        eval_scene(p+e.xyy).d-eval_scene(p-e.xyy).d,\n        eval_scene(p+e.yxy).d-eval_scene(p-e.yxy).d,\n        eval_scene(p+e.yyx).d-eval_scene(p-e.yyx).d\n    ));\n}\n\n// Camera\n// ----------------------------------------------------------------------------------------------------------------------------------\nvoid camera(\n    vec2 p, out vec3 ro, out vec3 rd, float or,\n    float oh, vec3 target, float roll, float ll\n)\n{\n    float mx = 10. * mouse_x;\n    float my = 10. * mouse_y;\n    float t = time_/30.;\n    \n    ro = vec3(or * sin(mx), oh - my, or * cos(mx));\n    \n    mat3 lam = look_at(ro, target, roll);    \n\trd = normalize(lam * vec3(p.xy, ll)); \n}\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Lighting, color calculations\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat oren_nayar(vec3 l, vec3 rd, vec3 nor, float roughness, float albedo) {  \n  float ldrd = dot(l, rd);\n  float nordl = dot(l, nor);\n  float nordrd = dot(nor, rd);\n\n  float s = ldrd - nordl * nordrd;\n  float t = mix(1., max(nordl, nordrd), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float a = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float b = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(.0, nordl) * (a + b * s / t) / pi_;\n}\n\nfloat gaussian(vec3 l, vec3 rd, vec3 nor, float shininess) {\n  vec3 h = normalize(l + rd);\n  float theta = acos(dot(h, nor));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nfloat fog_exp2(float dist, float dens) {\n  const float log2v = -1.442695;\n  float d = dens * dist;\n  return 1. - clamp(exp2(d * d * log2v), 0., 1.);\n}\n\nfloat soft_shadow(vec3 ro, vec3 rd) {\n    float res = 1.;\n    float t = .0001;                     \n\tfloat h = 1.;\n    for(int i = 0; i <20; i++) {         \n        h = eval_scene(ro + rd*t).d;\n        res = min(res, 4.*h/t);          \n\t\tt += clamp(h, .02, 1.);          \n    }\n    return clamp(res, 0., 1.);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Noise\n// ----------------------------------------------------------------------------------------------------------------------------------\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3. - 2. * pf);\n    \n    return \tmix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Domain transformations\n// ----------------------------------------------------------------------------------------------------------------------------------\nvec2 domain(vec2 uv, float s) {\n    return (2.*uv.xy-res_.xy) / res_.y*s;\n}\nmat3 rot(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Primitives\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat d_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat d_ellipsoid(vec3 p, vec3 r) {\n    return (length(p/r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat d_cylinder6( vec3 p, vec2 h ){\n  return max(length6(p.xz) - h.x, abs(p.y) - h.y);\n}\n\nfloat length6(vec2 p) {\n\tp = p * p * p; p = p * p;\n\treturn pow(p.x + p.y, 1./6.);\n}\n\nfloat d_rounded_cuboid(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.)) - r;\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n// Operators\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat _union_stairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n// Objects\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------------------------------------------------------------",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}