{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XllBDl",
      "date": "1513959918",
      "viewed": 265,
      "name": "Festive Pentagram",
      "username": "mla",
      "description": "Glowing pentagram (or other star polygon) in 3D.\n\nN controls number of sides",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "star",
        "festive",
        "pentagram"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// (c) Matthew Arcus 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Glowing festive pentagram: ray trace 5 rotations of basic line, use\n// distance of ray to line to determine color.\nconst int N = 5; // Number of lines\nconst float scale = 4.0;\nconst float A = 0.6; // Light amplitude\nconst float K = 0.4; // Concentration\nconst float R = 1.0; // Radius\nconst float PI = 3.14159;\nconst float theta = 2.0*PI/float(N);\nconst mat3 m = mat3(cos(theta),sin(theta),0,\n                    -sin(theta),cos(theta),0,\n                    0,0,1);\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Quaternion to rotation matrix\n// Assumes normalized\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x*x, y2 = y*y, z2 = z*z;\n  float xy = x*y, xz = x*z, xw = x*w;\n  float yz = y*z, yw = y*w, zw = z*w;\n  return 2.0*mat3(0.5-y2-z2, xy+zw, xz-yw,\n                  xy-zw, 0.5-x2-z2, yz+xw,\n                  xz+yw, yz-xw, 0.5-x2-y2);\n}\n\n#if 1\nfloat det(vec2 c0, vec2 c1) {\n  return determinant(mat2(c0,c1));\n  //return c0.x*c1.y - c0.y*c1.x;\n}\n\nvec2 closest(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Use Cramer's rule to solve linear system\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  vec2 c0 = vec2(1.0,dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-1.0);\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  return vec2(det(a,c1),det(c0,a))/det(c0,c1);\n}\n#else\n// This version doesn't work on Android Chrome.\n// return vec2(k,j) such that p + kq and\n// r + js are closest points on lines\n// Assumes q and s are normalized\nvec2 closest(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  mat2 m = mat2(-1.0,-dot(q,s),dot(q,s),1.0);\n  float idet = 1.0/(m[0][0]*m[1][1]-m[0][1]*m[1][0]);\n  return idet*m*vec2(dot(r-p,q),dot(r-p,s));\n}\n#endif\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  vec3 p = vec3(0,0,-6);\n  vec3 q = normalize(vec3(xy,0)-p);\n  // r+js is polygon line, to be rotated in loop\n  vec3 r = vec3(0,1,0);\n  vec3 s = vec3(1,0,0);\n  // Rotation axis\n  vec3 axis = normalize(vec3(1,1,cos(0.1*iTime)));\n  float phi = iTime*0.15;\n  mat3 n = qrot(vec4(sin(phi)*axis,cos(phi)));\n  p = n*p; q = n*q;\n  float mindist = 1e10;\n  vec3 color = vec3(0); // Accumulate color here\n  for (int i = 0; i < N; i++) {\n    vec2 k = closest(p,q,r,s);\n    vec3 p1 = p+k.x*q;\n    vec3 r1 = r+k.y*s;\n    float d = distance(p1,r1);\n    float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n    vec3 basecolor = hsv2rgb_smooth(vec3(h,1.0,1.0));\n    color += A*float(k.x > 0.0)*(1.0-pow(smoothstep(0.0,R,d),K))*basecolor;\n    s = m*s; r = m*r; // Rotate to next line\n  }\n  outColor = vec4(sqrt(color),1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}