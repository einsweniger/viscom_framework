{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "MddcDB",
      "date": "1520123733",
      "viewed": 212,
      "name": "Sometimes It Snows In April",
      "username": "Del",
      "description": "Sometimes It Snows In April",
      "likes": 5,
      "published": 3,
      "flags": 32,
      "tags": [
        "raymarch",
        "sdf",
        "snow",
        "symbol",
        "svg"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Sometimes It Snows In April - Del 04/03/2018\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    mouse = vec2(0.0);\n    float an = 10.0*mouse.x;\n\tcamPos = vec3(3.5*sin(an),1.0+mouse.y*2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    p.y += 0.5;\n    float scale = sin(iTime*1.25)*0.15;\n    \n    float  c = cos(scale*p.y+scale);\n    float  s = sin(scale*p.y+scale);\n    mat2   m = mat2(c,-s,s,c);\n    p = vec3(m*p.zy,p.x);\n    p.y -= 0.5;\n    return p;\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\nfloat SampleDistanceTexture(vec2 texuv)\n{\n    float aspect = iResolution.y/iResolution.x;\n    float scale = 0.25;\n    texuv.y *= scale;\n    texuv.x *= scale;\n\ttexuv.x *= aspect;\n\tfloat dist = texture(iChannel0, (texuv+0.5)).w +0.000000001;\n    return dist-0.5;\n}\n\n\nvec2 doModel( vec3 p )\n{\n    vec2 res = vec2( sdPlane(p+vec3(0.0,1.75,0.0)), 1.0);\t// floor...\n    \n    vec3 r1 = rotateY(p,iTime*0.8);\n    if (iMouse.w>0.5)\n    {\n\t\tr1 = rotateY(r1, sin(iTime*1.5-+p.y*0.5));\n    \tr1 = opTwist(r1);\n    }\n    \n\tfloat symbolDist = SampleDistanceTexture(r1.xy);\n    symbolDist-= 0.07;\n    symbolDist *= 0.25;\n\tfloat boxdist = sdBox(r1, vec3(0.5 + 2.0, 2.5, 0.1));\n    symbolDist = max(symbolDist,boxdist);\n    res = opU(res,vec2(symbolDist,2.0));\n    \n    if (iMouse.w>0.5)\n\t    res.x *= 0.9;\n    return res;\n}\n\n//------------------------------------------------------------------------\n// Material \n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\nvec3 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n        float f = mod( floor(1.5*pos.z) + floor(1.5*pos.x), 2.0);\n        vec3 col = 0.2 + 0.2*f+0.2*vec3(0.8,0.05,0.8);\n\t    return col;\n    }\n    return vec3(0.15,0.03,0.22);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.4,0.35,0.7));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    float _s = 1.5;\n\tfloat spec = pow(dif, 160.0) *_s;\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n        col+=spec;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 30.0;           // max trace distance\n\tconst float precis = 0.0001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 50.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n//snow original -> http://glslsandbox.com/e#36547.1\nfloat snow(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n\tuv+=time/scale;\n    uv.y+=time*2./scale;\n    uv.x+=sin(uv.y+time*.5)/scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\n\nvec3 _Snow(vec2 uv,vec3 background)\n{\n\tfloat c = snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tc+=snow(uv,5.);\n    c = clamp(c,0.0,1.0);\n    vec3 scol = vec3(1.0,1.0,1.0);\n    scol = mix(background,scol,c);\n\treturn scol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // debug SVG\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    //return;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\t//vec3 col = doBackground();\n  \tvec3 col = vec3(0.05);\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n\tcol = _Snow(p*0.5,col);\n    \n    fragColor = vec4( col, 1.0 );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "// Sometimes It Snows In April - Del 04/03/2018\n\n// improved version of https://www.shadertoy.com/view/MlVSWc\n// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\n#define N 20.  // splines discretization. Lower it on slow GPUs\n// absolute main SVG commands\n#define M(x,y)             x0 = _x = x;   y0 = _y = y;\n#define L(x,y)             d = min(d, line(uv, vec2(_x,_y), vec2(x,y)) ); _x=x,_y=y;\n#define C(x1,y1,x2,y2,x,y) d = min(d, bezier(uv, vec2(_x,_y), vec2(x1,y1),vec2(x2,y2), vec2(x,y)) ); _x=x,_y=y; \n#define H(x)               d = min(d, line(uv, vec2(_x,_y), vec2(x,_y)) ); _x=x;\n#define V(y)               d = min(d, line(uv, vec2(_x,_y), vec2(_x,y)) ); _y=y;\n#define Z                  d = min(d, line(uv, vec2(_x,_y), vec2(x0,y0)) );\n// relative main SVG commands\n#define m(x,y)             M(_x+x,_y+y)\n#define l(x,y)             L(_x+x,_y+y)\n#define c(x1,y1,x2,y2,x,y) C(_x+x1,_y+y1,_x+x2,_y+y2,_x+x,_y+y)\n#define h(x)               H(_x+x)\n#define v(y)               V(_y+y)\n#define z                  Z\n\n#define style(f,c)         fill=f; S=1.; COL = mod(vec4((c)/65536,(c)/256,c,1),256.)/255.;\n#define path(cmd)          d = 1e38; cmd; draw(d,O);\n\nfloat bezier(vec2,vec2,vec2,vec2,vec2);\nfloat line(vec2,vec2,vec2);\nvoid  draw(float,inout vec4);\nconst float FILL=1., CONTOUR=0.;\nvec4 COL = vec4(0); float fill=FILL, S=1., contrast=1.;  // style state\nfloat d = 1e38;   // global to allow unique distance field\n\nconst float Xoff = 100.0;\nconst float Yoff = -50.0;\n\n// === SVG drawing ===============================================================\nvoid SVG(vec2 uv, inout vec4 O) \n{\n    float _x, _y, x0, y0; // d = 1e38; \n    uv *= 1080.;                             // scaling\n    \n    \n    //float zoom = sin(iTime*2.0)*200.0;\n    //uv *= (zoom+1000.0);\n    \n    contrast = 1.;\n\n    path( style(FILL,0x904030)\n         \n        //M(984.0,557.0)\n        M(283.0+Xoff, Yoff)\n        l(-4.0,-2.0)\n        c(-27.0,37.0,-58.0,66.0,-94.0,85.0)\n        c(-35.0, 20.0, -76.0, 30.0, -121.0, 30.0)\n        l(-137.0,2.0)\n        l(1.0,-145.0)\n        h(38.0)\n        l(24.0, 24.0)\n        v(-121.0)\n        l(-28.0, 29.0)\n        h(-34.0)\n        v(-176.0)\n        l(54.0, 40.0)\n        l(-91.0, -181.0)\n        l(-93.0, 181.0)\n        l(56.0, -40.0)\n        v(176.0)\n        h(-42.0)\n        l(-26.0, -27.0)\n        v(119.0)\n        l(24.0, -24.0)\n        h(44.0)\n        v(145.0)\n        h(-30.0)\n        c(-9.0, -1.0, -34.0, -3.0, -73.0, -6.0)\n        c(-39.0, -4.0, -69.0, -11.0, -88.0, -20.0)\n        c(-43.0, -14.0, -75.0, -30.0, -97.0, -48.0)\n        c(-22.0, -19.0, -33.0, -40.0, -33.0, -64.0)\n        c(0.0, -23.0, 5.0, -41.0, 14.0, -52.0)\n        c(10.0, -11.0, 27.0, -17.0, 51.0, -17.0)\n        c(31.0, 0.0, 45.0, 16.0, 42.0, 49.0)\n        c(-4.0, 9.0, -12.0, 16.0, -24.0, 19.0)\n        c(4.0, -6.0, 6.0, -13.0, 6.0, -20.0)\n        c(0.0, -8.0, -2.0, -15.0, -7.0, -22.0)\n        l(-7.0, -6.0)\n        c(-6.0, -2.0, -12.0, -3.0, -17.0, -3.0)\n        c(0.0, 0.0, -10.0, 1.0, -15.0, 3.0)        //s(-10.0, 1.0, -15.0, 3.0)\n        c(-13.0, 4.0, -19.0, 14.0, -19.0, 31.0)\n        c(0.0, 15.0, 9.0, 27.0, 28.0, 35.0)\n        c(5.0, 2.0, 14.0, 4.0, 25.0, 5.0)\n        c(21.0, 0.0, 39.0, -12.0, 53.0, -36.0)\n        l(4.0, -21.0)\n        c(0.0, -30.0, -23.0, -50.0, -69.0, -60.0)\n        c(-32.0, 0.0, -56.0, 8.0, -73.0, 23.0)\n        c(-8.0,8.0, -25.0, 39.0, -25.0, 71.0)\t\t//s(-25.0, 39.0, -25.0, 71.0)\n        c(0.0, 23.0, 7.0, 44.0, 21.0, 65.0)\n        c(15.0, 20.0, 38.0, 40.0, 70.0, 59.0)\n        c(48.0, 34.0, 115.0, 57.0, 201.0, 69.0)\n        c(-60.0, 37.0, -90.0, 89.0, -90.0, 154.0)\n        c(0.0, 37.0, 11.0, 73.0, 33.0, 106.0)\n        l(2.0, 3.0)\n        l(4.0, 5.0)\n        c(37.0, 49.0, 86.0, 73.0, 147.0, 73.0)\n        c(50.0, 0.0, 93.0, -18.0, 131.0, -55.0)\n        c(36.0, -36.0, 55.0, -79.0, 55.0, -130.0)\n        c(0.0, -64.0, -26.0, -115.0, -78.0, -153.0)\n        c(59.0, 0.0, 113.0, 9.0, 159.0, 28.0)\n        c(48.0, 19.0, 87.0, 46.0, 118.0, 81.0)\n        l(-14.0, -47.0)\n        c(-10.0, -34.0, -15.0, -67.0, -15.0, -99.0)\n        c(0.0, -52.0, 13.0, -97.0, 39.0, -135.0)\n        z\n        // these c->s conversions are screwy for the circle...\n        M(Xoff, Yoff+324.0)\n        c(0.0, 30.0, -11.0, 56.0, -33.0, 78.0)\n        c(0.0,3.0, -48.0, 33.0, -79.0, 33.0)\t\t//s(-48.0, 33.0, -79.0, 33.0)\n        c(-36.0, 0.0, -64.0, -13.0, -83.0, -38.0)\n        l(-6.0, -8.0)\n        c(-15.0, -20.0, -22.0, -41.0, -22.0, -64.0)\n        c(0.0, -16.0, 2.0, -30.0, 7.0, -42.0)\n        c(0.0,0.0, 13.0, -24.0, 25.0, -37.0)\t\t\t        //s(13.0, -24.0, 25.0, -37.0)\n        c(22.0, -22.0, 48.0, -33.0, 79.0, -33.0)\n        c(22.0,0.0, 58.0, 11.0, 79.0, 32.0)\t\t\t\t\t//s(58.0, 11.0, 79.0, 32.0)\n        c(22.0, 22.0, 33.0, 48.0, 33.0, 79.0)\n        z\n    )\n}\n\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t)\n{\n    vec2 A = G4-G1 + 3.*(G2-G3),\n         B = 3.*(G1-2.*G2+G3),\n         C = 3.*(G2-G1),\n         D = G1;\n    return t * (t * (t * A + B) + C) + D;\n}\n\n\nfloat line(vec2 p, vec2 a, vec2 b) \n{\n\tvec2 pa = p - a, ba = b - a,\n\t     d = pa - ba * clamp(dot(pa, ba) / dot(ba, ba) , 0., 1.); // distance to segment\n    if  ( (a.y>p.y) != (b.y>p.y) &&\n           pa.x < ba.x * pa.y / ba.y ) S = -S;     // track interior vs exterior\n\treturn dot(d,d); //length(d);                  // optimization by deferring sqrt\n}\n// interior detection (sign S): ( thanks TimoKinnunen https://www.shadertoy.com/view/4lySWd )\n// see http://web.archive.org/web/20161116163747/https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html - previously on https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\nfloat bezier( vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D)    \n{\n    //float d = 1e5;                               // for global field\n    vec2 p = A;\n    for (float t = 1.; t <= N; t++) {\n        vec2 q = interpolate(A, B, C, D, t/N);\n        float l = line(uv, p, q);\n        d = min(d, l );\n\t\tp = q;\n\t}\n\treturn d;\n}\n\nvoid draw(float d, inout vec4 O) \n{\n    //if (iMouse.w>0.5)\n    //{\n        // distance field...\n        if (S>0.0)\n        {\n            d = sqrt(d);\n            d+=1.0;\n            d*=0.01;\n            O = vec4(0.5+(d*S));\n        }\n        return;\n    //}\n    //d = min(sqrt(d)*contrast*2.,1.);             // optimization by deferring sqrt here\n    //O = mix(COL, O, fill>0. ? .5+.5*S*d : d);    // paint \n    \n}\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    \n    vec2 R = iResolution.xy;\n    \n    //if (iFrame>0)\n    if ( texture(iChannel0,.5/R).xy == R )     // init or rescale\n    {     // init or rescale\n        O = texture(iChannel0, U/R);\n        return;\n    }\n    if (U==vec2(.5)) { O = vec4(R,1.0,1.0); return; }\n    \n    \n    \n    //if (iFrame>0)\n    //{\n    //    O = texture(iChannel0, U/iResolution.xy);\n    //    return;\n    //}\n    \n    O = vec4(0);\n\tU = ( U -.5*iResolution.xy ) / iResolution.y;\n    \n    //float scale = 0.5+sin(iTime)*0.5;\n    //scale += 1.0;\n    //U *= scale;\n\tSVG( U, O );\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}