{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4tSyRz",
      "date": "1507105595",
      "viewed": 430,
      "name": "Fly quaternion city",
      "username": "ollj",
      "description": "quaternion Mouselook! (pitch yaw)\nArrow.Up-Down=accelerate\nArrow Left-Right=roll\n\nfork of\nhttps://www.shadertoy.com/view/lsd3Dl",
      "likes": 2,
      "published": 3,
      "flags": 112,
      "tags": [
        "fractal",
        "collision",
        "quaternion",
        "airplane",
        "roll",
        "controls",
        "yaw",
        "pitch",
        "cloudsdale",
        "edynvr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 33,
            "src": "/presets/tex00.jpg",
            "ctype": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 33,
            "src": "/presets/tex00.jpg",
            "ctype": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 12119,
            "src": "https://soundcloud.com/hnhagendahbrony/cloudsdale-impro",
            "ctype": "musicstream",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 0
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "/*\nself  : https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n\n\n//cut off half of the distance field along a plane that that the .y axis as its normal.\n#define cutY\n\n//epsilon  is a break condition for sphere tracking.\n//fractals need smaller eps, IEEE floats lose too much precision below .0000001\n//smaller eps result in slower fps and more convave areas.\n#define eps .00001\n//max number of raymarch spheretracking iterations, max number of gradient descents.\n#define iterRm 256\n\n\n//max view distance, far clipping sphere, centred around camera\n#define zFar 80.\n//to veil the horizon or not to veil the horizon, that is the asymptote.\n#define doFog\n\n//do shading. do calculus operations, sample derivatives of the gradient.\n#define doShade\n\n//ao on fractals is often odd, it can make things brighter.\n#define doAO\n\n//do specular light, fake reflectio of sunlight\n#define doSpec\n\n//max.iter fractal shapes, parent setting is 4. 5. is a bit \"brighter\"\n#define iterDfFractal 4.\n\n\n//does not have dynamiceps\n\n//does not have any code for reflections.\n\n\n//fractals need more iterShadAO at screenspace-edges (edge detecion)\n//, where normals are not pointing towards camera\n//Max.sample soft shadow \n#define iterAO 8.\n\n//now with autopilot, thanks Fabrice!\n//#define USE_AUTO_PILOT \n//looks like i broke it\n\n#define THRUST 0.02*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define sat(a) clamp(a,.0,1.)\n\n//load and save, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n\n//quaterion math\nvec4 qid(){return vec4(0.0,0.0,0.0,1.0);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//rotate pitch,yaw,roll in that order:\nvec4 qpyr(vec3 o){o*=0.5;vec3 s=sin(o),c=cos(o)\n;return vec4(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\n/*\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nvec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\nvec4 qslerp(vec4 q1, vec4 q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*/\n\n//hash\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n//quaterion math, just to be different\n\n//shape:\nvec3 Tile(vec3 p){vec3 a=vec3(8.0);return abs(mod(p,a)-a*0.5)-a*0.25;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n//colors\nconst vec3 sunDir=normalize(vec3(0.7,1.0,-0.7))\n,sunColor=vec3(1.0,0.99,.9)\n,skyColor=vec3(.25,.26,.27)\n//rainbow tinted cosmic microwave background, makes nice fog.\n;vec3 Backdrop(in vec3 rd){vec3 a= \n+skyColor\n+.05*(rd+sin(rd.yzx*5.+2.4*sin(rd.zxy*3.0)))\n+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.));\n;return .7*a;}\n\n//return signed distane of[p] to a surface.\nfloat gd(vec3 u)//gradient differential, signed distance field:\n{vec3 p=Tile(u)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;for(float n=.0;n<iterDfFractal;n++ //fractal\n){z.xyz=clamp(z.xyz,-1.,1.)*2.-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==2.)dG=DERect(z,rcL);\n}\n;dG=min(dG,DERect(z,rc))\n#ifdef cutY\n;dG=max(dG,u.y);\n#endif\n;return dG;\n    ;}\n\n\n//a variant of gd(), that is HERE used to get a color and tto derive a surface normal.\n//the inout vec4 mcol is a big difference.\nfloat gd1(vec3 p,inout vec4 mcol)\n{p=Tile(p)\n;vec4 z=vec4(p,1)\n;float dG=1e3\n;vec4 mc=vec4(0)\n;for (float n=.0;n<5.;n++ //palette of 5 colors, i sync to abive fractal shape\n){z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz\n ;z*=scale/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr)\n ;z+=p0\n ;if(n==3.)mc=vec4(vec3(.5,.3,.2)+z.xyz*.05,.25)\n ;else if(n==2.)dG=DERect(z,rcL);\n}float ds=DERect(z,rc)\n;if(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0)\n;else mcol+=mc\n;return min(dG,ds);}\n\nvec3 fog(float ts,vec3 spc,vec3 fcol){\n//;float fog=min(pow(ts*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n;float fog=min(pow(ts*20./zFar*.2,1.33)*.54,1.)//optimizd for zzFar=20.\n//must be reciprocal log() ?\n;return mix(spc,fcol,fog);\n}\n\nfloat AO(in vec3 o,in vec3 d,float s){//origin, direction, scatterHash\n;float t=.0,a=1.,f,n=.01+.04*s\n;for(float i=.0;i<iterAO;i++ \n){f=max(gd(o+d*t)*1.5,n)\n ;a=min(a,f/t+t*0.5)\n ;t+=f;\n}return a;}//soft shadow with \"noisy lens\".\n\n\n//return occluded specular.\nvec3 SpecOcc(vec3 r,vec3 d,vec3 N,vec3 so,vec3 o,float s,vec4 mcol){\n;float l=dot(N,sunDir)//sundir must be normalized\n#ifdef doAO\n,shad=AO(so+N*.001,sunDir,s)//shadow\n#else\n,shad=.5\n#endif\n#ifdef doSpec\n;float v=dot(-d,N)\n;vec3 cc=vec3(.6,.8,1)//diffused light. sky color, shorter wavelengths diffuse more\n,lc=vec3(1,.8,.6)     //undiffused light, direct sun color, long wavelengths\n;float cd=exp(-distance(o,so))\n;vec3 R=reflect(d,N)\n;float spcl=pow(sat(dot(R,sunDir)),10.)\n,spcc=pow(max(.0,dot(R,-d)),1.+cd)*.25\n;r=r*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a\n#endif\n;r=sat(r)\n;return r;}\n\n/*\n[o]RayOrigin\n[d]RayDirection\n[s]ScatterNoise\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n[ao]Accumulate Occlusion, may just buffer the last step length\n[ps]PushSmallest; ps=(g<f*t &&g <ao && ts.w<.0);\n[ts]TimeSmallest    ,init: ts=vec4(-1 ), if(ps)store the 4 smallest [t>0] (abridged)\n[gs]gradientSmallest,init: gs=vec4(1e6), if(ps)store the 4 smallest abs(g)\n*/\nvec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering\n;float g=gd(o)*s*.5\n,t=g,ao=1.\n,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.\n;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 \"smallest values\"\n ;for(int i=0;i<iterRm;i++\n ){//start.raymarch\n ;g=gd(o+d*t)\n ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))\n       //=(g<min(f*t,ao)&&ts.w<.0);\n       //=(g<f*t&&g<ao&&ts.w<.0);\n ;if(ps //PushSmall, we remember 4*2 smallest values for AO.\n ){gs=vec4(abs(g),gs.xyz)\n  ;ts=vec4(t,ts.xyz);\n ;}\n ;t+=g\n ;ao=g\n ;if(t>zFar||g<eps)break;//raymarch loop break\n ;}//end__.raymarch loop \n ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall\n ;vec3 c=Backdrop(d)\n     //;return c;\n ;vec3 fcol=c\n ;for(int i=0;i<4;i++ //some AA supersampling shit in here?\n ){//ts and ps values get processed for \"occlusion\"\n  //oh looks like this is just nearSurface() surface stuff.      \n  ;if(ts.x<.0)break\n  ;float px=f*ts.x\n  ;vec3 so=o+d*ts.x\n  ;vec4 mcol=vec4(.0)\n  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))\n  ;vec3 ve=vec3(px,0,0)\n  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal\n  ;float d1=gd1(so,mcol)\n  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.\n  //above begs to be inversesqrt?\n  ;vec3 spc=mcol.rgb*0.14//specular set to material\n  #ifdef doShade\n  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)\n  #endif\n        //near distance can skip fog.\n  #ifdef doFog\n  ;spc=fog(ts.x,spc,fcol);\n  #else \n  //;spc=fog(ts.x,spc,fcol);\n  #endif  \n  ;c=mix(spc,c,sat(gs.x/px))\n  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix\n ;}\n//;if(c!=c)c=vec3(1,0,0);//if(NaN)\n;return sat(c*2.)\n;}\n\n\nvec4 mainImage2(out vec4 fragColor, in vec2 fragCoord){\n vec3 t=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n vec3 o=load(0).xyz;\n vec4 fw=(load(1));\n t=qmulv(fw,t);\n //ro=eye;rd=normalize(dir);\n float s=h12(fragCoord);\n return vec4(scene(o,t,s),1.0);\n}\n\n\nvoid steer( out vec4 o, in vec2 u ){\n    ;vec4 p,qrot\n;if(iFrame<2){//init\n ;p=vec4(.1,0,0,.01)\n ;qrot=normalize(vec4(.1,.2,.3,.8));\n}else{//next frame\n ;p=load(0);qrot=load(1)//load state from previous frame\n ;vec3 fw=vec3(0,0,1)\n ;fw=qmulv(qrot,fw) //this can be done simpler\n ;vec3 newp=p.xyz+fw*p.w*.2\n ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n ;else\n  {if(gd(vec3(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n  ;if(gd(vec3(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n  ;if(gd(vec3(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n }\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0)\n ;if(iMouse.z>.0\n ){\n  ;vec2 n=iMouse.xy-iMouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy\n ;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;newp=qmulv(qrot,vec3(d,0,0))\n  ;float d2=gd(p.xyz+newp)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d)\n ;}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;qrot=normalize(qmulq(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,velocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out vec4 o,vec2 u){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u); \n}\n",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}