{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ltByWc",
      "date": "1510324190",
      "viewed": 256,
      "name": "Tiled Gabor noise",
      "username": "VinceTavernier",
      "description": "Implementation of http://graphics.cs.kuleuven.be/publications/LLDD09PNSGC/. Tiled along x and y coordinates.",
      "likes": 4,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "noise",
        "tiled",
        "gabor",
        "stochastic"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "#define M_PI 3.141592653589793\n// Size of cells. Use a factor of iResolution.y\n// 360: 2^3 * 3^2 * 5\n// 450: 2   * 3^2 * 5^2\n#define TILE_SIZE 30.\n// Number of cells\n#define TILE_COUNT int(iResolution.y/TILE_SIZE)\n// Number of splats per cell\n#define SPLATS 6\n\n// Kernel settings\n// Note that a is 1/TILE_SIZE (cf. main loop)\n#define mouseAngle ((.125+iMouse.y/iResolution.y)*2.*M_PI)\n#define w0 vec2(cos(mouseAngle),sin(mouseAngle))\n#define f0 (iMouse.x<10.?sqrt(2.):(iMouse.x/iResolution.x*5.))\n\n// PRNG used in the paper\nstruct noise_prng\n{\n    uint x_;\n};\n    \nvoid noise_prng_srand(inout noise_prng this_, in uint s)\n{\n    this_.x_ = s;\n}\n\nuint noise_prng_rand(inout noise_prng this_)\n{\n    return this_.x_ *= 3039177861u;\n}\n\nfloat noise_prng_uniform_0_1(inout noise_prng this_)\n{\n    return float(noise_prng_rand(this_)) / float(4294967295u);\n}\n\nvec2 noise_prng_rand2_1_1(inout noise_prng this_)\n{\n    return -1.+2.*vec2(noise_prng_uniform_0_1(this_),\n                       noise_prng_uniform_0_1(this_));\n}\n\n// Kernel used in the paper\nfloat h(vec2 x) {\n    float r = length(x);\n    // Anisotropic\n    return exp(-M_PI*r*r)*cos(2.*M_PI*f0*dot(x, w0));\n    // Isotropic\n    //return exp(-M_PI*r*r)*cos(2.*M_PI*f0*r);\n}\n\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    noise_prng prng;\n\n    //U = fract(2.*U/iResolution.y)*iResolution.y; // uncomment to check tiling\n    // Find out the cell coordinates\n\tivec2 ccell = ivec2(U/TILE_SIZE);\n\n    O -= O;\n\n    // Loop over adjacent cells\n    ivec2 disp;\n    int dispSize = 1;\n    for (disp.x = -dispSize; disp.x <= dispSize; disp.x++)\n    {\n        for (disp.y = -dispSize; disp.y <= dispSize; disp.y++)\n        {\n            // The current cell being considered\n            ivec2 cell = ccell + disp;\n            // The cell number used to seed the PRNG (note: float mod works for negative numbers)\n            ivec2 nc = ivec2(mod(vec2(cell), float(TILE_COUNT)));\n            // Center of this cell in pixels\n            vec2 center = TILE_SIZE*(vec2(cell) + .5);\n            // Seed the random generator for the current cell\n            uint seed = uint(nc.x*TILE_COUNT+nc.y+1);\n            noise_prng_srand(prng, seed);\n            for (uint k = 0u; k < seed % 3u; ++k)\n\t\t\t\tnoise_prng_rand(prng);\n            // Loop over splats\n            for (int i = 0; i < SPLATS; i++)\n            {\n                // The location of this splat\n                vec2 loc = center + TILE_SIZE/2. * noise_prng_rand2_1_1(prng);\n                // The weight of this splat, [-1, 1]\n                float w = 2.*noise_prng_uniform_0_1(prng)-1.;\n                // Converges faster:\n                //w = sign(w);\n\n                // Distance to this splat\n                vec2 x = (U - loc)/TILE_SIZE;\n                O += w * h(x);\n            }\n            // uncomment to see grid coordinates\n            //if (disp.x == 0 && disp.y == 0) O *= float(SPLATS) * vec4(nc,0.,1.)/TILE_COUNT;\n        }\n    }\n\n    // Normalize by variance and map to [0, 1]\n    O = .5*O/(2.*sqrt(float(SPLATS)*.25*exp(-2.*M_PI*f0*f0/(TILE_SIZE*TILE_SIZE))))+.5;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}