{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ldjyRK",
      "date": "1492899420",
      "viewed": 240,
      "name": "Hammer projection",
      "username": "ollj",
      "description": "mouse moves stuff\nimagine the texture is a planets world map and clicking it moves your view on it \nbased om\nhttps://www.shadertoy.com/view/ldSXRm\nhttp://en.wikipedia.org/wiki/Hammer_projection",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "hammer",
        "mercator",
        "cartesian"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 8,
            "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//https://www.shadertoy.com/view/ldSXRm\n//made simpler\n//minus video\n\n\n//considder iChannel1 is a world map where [positionA.xy]/resolution\n//is on the opposite side on the globe of [fract(positionA.xy+vec2(.5,.5))]/resolution\n//this shader renders that globe in Hammer Projection.\n//https://en.wikipedia.org/wiki/Hammer_projection\n\n//my plan is to make a collection of projections that work nicely with large fov.\n\n//most of the common  projections are sphereTo2d map projections, \n//due to navigating globes. To utilize those projections, \n//for first person perspectives with 360\u00b0 field of fiew,\n//we map fragmentPos.xy to a latitudeLongitudePair, using scale() [(or the inverse scale1())\n//and feed that pair (with an offset) to the (inverse of) the sphereTo2d projection \n//and then map a chekerboard on it to visualize the used projection.\n//\n//offset can be set by left mouse button.\n\n//todo, make transformation insistinguishable from inverse by enforcing a type\n//for latitudelongitudePair\nstruct geog{vec2 g;}Mgeog;//.x=longitude | .y=latitude (because latitude sets \"north|south\")\n\n//field of view range [0..1] <-> [0..360]\u00b0\n#define fov 1.\n\nconst float tau=acos(-1.)*2.;\nconst float pi=acos(-1.);\nconst float pi2=acos(0.);\nconst float pi4=acos(0.)*.5;\nconst float s2=sqrt(2.);\n\n//vec2 sc(float a){return sin(vec2(a,a+pi2));}//or was it ,minus?\nvec2 sc(float a){return vec2(sin(a),cos(a));}\n\n//Hammer.transform:\nvec2 tHammer(vec2 p){\n vec2 s=sc(p.y),o=sc(p.y*.5);\n return s2*vec2(2.*s.y*o.x,s.x)/sqrt(1.+s.y*o.y);}\n//Hammer.transform.Inverse\nvec2 tHammer1(vec2 p){float z=1.-(p.x*p.x/16.)-(p.y*p.y/4.);\n if(z<0.)discard;float s=sqrt(z);\n return vec2(2.*atan((s*p.x),(2.*(2.*z-1.))),asin(s*p.y));}\n\n//scale: (-0.5.-0.5) x (0.5..0.5) -> (l[0]..l[1]) x (l[2]..l[3])\nvec2 scale(vec2 p, vec4 l){\n return (p+vec2(.5))*vec2(l[1]-l[0],l[3]-l[2])+vec2(l[0],l[2]);}\n//scale.inverse p=scale1(scale_forward(p));\nvec2 scale1(vec2 p, vec4 l){\n return (p-vec2(l[0],l[2]))/vec2(l[1]-l[0], l[3]-l[2])-vec2(.5);}\n\nfloat CheckerFloor(vec2 p){p=floor(p*2.);\n return mod(p.x+p.y,2.);}\n//float grid=\n\nvec2 r90(vec2 a){return vec2(a.y,-a.x);}\n\nvoid mainImage( out vec4 Out, in vec2 fragCoord ){Out=vec4(0.);//linux likes this\n vec2 u=fragCoord.xy/iResolution.xy-.5;\n u*=sqrt(2.);\n u*=fov;\n //u.x*=iResolution.y/iResolution.x;\n vec4 CarLim=vec4(-2,2,-1,1)*1.0;//carthesian limits\n vec2 P1=scale(u,CarLim);\n vec2 P2=tHammer1(P1);\n\n //a dynamic [t] is residue from https://www.shadertoy.com/view/ldSXRm\n float t=iTime;\n float t1=.5*(1.+cos(t   ));\n float t2=.5*(1.+cos(t*.5));\n //Test if we are within limits but we do not discard yet because we want\n //to draw border. Discarding would mean half of the exterior not drawn.\n //below code is just deminstrating inverse function usage, by \n //... \"cutting window out of a globe\" within the used projection\n //the window position|size changes over time:\n //dynamic t are more confusing than useful.\n //dynamic t would map parts of a globe in a projection, not too common.\n //for simplicity all [t] is made static here:                                               \n t1=0.;\n t2=0.;\n\n //[l] cuts out a region from lat_lon till lat_lon \n //that then is just not part of the our projection (to skip fragments)\n vec4 l=vec4(-pi,pi*(1.-t1),pi2*(t1/2.-1.),+pi2*(1.-t2/2.));\n l*=fov;\n \n //debug overwrite shows a half-globe of the projection:\n //l=vec4(-2.,2.,-1.,1.);\n \n //[outside.xy] tells if a LatitudeSongitude.xy \n //is within the rectangular_area_on_a_globe.xy that we want to project.\n bvec2 outside=bvec2(false);\n #define poa(a,b) if(P2[a]<l[b])outside[a]=true;\n #define pob(a,b) if(P2[a]>l[b])outside[a]=true;\n poa(0,0);pob(0,1);poa(1,2);pob(1,3);\n                                                  \n //project texture and grid:\n vec3 red =vec3(1,0,0);\n vec3 blue=vec3(0,0,1);\n vec2 r=scale1(P2,l);r=r90(r);\n r*=fov;\n //r.y-=iTime*.01;//rotate\n r.y+=iMouse.x/iResolution.x;\n r.x-=iMouse.y/iResolution.y;\n float g      =CheckerFloor(r*32.);//smaller squares are fullRotation/64  wide\n //there are 64*64 small squares;\n float checker=CheckerFloor(r*pi); //larger  squares are fullRotation/tau wide\n //projecting a map is free:\n if(!any(outside)){//latitudeLongitudePair is within the area we want to map\n  Out=texture(iChannel0,r+.5);//prject iChannel0\n  Out+=.05*vec4(mix(red,blue,checker)+vec3(0,g,g),1.);//project grid\n }else{//latitudeLongitudePair is outside of what we want to map\n  Out=vec4(0.);\n }\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}