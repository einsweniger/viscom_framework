{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4dBcRD",
      "date": "1491041647",
      "viewed": 2917,
      "name": "Water waves drag",
      "username": "afl_ext",
      "description": "This shader demonstrates how each water octave can bend sufrace UVs to emulate very appealing effect! Also its darn fast",
      "likes": 33,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "waves",
        "water",
        "drag"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//afl_ext 2017 \n\nvec2 wavedx(vec2 uv, vec2 emitter, float speed, float phase, float timeshift){\n    float x = distance(uv, emitter) * phase - timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, dx);\n}\n\n#define DRAG_MULT 0.048\n\nvec3 optimizedWaveSources[32] = vec3[](\n    vec3(-726.0, 789.0, -672.0),\n    vec3(-564.0, -673.0, -351.0),\n    vec3(-83.0, -3.0, 631.0),\n    vec3(-775.0, -361.0, 755.0),\n    vec3(-446.0, -134.0, -390.0),\n    vec3(-219.0, -365.0, -135.0),\n    vec3(-390.0, -316.0, -62.0),\n    vec3(-78.0, -344.0, -678.0),\n    vec3(515.0, 745.0, -173.0),\n    vec3(-202.0, 752.0, -36.0),\n    vec3(238.0, -775.0, -48.0),\n    vec3(366.0, -538.0, 80.0),\n    vec3(-786.0, 180.0, -724.0),\n    vec3(645.0, 205.0, -284.0),\n    vec3(599.0, 559.0, 383.0),\n    vec3(-592.0, -460.0, -783.0),\n    vec3(74.0, -50.0, -298.0),\n    vec3(-788.0, 673.0, 159.0),\n    vec3(-666.0, 387.0, 103.0),\n    vec3(-39.0, -616.0, 55.0),\n    vec3(726.0, 422.0, 81.0),\n    vec3(-123.0, -12.0, 343.0),\n    vec3(757.0, 2.0, -278.0),\n    vec3(-767.0, -153.0, 728.0),\n    vec3(-250.0, -355.0, 486.0),\n    vec3(-668.0, -146.0, -774.0),\n    vec3(-650.0, 729.0, -23.0),\n    vec3(-148.0, 742.0, -151.0),\n    vec3(-789.0, -725.0, -565.0),\n    vec3(115.0, 37.0, -380.0),\n    vec3(-631.0, -38.0, -758.0),\n    vec3(250.0, 640.0, 30.0)\n    );\n\nfloat getwaves(vec2 position){\n    position *= 0.1;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<16;i++){\n        vec2 p = normalize(vec2(optimizedWaveSources[i])) * 2000.0;\n        vec2 res = wavedx(position, p, speed, phase, iTime);\n        position -= normalize(position - p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.2;\n        speed *= 1.02;\n    }\n    return w / ws;\n}\nfloat getwavesHI(vec2 position){\n    position *= 0.1;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<32;i++){\n        vec2 p = normalize(vec2(optimizedWaveSources[i])) * 2000.0;\n        vec2 res = wavedx(position, p, speed, phase, iTime);\n        position -= normalize(position - p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.2;\n        speed *= 1.02;\n    }\n    return w / ws;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwavesHI(pos.xy) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwavesHI(pos.xy - ex.xy) * depth, pos.y)), \n                           normalize(a-vec3(pos.x, getwavesHI(pos.xy + ex.yx) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0)* vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    if(iResolution.x < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), mouse.x * 2.0 - 1.0) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat rand2sTimex(vec2 co){\n    return fract(sin(dot(co.xy * iTime,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz) * depth - depth;\n        if(h + 0.01 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nvec2 rsi2(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    return vec2(min(ex.x, ex.y), max(ex.x, ex.y));\n}\n\nvec3 scatter(vec3 light, float dist, vec3 absorbColor){\n\t   return max(vec3(0.0), light - dist * absorbColor * 0.51);\n}\n\nvec3 renderAtmospherePath(vec3 start, vec3 end){\n    //vec3 noonColor = (1.0 - pass.body.atmosphereAbsorbColor) * ClosestStarColor * 0.02;\n    //vec3 sunsetColor = (pass.body.atmosphereAbsorbColor) * ClosestStarColor \n    float coverage = 0.0;\n    vec3 alphacolor = vec3(0.0);\n    vec3 color = vec3(0.0);\n    float stepsize = 1.0 / 10.0;\n    vec2 UV = vec2(0.0);\n \tvec3 sd = normalize(vec3(1.0, 1.0, 1.0));  \n    float iter = 0.0;// + stepsize * fract(oct(UV * 100.0) + Time * 0.01);\n    float radius = 6170.0;\n    float atmoheight = 100.0;\n    vec3 starDir = sd;\n    vec3 direction = normalize(end - start);\n    float dt2 = dot(direction, starDir);\n    float rayStarDt = dot(starDir, direction);\n    float mieCoeff = exp(-3.1415 * 5.0 * (-rayStarDt * 0.5 + 0.5));\n    float rayleightCoeff =  exp(-0.1415 * (-rayStarDt * 0.5 + 0.5));//(1.0 / (1.0 + 12.1 * (  1.0 - (rayStarDt ))));\n    float distmultiplier = distance(start, end) * 0.01;\n    float dimmer = 1.0 / (1.0 + 10.0*distmultiplier);\n    float shadowAccumulator = 0.0;\n\n    vec3 normal = normalize(start);\n    float dt = 1.0 - (1.0 / (1.0 + 3.0 * max(0.0, dot(normal, starDir))));\n    shadowAccumulator = dt;\n    \n    vec3 atmosphereAbsorbColor = vec3(0.1, 0.3, 0.7);\n\n    vec3 rayEnergy = vec3(1000.0);\n    for(int i=0;i<10;i++){\n        vec3 pos = mix(start, end, iter);\n        float cdst = distance(pos, vec3(0.0)) - radius;\n        float heightmix = 1.0 - cdst / atmoheight;\n        vec3 rayleightScatteredLight = heightmix * atmosphereAbsorbColor * rayEnergy * rayleightCoeff * distmultiplier * 1225.1 * stepsize;\n        vec3 mieScatteredLight       = heightmix * atmosphereAbsorbColor * rayEnergy * mieCoeff       * distmultiplier * 525.1 * stepsize;\n\n        //rayEnergy -= rayleightScatteredLight;\n       // rayEnergy -= mieScatteredLight;\n\n        //rayEnergy = max(vec3(0.0), rayEnergy);\n        \n    \tvec3 endSecondary = pos + starDir * rsi2(Ray(pos, starDir), Sphere(vec3(0.0), 6270.0)).x;\n        vec3 primaryColor = scatter(rayEnergy, distance(endSecondary, pos), atmosphereAbsorbColor);\n        vec3 secondaryColor = scatter(primaryColor, distance(start, pos), atmosphereAbsorbColor);\n\n        color += secondaryColor;//(mieScatteredLight + rayleightScatteredLight) * (1.0 - coverage) * shadowAccumulator * distmultiplier;\n        iter += stepsize;\n    }\n    color *= stepsize * dimmer;\n    return color * 0.1;\n}\nvec3 getatm(vec3 ray){\n    vec3 start = vec3(0.0, 1.0, 0.0) * 6170.0;\n    vec3 end = start + ray * rsi2(Ray(start, ray), Sphere(vec3(0.0), 6270.0)).x;\n \treturn renderAtmospherePath(start, end);\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0, 1.0, 1.0));   \n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n}\n\nvec3 getColor(vec2 uv){\n    \n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tvec3 ray = getRay(uv);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\n        //tonemapping\n        C = normalize(C) * sqrt(length(C));\n     \treturn C; \n    }\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.01, waterdepth);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R); \n    //tonemapping\n    C = normalize(C) * sqrt(length(C));\n    \n\treturn C;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec3 ray = getRay(uv);\n    vec3 C = vec3(0.0);\n \tvec2 dfx = 1.0 / iResolution.xy;\n    vec2 supersampler = dfx;\n    vec2 diff = uv;\n    float W = 0.0;\n    for(int i=0;i<3;i++){\n        C += getColor(uv + vec2(rand2sTimex(diff), rand2sTimex(diff + 100.0)) * supersampler);   \n        diff += 200.0;\n        W += 1.0;\n    }\n    C /= W;\n\tfragColor = vec4(C,1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}