{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "MdjcD3",
      "date": "1494214180",
      "viewed": 203,
      "name": "006b Derivative Arithmetic 2",
      "username": "ollj",
      "description": "still incomplete and untested...\n\nmy take on \"optimizing\" automatic differentiation.\nusing float arrays instead of vectors.\nbecause paniq keeps derivatives for vec3, but i want to keep one for less dimensions, too.",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "derivative",
        "dual",
        "paniq",
        "arithmetic",
        "continuous",
        "automatic",
        "differential",
        "derivate",
        "goursat",
        "continuity"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//self  = https://www.shadertoy.com/view/MdjcD3\n//parent= https://www.shadertoy.com/view/XlV3Dy\n\n/*\nmouse does stuff.\ncleaned and starting to undertand how to use:\nsubstraction of distances is in line 235 ish\n, mixing 2 shapes by sin(time)*.5+.5\n*/\n\n/*\narithmetic set for automatic differentiation, \nderivative arithmetic [DA] for\nhttps://en.wikipedia.org/wiki/Smoothness\nof shapes that (otherwise) lack C1-continuity.\nbased on    : https://www.shadertoy.com/view/4dVGzw\ninspired by : https://www.shadertoy.com/view/Mdl3Ws \nexplained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\nwiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\nsummary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n*/\n\n#define dimensions 3\n\n#define IterRm 64\n//max raymarch iterations|steps\n\n#define IterSh 24\n//softshadow iterations\n\n#define StepFactor .99\n//stepfactor range [.1 to 2.], where larger values tend to overstep.\n//if(lipschitzConstant>1., distance is overestimated.\n//... lazy fix for that is scaling stepDistance*=StepFactor\n//I noticed better quality with a smaller stepfactor AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define Goursat\n//toggle between 2 distance fields|surfaces:\n//Goursat-surface (non-C1 continuous)\n//or\n//\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[j] stays \"underived\"\n//[i] calculates the gradient as byproduct\n//[i] becomes Operation(i,FirstDerivateOf(Operation(i,j))\n//[i] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//\"pseudo\" dual because [i] has 3 dimensions, and [j] has 1 dimension that modifies on all dimensions of [i], \n//because graphic cards are good with domain operators on vectors.\n//we define your dual number (where one part calculates with derivative of the other part and itself)\n//as type vec4(vec3,float)\n//and the 3 dimensions|domains are resolved with [struct DAVec3{}] and [da_domain()]:\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(1.,0.,0.,p.x),\n vec4(0.,1.,0.,p.y),\n vec4(0.,0.,1.,p.z));}\n//this lets you derive over 3 dimensions at once OR seperately, using very self-similar dual-function variants:\n//#define dacon(a) vec4(0.,0.,0.,a)\n#define i1 in float\n#define i4 in vec4\n#define i3 in vec3\n\n//automatic differenciation of paniq \n//transformed to float array form, wher paniq .w == array index #0.\n#define a1 float[1]\n#define a2 float[2]\n#define a3 float[3]\n#define a4 float[4]\n//explicit vector proessing for array operands, because opengl is not C#\n//return array fith entry #0 removed from it.\na3 a2m(a4 a){return a3(a[1],a[2],a[3]);}\na2 a2m(a3 a){return a2(a[1],a[2]);}\na1 a2m(a2 a){return a1(a[1]);}\nfloat a2v(a1 a){return a[0];}vec4 a2v(a4 a){return vec4(a[0],a[1],a[2],a[3]);}\nvec2 a2v(a2 a){return vec2(a[0],a[1]);}vec3 a2v(a3 a){return vec3(a[0],a[1],a[2]);}\n#define a2n(a) a2v(a2m(a))\na1 v2a(float a){return a1(a);}a4 v2a(vec4 a){return a4(a.x,a.y,a.z,a.w);}\na2 v2a(vec2 a){return a2(a.x,a.y);}a3 v2a(vec3 a){return a3(a.x,a.y,a.z);}\n#define a2ie return v2a(-a2v(a));} \na1 a2i(a1 a){a2ie a2 a2i(a2 a){a2ie a3 a2i(a3 a){a2ie a4 a2i(a4 a){a2ie\n//I hope this tortures a parser as much as possible.\n/* //shorthand idea is on ice:\n#define adda(z) z add(z a,a1 b){return v2a(a2v(a)+b[0]);}\nadda(a1)adda(a2)adda(a3)adda(a4)\n#define mula(z) z mul(z a,a1 b){return v2a(a2v(a)*b[0]);}\nmula(a1)mula(a2)mula(a3)mula(a4)\n*/\n//this is NOT safeinv(), because safeinv is a recoprocal\n//and i may have confused this a bit too often\nfloat dac1(float z){return z;}\nvec2 dac2(float z){return vec2(z,0.);}\nvec3 dac3(float z){return vec3(z,0.,0.);}\nvec4 dac4(float z){return vec4(z,vec3(0));}\n//paniqs da uas .x as 0th derivative and all else as 1st derivative.\n//but keep #0 as 0th derivative and all else as 1st derivative.\n//for my array version that hopefully is more dynamic.\n#define dasi2 sin(a[0]),a2n(a)*cos(a[0])));}\n#define dasin(w) w da_sin(w a){return v2a\ndasin(a4)(vec4(dasi2 dasin(a3)(vec3(dasi2 dasin(a2)(vec2(dasi2\n#define daco2 cos(a[0]),-a2n(a)*sin(a[0])));}\n#define dacos(w) w da_cos(w a){return v2a\ndacos(a4)(vec4(daco2 dacos(a3)(vec3(daco2 dacos(a2)(vec2(daco2\n//as proof of concept, remember the derivates of sin|cos:\n//sin => cos => -sin => -cos => sin =>...\n//vec4 da_sin(i4 a){return vec4( a.xyz*cos(a.w),sin(a.w));}\n//vec4 da_cos(i4 a){return vec4(-a.xyz*sin(a.w),cos(a.w));}\n\n//a4 daconsss(a1 a){return dac4(a[0]);}\n#define daexp(z) z daex2(z a){float w=exp(a[0]);return v2a\ndaexp(a2)(vec2(w,a2n(a)*w));}\ndaexp(a3)(vec3(w,a2n(a)*w));}\ndaexp(a4)(vec4(w,a2n(a)*w));}\n//vec4 da_exp(i4 a){float w=exp(a.w);return vec4(a.xyz*w,w);}//exp(a)==pow(e,a)\n#define dalog2 log(a[0]),a2n(a)/a[0]));}\n#define dalog3(z) z dalog(z a){return v2a\ndalog3(a2)(vec2(dalog2 dalog3(a3)(vec3(dalog2 dalog3(a4)(vec4(dalog2\n//vec4 da_log(i4 a){return vec4(a.xyz/a.w,log(a.w));}\n\n//if(a==0)return a, return 1/a;\nfloat safeinv(float a){return mix(a,1./a,step(abs(a),0.));}\na1 safeinv(a1 a){return v2a(safeinv(a[0]));}\n#define daab2 abs(a[0]),a2n(a)*sign(a[0])));}\n#define daab3(z) z daabs(z a){return v2a\ndaab3(a2)(vec2(daab2 daab3(a3)(vec3(daab2 daab3(a4)(vec4(daab2\n//vec4 da_abs (i4 a){return vec4(a.xyz*sign(a.w),abs(a.w));}                                    \n#define dapo2 a[0]*a[0],2.*a[0]*a2n(a)));}\n#define dapo3(z) z dapow2(z a){return v2a\ndapo3(a2)(vec2(dapo2 dapo3(a3)(vec3(dapo2 dapo3(a4)(vec4(dapo2\n//vec4 da_pow2(i4 a){return vec4(2.*a.w*a.xyz, a.w*a.w);}\n#define dasq2 sqrt(a[0]),safeinv(a[0])*a2n(a)*.5));}\n#define dasq3(z) z dasqrt(z a){return v2a(\ndasq3(a2)vec2(dasq2 dasq3(a3)vec3(dasq2 dasq3(a4)vec4(dasq2\n//vec4 da_sqrt(i4 a){float q=sqrt(a.w);return vec4(.5*a.xyz*safeinv(q),q);}\n#define damiE ,step(a[0],b[0])));}\n#define damis(z) z damin(z a,z b){return v2a(mix(a2v(a),a2v(b)damiE\ndamis(a2)damis(a3)damis(a4)\n//vec4 da_min(i4 a,i4 b){return(a.w<=b.w)?a:b;}\n#define damiL(z) z damin(z a,a1 b){return v2a(mix(a2v(a)\ndamiL(a2),dac2(b[0])damiE\ndamiL(a3),dac3(b[0])damiE\ndamiL(a4),dac4(b[0])damiE\n//vec4 da_min(i4 a,i1 b){return(a.w<=b  )?a:da_const(b);}\n#define damiR(z) z damin(a1 a,z b){return v2a(mix\ndamiR(a2)(dac2(a[0]),a2v(b)damiE\ndamiR(a3)(dac3(a[0]),a2v(b)damiE\ndamiR(a4)(dac4(a[0]),a2v(b)damiE\n//vec4 da_min(i1 a,i4 b){return(a  < b.w)?da_const(a):b;}\n#define damaE ,step(b[0],a[0])));}\n#define damas(z) z damax(z a,z b){return v2a(mix(a2v(a),a2v(b)damaE\ndamas(a2)damas(a3)damas(a4)\n//vec4 da_max(i4 a,i1 b){return(a.w>=b  )?a:da_const(b);}\n#define damaL(z) z damax(z a,a1 b){return v2a(mix(a2v(a)\ndamaL(a2),dac2(b[0])damaE\ndamaL(a3),dac3(b[0])damaE\ndamaL(a4),dac4(b[0])damaE\n//da_max(i1 a,i4 b){return(a  > b.w)?da_const(a):b;}\n#define damaR(z) z damax(a1 a,z b){return v2a(mix\ndamaR(a2)(dac2(a[0]),a2v(b)damaE\ndamaR(a3)(dac3(a[0]),a2v(b)damaE\ndamaR(a4)(dac4(a[0]),a2v(b)damaE\n//vec4 da_min(i1 a,i4 b){return(a  < b.w)?da_const(a):b;}\n#define mab0 mod(a[0],b[0])\n#define damo2 mab0,mod(a2n(a),1.)));}\n#define damo3(z) z damod(z a,z b){return v2a\ndamo3(a2)(vec2(damo2 damo3(a3)(vec3(damo2 damo3(a4)(vec4(damo2\n//vec4 da_mod(i4 a,i4 b){return vec4(mod(a.xyz,1.),mod(a.w,b.w));}\n#define damo1(z) z damod(z a,a1 b){return v2a\ndamo1(a2)(vec2(damo2 damo1(a3)(vec3(damo2 damo1(a4)(vec4(damo2\n//vec4 da_mod(i4 a,i1 b){return vec4(mod(a.xyz,1.),mod(a.w,b  ));}\n#define dam22 mod(a[0],b[0]),vec3(0)));}\n#define damo0(z,w) z damod(a1 a,z b){return v2a(w(mab0,\ndamo0(a2,vec2)0));}damo0(a3,vec3)vec2(0)));}damo0(a4,vec4)vec3(0)));}\n//vec4 da_mod(i1 a,i4 b){return vec4(0,0,0        ,mod(a  ,b.w));}//here \"a.xyz\"==vec3(0)\n#define dase return v2a(a2v(a)-a2v(b));}\n#define dasuM(z) z dasub(z a,z b)\ndasuM(a2){dase dasuM(a3){dase dasuM(a4){dase\n//vec4 da_sub(i4 a,i4 b){return a-b;}\n#define dasu2 a[0]-b[0],a2n(a)));}\n#define dasu3 a[0]-b[0],-a2n(b)));}\n#define dasuR(z) z dasub(z a,a1 b){return v2a\n#define dasuL(z) z dasub(a1 a,z b){return v2a\ndasuR(a2)(vec2(dasu2 dasuR(a3)(vec3(dasu2 dasuR(a4)(vec4(dasu2\n//vec4 da_sub(i4 a,i1 b){return vec4( a.xyz,a.w-b  );}\ndasuL(a2)(vec2(dasu3 dasuL(a3)(vec3(dasu3 dasuL(a4)(vec4(dasu3\n//vec4 da_sub(i1 a,i4 b){return vec4(-b.xyz,a  -b.w);}\n#define daade return v2a(a2v(a)*a2v(b));}\n#define daads(z) z daadd(z a,z b)\ndaads(a2){daade daads(a3){daade daads(a4){daade\n//vec4 da_add(i4 a,i4 b){return a+b;}\n#define daadE return dasub(a,a2i(b));}\n#define daadL(z) z daadd(a1 a,z b){daadE\n#define daadR(z) z daadd(z a,a1 b){daadE\ndaadL(a2)daadL(a3)daadL(a4)daadR(a2)daadR(a3)daadR(a4)\n//vec4 da_add(i4 a,i1 b){return da_sub(a,-b);}//addition as invrse substraction\n//vec4 da_add(i1 a,i4 b){return da_sub(a,-b);}\n#define amue a2n(a)*b[0]+a2n(b)*a[0])));}\n#define amun(z) z damul(z a,z b){return v2a\namun(a2)(vec2(a[0]*b[0],(amue\namun(a3)(vec3(a[0]*b[0],vec2(amue\namun(a4)(vec4(a[0]*b[0],vec3(amue\n//vec4 da_mul(i4 a,i4 b){return vec4(a.xyz*b.w+a.w*b.xyz, a.w*b.w);}\n#define amuf return v2a(a2v(a)*a2v(b));}\n#define amuR(z) z damul(z a,a1 b){amuf\n#define amuL(z) z damul(a1 a,z b){amuf\namuR(a2)amuR(a3)amuR(a4)amuL(a2)amuL(a3)amuL(a4)\n//vec4 da_mul(i4 a,i1 b){return a*b;}\n//vec4 da_mul(i1 a,i4 b){return a*b;}\n#define adie a2n(a)*b[0]-a2n(b)*a[0])/(b[0]*b[0])));}\n#define adin(z) z dadiv(z a,z b){return v2a\nadin(a2)(vec2(a[0]/b[0],(adie\nadin(a3)(vec3(a[0]/b[0],vec2(adie\nadin(a4)(vec4(a[0]/b[0],vec3(adie\n//vec4 da_div(i4 a,i4 b){return vec4((a.xyz*b.w-a.w*b.xyz)/(b.w*b.w), a.w/b.w);}\n#define adiE return v2a(a2v(a)/a2v(b));}\n#define adiR(z) z adiv(z a,a1 b)\nadiR(a2){adiE adiR(a3){adiE adiR(a4){adiE\n//vec4 da_div(i4 a,i1 b){return a/b;}\n#define adil a[0]/b[0],-a[0]*a2n(b)/(b[0]*b[0])));}\n#define adiL(z) z adiv(a1 a,z b){return v2a\nadiL(a2)(vec2(adil adiL(a3)(vec3(adil adiL(a4)(vec4(adil\n//vec4 da_div(i1 a,i4 b){return vec4((-a*b.xyz)/(b.w*b.w), a/b.w);} \n#define alw(w) a2n(w)*w[0]\n#define al21(w) w dalen(w x){float q=abs(x[0]);return v2a(\n#define aL21 safeinv(q)*alw(x),q));}\nal21(a2)vec2(aL21 al21(a3)vec3(aL21 al21(a4)vec4(aL21\n#define al22(w) w dalen(w x,w y){float q=length(vec2(x[0],y[0]));return v2a(\n#define aL22 safeinv(q)*(alw(x)+alw(y)),q));}\nal22(a2)vec2(aL22 al22(a3)vec3(aL22 al22(a4)vec4(aL22\nvec4 da_length(i4 x,i4 y){float q=length(vec2(x.w,y.w));\n return vec4((x.xyz*x.w+y.xyz*y.w)*safeinv(q),q);}\n#define al23(w) w dalen(w x,w y,w z){float q=length(vec3(x[0],y[0],z[0]));return v2a(\n#define aL23 safeinv(q)*(alw(x)+alw(y)+alw(z)),q));}\nal23(a2)vec2(aL23 al23(a3)vec3(aL23 al23(a4)vec4(aL23\nvec4 da_length(i4 x,i4 y,i4 z){float q=length(vec3(x.w,y.w,z.w));\n return vec4((x.xyz*x.w+y.xyz*y.w+z.xyz*z.w)*safeinv(q),q);}\n\n//back ocompatibility: (swivling is utterly wrong)\n#define da_pow2(a) a2v(dapow2(v2a(a)))\n#define da_add(a,b) a2v(daadd(v2a(a),v2a(b)))\n#define da_sub(a,b) a2v(dasub(v2a(a),v2a(b)))\n#define da_mul(a,b) a2v(damul(v2a(a),v2a(b)))\n#define da_div(a,b) a2v(damul(v2a(a),v2a(b)))\n#define da_min(a,b) a2v(damin(v2a(a),v2a(b)))\n#define da_max(a,b) a2v(damax(v2a(a),v2a(b)))\n#define da_abs(a) a2v(daabs(v2a(a)))\n                                                 \n#if (dimensions==3)\n             \n//using the above, we define distance functions that automatically calculate their derivatives\n//this makes surfaces that are C1-discontinuous, like staircases, \n//at least have their (continuous) first rerivate calculated, which is useful for raymarching (?)\nvec4 sdSphere(DAVec3 p){\n p.x*=.8;p.x-=.5*sin(1.61*iTime);\n p.y*=.8;\n p.z*=.8;p.z-=.5*cos(1.61*iTime);\n vec4 q=da_length(p.x,p.y,p.z);\n q=da_sub(q,1.);\n return q;}\n\n\n// s: width, height, depth, thickness\n// r: .xy corner radius, .z corner radius\n//return distance to very parametric surface that contains many useful sub-shapes.\nvec4 sdSuperprim(DAVec3 p, i4 s,vec2 r) {\n    vec4 dx = da_sub(da_abs(p.x),s.x);\n    vec4 dy = da_sub(da_abs(p.y),s.y);\n    vec4 dz = da_sub(da_abs(p.z),s.z);\n    vec4 q = \n       \tda_sub(\n            da_abs(\n                da_add(\n                    da_add(\n                        da_length(\n                            da_max(da_add(dx, r.x),0.),\n                            da_max(da_add(dy, r.x),0.)),\n                  \t\tda_min(-r.x,da_max(dx,dy))),\n                    s.w)), \n                s.w);\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n\n//Goursat Surface\nvec4 sdGoursat(DAVec3 p) {\n p.x = da_mul(p.x, 2.0);\n p.y = da_mul(p.y, 2.0);\n p.z = da_mul(p.z, 2.0);\n vec4 d =da_add(\n  20.*iMouse.x/iResolution.x,\n  da_sub(\n   da_add(\n    da_pow2(\n     da_pow2(p.x))\n     ,da_add(\n      da_pow2(\n       da_pow2(p.y))\n       ,da_pow2(\n         da_pow2(p.z)))),\n                da_add(\n                    da_mul(5.0,da_pow2(p.x)),\n                    da_add(\n                        da_mul(5.0,da_pow2(p.y)),\n                        da_mul(5.0,da_pow2(p.z))))));\n    return da_div(d, max(11.8,length(d.xyz)));\n}\n#endif /*dimensions=3*/\n             \n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n\n#if (dimensions==3)\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,i1 t,i1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\n\nstruct DAMValue{vec4 d;float m;};\n\nDAMValue min2OLD(DAMValue a, DAMValue b){if(a.d.w>b.d.w)return b;return a;}\nDAMValue planeOLD(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n                                                 \n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifdef Goursat\n //r=sdGoursat(p);\n //r=sdSphere(p);\n //r=da_max(-sdTangle(p),sdSphere(p));\n //r=sdGoursat(p)*.7+sdSphere(p)*.3;\n r=mix(sdGoursat(p),sdSphere(p),sin(iTime*.61)*.5+.5);\n  // r=r.wxyz;\n#else\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.z,p.y,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.w,b.w,u)),m);\n  //r=r.wxyz;\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n  //r=r.wxyz;\n#endif\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(i3 p){DAMValue d=df(da_domain(p));\n return vec2(d.d.w,d.m);}\n//return material at p with normal n\nvec4 material(i3 p,i3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.xyz*.5 +.5,.0)*abs(mod(d.w,.1)/.1-.5)\n           ,clamp(dm(p).y,0.,1.));}\n\n//return soft shadow\nfloat shadow(i3 o,i3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n\n//return p, modified by light , shadow, envMap...\nvec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(i3 o,i3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n  h=dm(o+i*t).x*StepFactor;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));\n return d.d.xyz;}\n\n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\nvec3 demo3d(vec2 p,vec2 m){\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n return c;}\n#else\n//draw linear function and its first derivative.\nvec3 demo2d(vec2 p,vec2 m){\n p*=5.;\n vec2 f=fract(abs(p)-.02);\n f*=(f*f)*(f*f)*(f*f);\n float grid=f.x+f.y;\n return vec3(grid);}\n#endif /*dimensions==3*/\n\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n //m=vec2(.01,.2);//a debug overwrite\n #if (dimensions==3)\n vec3 c=demo3d(p,m);\n #else \n vec3 c=demo2d(p,m);\n #endif /*dimensions==3*/\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}