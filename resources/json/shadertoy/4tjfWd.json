{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4tjfWd",
      "date": "1517613764",
      "viewed": 368,
      "name": "LOD bokeh blur",
      "username": "battlebottle",
      "description": "Modified from:\n\nhttps://www.shadertoy.com/view/4d2Xzw\n\nuse the mouse to change the blur intensity and day-night cycle",
      "likes": 6,
      "published": 3,
      "flags": 32,
      "tags": [
        "blur",
        "bokeh",
        "lod"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//Modified from:\n//\n//https://www.shadertoy.com/view/4d2Xzw\n//\n//A bokeh blur is calculated using by evenly sampling the area of a circle around each pixel, \n//and averaging the result. With a limited set of samples this creates visual artefacts as the \n//blur radius gets bigger. Using lod hides these artifacts without significantly decreasing the \n//blur quality in general.\n//\n//My math for calculating the LOD is probably wrong, but it's close enough to prove the concept.\n//High intensity lights were added to the photo of London to help highlight the bokeh effect.\n\n\n#define GOLDEN_ANGLE 2.39996\n\n#define ITERATIONS 128\n\nconst float SRGB_GAMMA = 1.0 / 2.2;\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//Sourced from: //https://www.shadertoy.com/view/4d2Xzw\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius)\n{\n\tvec3 acc = vec3(0);\n    float r = 1.;\n    \n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {\n        r += 1. / r;\n\t    vangle = rot * vangle;\n        vec3 col = textureLod(tex, uv + (r-1.) * vangle, sqrt(radius)).xyz * 1.0;\n        acc += col;\n\t}\n    \n\treturn acc / (vec3(float(ITERATIONS)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //get uv with correct aspect ratio\n    vec2 uv = fragCoord / iResolution.x + vec2(0.0,0.15); \n    \n    //calculate the blur radius we want\n\tfloat blurRadius = 1.6 - 1.6*cos(mod(iTime*.10 +.25, 3.0) * 6.283); \n    \n    if (iMouse.z > 0.0) {\n     \tblurRadius = (iMouse.x / iResolution.x) ;   \n    \tblurRadius *= 8.0;\n    }\n    \n    //Get a bokeh blurred sample of Buffer A and convert to sRGB\n    fragColor = vec4(pow((Bokeh(iChannel0, uv, blurRadius)), vec3(SRGB_GAMMA)), 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 5,
            "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "const float SRGB_GAMMA = 1.0 / 2.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    //Sample texture and convert to linear sRGB color space\n    fragColor =  vec4(pow(texture(iChannel0, uv).rgb, vec3(1.0 / SRGB_GAMMA)), 1.0);\n    \n    //Day-night cycle\n    float dayNightCycle = sin(iTime / 5.0) / 2.0 + 0.5;\n    \n    if (iMouse.z > 0.0) {\n     \tdayNightCycle = 1.0 - iMouse.y / iResolution.y;\n    }\n    \n    \n    vec3 nightColor = vec3(0.1, 0.15, 0.9);\n    vec3 dayColor = vec3(1.0, 0.9, 0.95);\n    vec3 lightColor = nightColor * dayNightCycle + dayColor * (1.0 - dayNightCycle);\n    \n    fragColor = vec4(fragColor.rgb * lightColor, 1.0);\n    \n    \n    //Street lamps\n\tif(distance( uv, vec2(0.1,0.54)) < 0.01){\n\t    fragColor += vec4(vec3(3.6, 3.4, 5.33) * 6.0, 1.0);\n\t}\n\tif(distance( uv, vec2(0.382,0.53)) < 0.008){\n\t    fragColor += vec4(vec3(3.6, 3.4, 5.33) * 6.0, 1.0);\n\t}\n\tif(distance( uv, vec2(0.672,0.53)) < 0.008){\n\t    fragColor += vec4(vec3(3.6, 3.4, 5.33) * 6.0, 1.0);\n\t}\n    \n    //Bus break lights\n\tif(distance( uv, vec2(0.22,0.354)) < 0.003){\n\t    fragColor += vec4(vec3(4.6, 2.4, 1.33) * 4.0, 1.0);\n\t}\n\tif(distance( uv, vec2(0.255,0.357)) < 0.003){\n\t    fragColor += vec4(vec3(4.6, 2.4, 1.33) * 4.0, 1.0);\n\t}\n    \n    //Bus indicator light\n    if (mod(iTime, 1.0) > 0.5) {\n\t\tif(distance( uv, vec2(0.22,0.365)) < 0.003){\n\t\t    fragColor += vec4(vec3(4.6, 4.4, 1.33) * 4.0, 1.0);\n\t\t}\n    }\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}