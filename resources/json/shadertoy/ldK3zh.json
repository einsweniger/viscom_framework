{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ldK3zh",
      "date": "1457883749",
      "viewed": 162,
      "name": "Testing Raymarching",
      "username": "maeln",
      "description": "A simple raymarching test.",
      "likes": 0,
      "published": 3,
      "flags": 32,
      "tags": [
        "raymarching"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "vec4 rgbShift(vec4 shift, in vec2 uv) {\n    vec2 rs = vec2(shift.x,-shift.w);\n    vec2 gs = vec2(shift.y,-shift.z);\n    vec2 bs = vec2(shift.z,-shift.x);\n    \n    float r = texture(iChannel0, rs+uv, 0.0).x;\n    float g = texture(iChannel0, gs+uv, 0.0).y;\n    float b = texture(iChannel0, bs+uv, 0.0).z;\n    \n    return vec4(r,g,b,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float dist = length((2.*fragCoord.xy - iResolution.xy) / iResolution.x);\n    \n    /*\n    int tx = int(uv.x*512.0);\n    float fftGrave = texelFetch( iChannel1, ivec2(0,0), 0 ).x; \n    float fftMiddle = texelFetch( iChannel1, ivec2(256,0), 0 ).x; \n    float fftAigue = texelFetch( iChannel1, ivec2(512,0), 0 ).x; \n    \n    dist *= fftGrave*4.0;\n    dist *= fftMiddle*2.0;\n    dist *= fftAigue*1.0;\n    */\n    \n    vec4 color = rgbShift(vec4(-dist/200.0, dist/200.0, -dist/200.0, dist/200.0), uv);\n    fragColor = color;\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 19,
            "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
            "ctype": "music",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "#define MAXSTEPS 128\n#define MINDIST  0.0005\n#define MAXDIST  20.0\n\n// Primitive fun from Iq: \n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nstruct pLight {\n    vec3 position;\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\n\nfloat sdPlane(vec3 p)\n{\n  return p.y;\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 cubes(vec3 p)\n{\n    if(p.z > 0.0)\n        return vec2(MAXDIST, 2.0);\n   \tvec3 c = vec3(1.0, 0.0, 1.0);\n    vec3 q = mod(p,c)-0.5*c;\n    return vec2(sdBox(q-vec3(0.0, 0.25, 0.0), vec3(0.25)), 2.0);\n}\n\nvec2 spheres(vec3 p)\n{\n    if(p.z < 0.0)\n        return vec2(MAXDIST, 2.0);\n   \tvec3 c = vec3(4.0, 0.0, 4.0);\n    vec3 q = mod(p,c)-0.5*c;\n    \n    float s1 = sphere(q-vec3(0,0.5,1.5), 0.5);\n    float s2 = sphere(q-vec3(0,0,1.0), 0.5);\n    vec2 u1 = vec2(smin(s1,s2,0.3), 1.0);\n    \n    return u1;\n}\n\nvec2 scene(vec3 ray)\n{\n    vec2 plane = vec2(sdPlane(ray), 0);\n    vec2 b1 = cubes(ray);\n    vec2 u1 = spheres(ray);\n    return opU(plane, opU(b1, u1));\n}\n\nvec2 DE(vec3 ray) {\n    return scene(ray);\n}\n\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.0, MINDIST);\n\treturn normalize(vec3(\n    DE(pos + eps.yxx).x - DE(pos - eps.yxx).x,\n    DE(pos + eps.xyx).x - DE(pos - eps.xyx).x,\n    DE(pos + eps.xxy).x - DE(pos - eps.xxy).x));\n}\n\nvec2 raymarch(vec3 from, vec3 direction)\n{\n    float t = 1.0*MINDIST;\n    int i = 0;\n    float obj = -1.0;\n    for(int steps=0; steps<MAXSTEPS; ++steps)\n    {\n        ++i;\n        vec2 dist = DE(from + t * direction);\n        if(dist.x < MINDIST || t >= MAXDIST) break;\n        t += dist.x;\n        obj = dist.y;\n    }\n    \n    return vec2(t, t > MAXDIST ? -1.0 : obj);\n}\n\nfloat grid(vec2 p, float factor)\n{\n\tfloat N = factor; // grid ratio\n\tvec2 w = fwidth(p)+MINDIST;\n\tvec2 a = p + 0.5*w;                        \n\tvec2 b = p - 0.5*w;           \n\tvec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\n\treturn (1.0-i.x)*(1.0-i.y);\n}\n\nvec3 fog(vec3 sky, vec3 mat, float dist) {\n    float fogAmount = 1.0 -min(exp(-dist*0.2), 1.0);\n    return mix(mat, sky, fogAmount);\n}\n\nvec3 material(vec2 c, vec3 hit, vec3 sky) {\n    vec3 color = sky;\n    if(c.y < 0.0) return color;\n    if(c.y < 1.0) {\n    \tcolor = vec3(grid(hit.xz*4.0, 18.0));\n    } else if(c.y < 2.0) {\n     \tcolor = vec3(0,1,0);\n    } else if(c.y >= 2.0 && c.y < 3.0) {\n    \tcolor = vec3(1,0,0);\n    } else {\n    \tcolor = vec3(c.x);\n    }\n    return color;\n}\n\n/*\nvec3 lambertShading(vec3 hit, vec3 normal, pLight light) {\n    vec3 L = light.position - hit;\n    vec3 LC = light.color * light.power * max(0.0, dot(L, normal));\n    return LC;\n}\n*/\n\nvec3 rayReflection(vec3 N, vec3 R) {\n    return normalize(-2.0*N*dot(R, N)+R);\n}\n\nvec3 refl(vec3 N, vec3 L) {\n    return 2.0*dot(L,N)*N-L;\n}\n\nvec3 phong(vec3 hit, vec3 eye, vec3 N, pLight light, float ks) {\n    vec3 L = normalize(light.position - hit);\n    vec3 V = normalize(eye - hit);\n    vec3 R = refl(N, L);\n    vec3 ambiant = light.ambiant;\n    vec3 diffuse = max(dot(L,N), 0.0)*light.diffuse;\n    vec3 specular = pow(max(dot(R,V), 0.0), ks)*light.specular;\n    return ambiant + 0.5*(diffuse+specular);\n}\n\nfloat shininess(vec3 hit, vec3 eye, vec3 normal, pLight light) {\n    float ks = 1.0; // Specular component, should be part of the material.\n    vec3 L = light.position - hit;\n    vec3 R = rayReflection(normal, L);\n    vec3 V = eye - hit;\n    return pow(dot(R, V), ks);\n}\n\nvec3 reflection(vec3 rayDir, vec3 normal, vec3 hit, vec3 sky) {\n    vec3 refle = rayReflection(normal, normalize(rayDir));\n    vec2 r = raymarch(hit, refle);\n    return material(r, hit+r.x*refle, sky);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pLight l1 = pLight(vec3(sin(iTime)*2.0, 2.0, cos(iTime)*2.0),\n                       vec3(0.1), vec3(0.5), vec3(0.8));\n    \n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    int tx = int(uv2.x*512.0);\n    float fftGrave = texelFetch( iChannel0, ivec2(0,0), 0 ).x; \n    float fftMiddle = texelFetch( iChannel0, ivec2(256,0), 0 ).x; \n    float fftAigue = texelFetch( iChannel0, ivec2(511,0), 0 ).x; \n    \n    vec3 target  = vec3(iTime, 1.0, 0.0);\n\tvec3 eye     = vec3(iTime-3.0+fftGrave, 1.0, sin(fftAigue));\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = vec3(0.0, 0.0, 1.0);//normalize(cross(up, eye));\n    vec3 eyeUp    = vec3(0.0, 1.0, 0.0);//normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    \n    vec3 hi = vec3(255.0, 166.0, 158.0)/255.0;\n    vec3 lo = vec3(134.0, 22.0, 87.0)/255.0;\n    vec3 color = mix(lo, hi, fragCoord.y/iResolution.y);\n    vec3 sky = color;\n    vec2 c = raymarch(eye, rayDir);\n    vec3 hit = eye+c.x*rayDir;\n    vec3 norm = normal(hit);\n    \n    if(c.y >= 0.0) {\n        if(c.y >= 1.0 && c.y < 2.0) {\n            // Reflexion\n            vec3 reflColor = reflection(rayDir, norm, hit, color);\n            color = mix(material(c, hit, color), reflColor, 0.7)*phong(hit, eye, norm, l1, 1.5);\n        } else {\n            color = material(c, hit, color);\n            color *= phong(hit, eye, norm, l1, 2.0);\n        }\n    }\n   \t\n    // Camera facing fake lighting.\n    //color *= max(0.0, dot(-rayDir, norm));\n    \n    // Gamma:\n    //color = pow(color, vec3(1.0/2.2));\n    //color *= c.x/10.0;\n    \n    color = fog(sky, color, c.x);\n    \n\tfragColor = vec4(color, 1.0);\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}