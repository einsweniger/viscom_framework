{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4d3cDf",
      "date": "1520428681",
      "viewed": 181,
      "name": "Ray Tracer (first)",
      "username": "Jamie_Pendergast",
      "description": "a raytracer",
      "likes": 1,
      "published": 3,
      "flags": 0,
      "tags": [
        "raytacer"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "float intersect(vec3 ro, vec3 rd, vec3 position, float radius) {\n    vec3 l = vec3(position.x - ro.x, position.y - ro.y, position.z - ro.z);\n    float tca = dot(l,rd);\n    float d2 = dot(l,l) - (tca * tca);\n\n    if(d2 > radius * radius ) {\n        return -1.0;\n    }\n\n    float thc = sqrt((radius * radius) - (d2));\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n\n\n    if(t0 > t1) {\n        float t1_c = t1;\n        float t0_c = t0;\n        t0 = t1_c;\n        t1 = t0_c;\n    }\n\n    if(t0 < 0.0) {\n        t0 = t1;\n        if(t0 < 0.0) {\n            return -1.0;\n        }\n    }\n\n    return t0;\n} \n\nstruct sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n};\n\n\n    vec3 light = vec3(0.);\nvec3 light_c = vec3(1.,1.,1.);\n\nvec3 material1(vec3 normal, vec3 color) {\n    return color * sin(min(max(dot(normal,light),0.1),0.95));\n}\n\nvec3 sky = vec3(0.1,0.4,1.);\n\nvec3 rayTrace(vec3 ro, vec3 rd, sphere[4]spheres) {\n    float t = 9999999.;\n\n    vec3 color = sky;\n    for(int x = 0; x < 3; x++) {\n        sphere tgt = spheres[x];\n        float i = intersect(ro,rd,tgt.pos, tgt.radius);\n\n        if(i != -1.) {        \n            if(i < t) {//the max dist is greater than the ray dist \n                t = i;\n            }\n            else{\n                //set color        \n                break;\n            }\n            vec3 hit = ro + rd * t;\n            vec3 b_hit = ro + rd * t - 0.01;\n            vec3 normal = normalize(vec3(tgt.pos -hit));\n\n            float dnl = dot(normal,light);\n            color = material1(normal,tgt.color);\n\n            float fraction = 0.2;\n            vec3 reflectionColor = vec3(1.);\n\n            for(int y = 0; y < 3; y++ ) {\n                if(y != x) {\n\n                    for(int z = 0; z < 10; z++) {\n                        sphere rs = spheres[y];\n                        vec3 r = reflect(rd,normal);\n\n\n                        float i = intersect(b_hit, r, rs.pos,rs.radius);\n\n                        if(i != -1.) {\n                            reflectionColor = material1(-r,rs.color);\n                            color = mix(color,reflectionColor * fraction,fraction);\n                            fraction /= 6.;\n\n                            ro = b_hit;\n                            rd = r;\n\n                        }    \n                        else  {\n\n                        }\n                    }              \n                }\n            }\n\n\n            for(int y = 0; y < 3; y++) {\n                if(y != x){ \n                    sphere stgt = spheres[y];\n\n                    float i = intersect(b_hit,-light,stgt.pos,stgt.radius);\n\n                    if(i != -1.) {\n                        color *= 0.1;\n                    }\n                    else {\n                        //shade the fcker in\n                        color = mix(color * light_c, sky + light_c,0.1);\n                    }\n                }\n            }\n\n        }\n\n    }\n\n\n    return color;\n}\n\n\n\nsphere spheres[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = vec3(cos(iTime),0.,1.);\n    light = normalize(light);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= 0.5;\n\n\n    spheres[0] = sphere(vec3(cos(iTime * 3.) * 6.,5. + sin(iTime * 3.) * 5.,30. + cos(iTime) * 20.) , vec3(0.,1.,0.), 6.);\n    spheres[1] = sphere(vec3(cos(iTime * 2.) * 12., 1.,30.),vec3(0.),6.);\n    spheres[2] = sphere(vec3(0.,-16.,30.), vec3(0.7), 10.);\n    vec3 mouse = vec3(iMouse.xy / iResolution.xy,0.);\n\n    mouse.xy -= 0.5;\n    vec3 ro = vec3(0.5) + mouse * 30.;\n    vec3 rd = normalize(vec3(uv,iResolution.x / iResolution.y * 0.5));\n    vec3 result = rayTrace(ro,rd,spheres);\n    fragColor = vec4(result,1.);\n}\n\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}