{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XtfcDS",
      "date": "1506143454",
      "viewed": 355,
      "name": "Stereo AR test scene",
      "username": "KylBlz",
      "description": "Optimized for mobile, click the screen to adjust distortion",
      "likes": 11,
      "published": 3,
      "flags": 0,
      "tags": [
        "raymarch",
        "ar",
        "vr"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 25,
            "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png",
            "ctype": "cubemap",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//Some kind of uhh... device... for umm... yeah.\n//#define NO_SCENE\n//#define NO_GLASSES\n\n#define PI 3.14159265\n#define zFar 100.\n//eyebox\n#define IPD 0.2\n//raymarch steps\n#define steps 64\n//min dist considered hit\n#define minC .002\n#define tex(a,b) textureLod(a,b,0.)\n\n//the current camera location and initial ray dir\nvec3 camLoc, rayDir;\n\n//tools\nvec3 rotateXY(vec3 p, vec2 angle) {\n    vec2 c = cos(angle), s = sin(angle);\n    p.yz *= mat2 (c.x,s.x,-s.x,c.x);\n    p.xz *= mat2 (c.y,s.y,-s.y,c.y);\n    return p;\n}\n//used for depth testing\nvec2 lt(const vec2 l, const vec2 r) { \n    return (l.x < r.x)? l: r;\n}\n\n\n//light location, size\nconst int mtLight = 1;\nvec4 light = vec4(vec3(1.,-.5,-3.), 0.1);\nvec3 lightCol = vec3(1., .75, .5);\nfloat brightness = 1.;\n//light functions\nfloat map_light(vec3 ro) {\n    return distance(ro, light.xyz) - light.w;\n}\nvec3 map_light_norm(vec3 ro) { \n    return normalize(ro - light.xyz);\n}\nvec3 map_light_pm(in vec3 ro, in vec3 rd) { \n    vec3 nrm = map_light_norm(ro);\n    return lightCol*brightness*max(0.,dot(-rd, nrm));\n}\nvec3 map_light_rgb(vec3 ro, vec3 rd, vec3 nrm) { \n    return map_light_pm(ro, rd);\n}\nvec3 map_light_ray(vec3 ro, vec3 rd, vec3 nrm) {\n    return rd;\n}\n\n\n//glass sphere location, size\nconst int mtGsph = 2;\nvec4 Gsphere = vec4(vec3(1.2, 0., -2.), 0.8);\n//glass sphere functions\nfloat map_Gsph(vec3 ro) {\n    return distance(ro, Gsphere.xyz) - Gsphere.w;\n}\nvec3 map_Gsph_norm(vec3 ro) {\n    return normalize(ro - Gsphere.xyz);\n}\nvec3 map_Gsph_pm(vec3 ro) { \n    return vec3(0.);\n}\nvec3 map_Gsph_rgb(vec3 ro, vec3 rd, vec3 nrm) { \n    return .5*(Gsphere.z - ro.zzz);\n}\nvec3 map_Gsph_ray(vec3 ro, vec3 rd, vec3 nrm) {\n\treturn refract(rd, nrm, 0.85);\n}\n\n\n//reflective sphere location, size\nconst int mtSsph = 3;\nvec4 Ssphere = vec4(vec3(-1., 0.5, -5.), 0.5);\n//reflective sphere functions\nfloat map_Ssph(vec3 ro) {\n    return distance(ro, Ssphere.xyz) - Ssphere.w;\n}\nvec3 map_Ssph_norm(vec3 ro) { \n    return normalize(ro - Ssphere.xyz); \n}\nvec3 map_Ssph_pm(vec3 ro, vec3 rd) {\n    vec3 nrm = map_Ssph_norm(ro),\n         rotnrm = rotateXY(nrm, vec2(0., iTime*.5)),\n         col = tex(iChannel0, rotnrm).rgb;\n    return col*col*max(0.,dot(rd, -nrm));\n}\nvec3 map_Ssph_rgb(vec3 ro, vec3 rd, vec3 nrm) {\n    return map_Ssph_pm(ro, rd);\n}\nvec3 map_Ssph_ray(vec3 ro, vec3 rd, vec3 nrm) {\n    return reflect(rd, nrm);\n}\n\n\n//aabb Center Size\nstruct box { vec3 c, s; };\nconst int mtBox = 5;\nbox b1 = box(vec3(0.,-1.5,0.), vec3(.5));\nfloat map_box(in vec3 ro) {\n  vec3 d = abs(b1.c - ro) - b1.s;\n  return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\nvec3 map_box_norm(vec3 ro) { \n    vec3 d = ro - b1.c;\n    //do a nice bevel\n    return normalize(step(b1.s * .95, abs(d))*sign(d));\n}\nvec3 map_box_pm(vec3 ro, float d) {\n    return vec3(0.);\n}\nvec3 map_box_rgb(vec3 ro, vec3 rd, vec3 nrm) {\n    //sample Ssphere\n    vec3 smp = normalize(ro - Ssphere.xyz),\n         rotnrm = rotateXY(smp, vec2(0., iTime*.5)),\n         col = tex(iChannel0, rotnrm).rgb;\n\t//sample light\n    float lightcontrib = max(0., dot(normalize(light.xyz - ro), nrm)),\n          ssphcontrib = max(0., dot(-smp, nrm));\n    return col*col*ssphcontrib + lightCol*lightcontrib*brightness;\n}\nvec3 map_box_ray(vec3 ro, vec3 rd, vec3 nrm) {\n    return reflect(rd, nrm);\n}\n\n\n//gets normal\nvec3 map_nrm(vec3 ro, int c) { \n    if (c == mtLight)\t return map_light_norm(ro);\n    else if (c == mtSsph)return map_Ssph_norm(ro);\n    else if (c == mtGsph)return map_Gsph_norm(ro);\n    else if (c == mtBox) return map_box_norm(ro);\n    else return vec3(0., 1., 0.);\n}\n//gets surface color\nvec3 map_rgb(vec3 ro, vec3 rd, vec3 nrm, vec3 c) {\n    int cy = int(c.y);\n    //emissive surfaces\n    if (cy == mtLight)\t  return map_light_rgb(ro, rd, nrm);\n    else if (cy == mtSsph)return map_Ssph_rgb(ro, rd, nrm);\n\t//use total dist (c.z) for ghetto AO\n    else if (cy == mtGsph)return map_Gsph_rgb(ro, rd, nrm) * c.z;\n    else if (cy == mtBox) return map_box_rgb(ro, rd, nrm) * c.z;\n    else return vec3(0.0);\n}\n//map light interactions\nvec3 map_ray(vec3 ro, vec3 rd, vec3 nrm, int c) { \n    if (c == mtLight)\t return map_light_ray(ro, rd, nrm);\n    else if (c == mtSsph)return map_Ssph_ray(ro, rd, nrm);\n    else if (c == mtGsph)return map_Gsph_ray(ro, rd, nrm);\n    else if (c == mtBox) return map_box_ray(ro, rd, nrm);\n    else return rd;\n}\n//returns { c(dist, mat, td), color(rgb), ro(xyz), rd(xyz) }\nmat4 map(vec3 pos, vec3 ro, vec3 rd, float t, float dt) {\n    //get distances\n    vec2 Gsphres = vec2(map_Gsph(pos), mtGsph),\n         Ssphres = vec2(map_Ssph(pos), mtSsph),\n         litres = vec2(map_light(pos), mtLight),\n         boxres = vec2(map_box(pos), mtBox);\n\n    //get total distance to other objects (non emissive)\n    float td = max(Gsphres.x, 0.) +\n               max(boxres.x, 0.);\n\n    //depth check and ambient occlusion\n    vec3 c = vec3(lt(lt(lt(Ssphres, Gsphres), litres), boxres), 1.-1./(1.+td*td));\n    \n    mat4 outp = mat4(vec4(c, 0.),\n                     vec4(0.), \n                     vec4(ro, 0.), \n                     vec4(rd, 0.));\n    \n    //get the normal of the closest touching thing\n    if (c.x < t*minC) { //if (c.x < minC) {\n        outp[0].w = 1.;\n        //get normal\n        vec3 nrm = map_nrm(pos, int(c.y));\n        //get color sample\n        outp[1].rgb += map_rgb(pos, rd, nrm, c) * float(steps) / 5.;\n        //get new ray info\n        outp[2].xyz = pos;\n        outp[3].xyz = map_ray(pos, rd, nrm, int(c.y));\n    \n    }\n    //sample participating media\n    outp[1].rgb += (\n    \t    map_Ssph_pm(pos, rd)  / (.5+Ssphres.x*Ssphres.x) +\n            map_light_pm(pos, rd) / (1.+5.*litres.x*litres.x)\n    );\n    \n    return outp;\n}\n\n\n//marches scene\nvec3 march( vec3 _ro, vec3 _rd) {\n    vec3 ro = _ro, rd = _rd, nrm;\n    //start at starting loc\n    float t = 0., dt = 0., ld = 0.;\n    //sdf results\n    mat4 c = mat4(0.);\n    //march vars\n    vec3 col = vec3(0.), pos = ro;\n    //the march loop\n    for( int i=0; i<steps; i++ ) {        \n        //step the ray and update position\n        t += dt;\n        //position to test depth functions\n        pos = ro+rd*t;\n        //get sdf results\n        c = map(pos, ro, rd, t, dt);\n        //update light\n        col += c[1].rgb;\n        ro = c[2].xyz;\n        rd = c[3].xyz;\n        //control step size\n        ld = dt;\n        //step slower closer to the camera\n        dt = min(.2, c[0].x);\n    }\n    \n    //final color\n    return col / float(steps) * 5.;\n}\n\n\nvec2 distort(float x, float x2, float x3, float x4, float y, float y2, float y3, float y4) {\n    return vec2( 0.005 + \n\t\tx\t  *  0.837 +\n\t\ty\t  *  0.001 +\n\t\tx2\t  * -0.008 +\n\t\tx*y\t  *  0.225 +\n\t\ty2\t  * -0.005 +\n\t\tx3\t  *  0.061 +\n\t\tx2*y  *  0.007 +\n\t\tx*y2  *  0.029 +\n\t\ty3\t  * -0.000 +\n\t\tx4\t  * -0.001 +\n\t\tx3*y  * -0.149 +\n\t\tx2*y2 * -0.010 +\n\t\tx*y3  * -0.056 +\n\t\ty4\t  *  0.000  \n\t\t,\t     0.009 +\n\t\tx\t  *  0.002 +\n\t\ty\t  *  1.047 +\n\t\tx2\t  *  0.055 +\n\t\tx*y\t  *  0.515 +\n\t\ty2\t  *  0.122 +\n\t\tx3\t  *  0.004 +\n\t\tx2*y  *  0.048 +\n\t\tx*y2  *  0.002 +\n\t\ty3\t  *  0.113 +\n\t\tx4\t  * -0.076 +\n\t\tx3*y  * -0.024 +\n\t\tx2*y2 * -0.363 +\n\t\tx*y3  * -0.008 +\n\t\ty4\t  * -0.020\n\t);\n}\nvec2 getDistortion(in vec2 uv, in vec2 bal, in float offset, out vec2 accum) {\n    //undo eye space transform\n    vec2 smp = uv * vec2(offset, 1.0);\n\t//to NDC\n    float x = smp.x * 2.0 - 1.0, y = smp.y * 2.0 - 1.0,\n\t\t//compute up to 4th order\n        x2 = x*x, y2 = y*y, x3 = x2*x, y3 = y2*y, x4 = x3*x, y4 = y3*y;\n\t//this just lets us mix distortion\n    vec2 d = smp - (distort(x,x2,x3,x4, y,y2,y3,y4) * 0.5 + 0.5);\n\t//create uniform mix, back to eye space\n\taccum = mix(vec2(0.), d, bal.y) * vec2(offset, 1.0);\n\t//distort uv\n    return uv + accum;\n}\n\n\nvoid mainImage( out vec4 fC, in vec2 fX ) {\n    //place 0,0 in center from -1 to 1 ndc\n    vec2 uv = fX.xy * 2./iResolution.xx - vec2(1., 0.5);\n    //get input, update camera\n    camLoc = vec3(0.1 + sin(iTime*.5), -sin(iTime * 0.125) + 1., 5.);\n\n#ifndef NO_GLASSES\n    //do stereo render\n    float eye = 0.;\n    if (uv.x > 0.) {\n        camLoc.x -= IPD;\n        uv.x -= 0.5;\n        eye = -1.;\n    } else {\n\t\tcamLoc.x += IPD;\n        uv.x += 0.5;\n        eye = 1.;\n    }\n    //do distortion correction\n    vec2 eyebox = iMouse.xy/iResolution.xy * vec2(0.2, 0.1);\n    if (dot(eyebox, eyebox) < .0001) eyebox = vec2(0., .001);\n    vec2 dlta = vec2(0.);\n    uv = getDistortion(uv, eyebox, eye, dlta);\n    \n#endif   \n#ifdef NO_SCENE\n    fC = vec4(fract(uv * 10.), .5, 1.);\n    return;\n#endif\n    \n\tvec3 camRot = vec3(sin(iTime*0.125)*0.3-0.3, PI, 0.);\n    //camRot is angle vec in rad\n    vec3 camDir = normalize(vec3(uv, 1.0));\n    rayDir = normalize(rotateXY(camDir, camRot.xy));\n    \n    //update stuff\n    light.x = 2. * sin(iTime*PI*0.3) + 1.;\n    light.z = 2. * cos(iTime*PI*0.3) - 3.;\n    brightness = 3.+3.*sin(iTime)*sin(iTime);\n    //calculate stuff\n    vec3 col = march(camLoc, rayDir);\n    //output\n    fC = vec4(pow(clamp(col, vec3(0.), vec3(1.)), vec3(.8)), 1.);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}