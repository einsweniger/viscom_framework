{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4lByzW",
      "date": "1507645010",
      "viewed": 351,
      "name": "low-poly heightmap",
      "username": "abje",
      "description": "uses voxel traversal and plane raycasting to make a terrain.",
      "likes": 3,
      "published": 3,
      "flags": 0,
      "tags": [
        "3d",
        "terrain",
        "voxels",
        "triangles"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//another hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat cosmix(float b, float a, float x) {\n\treturn a+(b-a)*(cos(x*3.14)+1.0)/2.0;\n}\n\nfloat noise3d(vec3 pos) {\n\tvec3 flo = vec3(floor(pos.x),floor(pos.y),floor(pos.z));\n\tfloat x0y0z0 = hash13(vec3(flo.x,    flo.y,    flo.z    ));\n\tfloat x1y0z0 = hash13(vec3(flo.x+1.0,flo.y,    flo.z    ));\n\tfloat x0y1z0 = hash13(vec3(flo.x,    flo.y+1.0,flo.z    ));\n\tfloat x1y1z0 = hash13(vec3(flo.x+1.0,flo.y+1.0,flo.z    ));\n\tfloat x0y0z1 = hash13(vec3(flo.x,    flo.y,    flo.z+1.0));\n\tfloat x1y0z1 = hash13(vec3(flo.x+1.0,flo.y,    flo.z+1.0));\n\tfloat x0y1z1 = hash13(vec3(flo.x,    flo.y+1.0,flo.z+1.0));\n\tfloat x1y1z1 = hash13(vec3(flo.x+1.0,flo.y+1.0,flo.z+1.0));\n\tfloat a =  cosmix(x0y0z0,x1y0z0, pos.x-flo.x);\n\tfloat b =  cosmix(x0y1z0,x1y1z0, pos.x-flo.x);\n\tfloat a1 = cosmix(a,b,pos.y-flo.y);\n\tfloat a2 = cosmix(x0y0z1,x1y0z1, pos.x-flo.x);\n\tfloat b2 = cosmix(x0y1z1,x1y1z1, pos.x-flo.x);\n\tfloat b1 = cosmix(a2,b2,pos.y-flo.y);\n\treturn     cosmix(a1,b1,pos.z-flo.z);\n}\n\nvec3 noise(vec2 p) {\n    return mix(hash33(vec3(p,floor(iTime))),hash33(vec3(p,ceil(iTime))),fract(iTime));\n}\n\nfloat ground(vec2 p) {\n    //return 0.0;\n    //return sin(length(p)*3.0+iTime);\n    //return dot(noise(p),vec3(1))*6.0;\n    //return dot(sin(p+iTime),vec2(1));\n    return noise3d(vec3(p*0.1,iTime))*15.0;\n}\n\n\n//ray-plane intersection, is negative if the ray starting point is under the plane and returns a high number if ray is not pointing in plane direction\nfloat plane(vec3 p, vec3 d, vec3 plane) {\n    return dot(p,plane)/max(-dot(d,plane),0.00001);\n}\n\n//shades the terrain, coloring according to normal, not the best shading\nvec4 shade(vec3 p, vec3 d, vec3 objnorm, float depth, vec4 background) {\n    vec3 sun = normalize(vec3(-1));\n    vec3 reflectnorm = reflect(d,objnorm);\n    vec3 color = objnorm*0.5+0.5;\n    vec4 fragColor = vec4(color*max(0.4,0.8*dot(objnorm,-sun)),1.0);\n    //fragColor = mix(background,fragColor,clamp(3.0-depth*0.05,0.0,1.0));\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //ray orientation(camera position) and ray direcion(camera direction)\n    vec3 ro = vec3(-0.25,17.5,-iTime);\n    vec3 rd = vec3(uv+0.001,-1.0);\n    \n    //current voxel\n    vec2 cell = floor(ro.xz);\n    //the inverse of ray direction\n    vec3 invrd= abs(1.0/rd);\n    //the position of the ray relative to the voxel\n    vec2 cello= (ro.xz-cell);\n    \n    vec2 lens = abs(step(vec2(0),rd.xz)-cello)*invrd.xz;\n    //distance from camera to hit position for fog\n    float dist = 0.0;\n    vec3 normal = vec3(0);\n    for (int i = 0; i < 100; i++) {\n        vec2 mask = vec2(lessThanEqual(lens,lens.yx));\n        float len = dot(lens,mask)/dot(mask,vec2(1));\n        \n        const vec2 a = vec2(1,0);\n        \n        //calculating height of the terrain at all four of the voxels edges\n        vec4 heights = vec4(\n            ground(cell+a.yy),\n            ground(cell+a.xy),\n            ground(cell+a.yx),\n            ground(cell+a.xx));\n        \n        //the normal of the 2 planes used to find the intersection\n        vec3 dir = -normalize(cross(vec3(1,heights.y,0)-vec3(0,heights.x,0),vec3(0,heights.z,1)-vec3(0,heights.x,0)));\n        vec3 dir2 = normalize(cross(-vec3(1,heights.y,0)+vec3(1,heights.w,1),-vec3(0,heights.z,1)+vec3(1,heights.w,1)));\n        \n        //vec3 dir = normalize(noise(cell)+vec3(-0.5,0.1,-0.5));\n        \n        //ray-plane intersection\n        float len3 = plane(vec3( ro.x-cell.x ,ro.y-heights.x, ro.z-cell.y ),rd,dir);\n        float len4 = plane(vec3((ro.x-cell.x)-1.0,ro.y-heights.w,(ro.z-cell.y)-1.0),rd,dir2);//(ro.y-heights.x)*invrd.y;\n        \n        float len2;\n        vec3 dir3;\n        float len5;\n        \n        if (heights.x+heights.w<heights.y+heights.z) {\n            len2 = max(len3, len4);\n            \n            //checking for edge case\n            vec3 p = ro+rd*len2;\n            len2 += step(0.001,max(dot(vec3((p.x-cell.x)-1.0,p.y-heights.w,(p.z-cell.y)-1.0),dir2),\n                                   dot(vec3( p.x-cell.x ,p.y-heights.x, p.z-cell.y ),dir)))*100000.0;\n        } else {\n            len2 = min(len3,len4);\n        }\n        if (len2 == len3) {\n            dir3 = dir;\n        } else {\n            dir3 = dir2;\n        }\n        \n        //len2 = len4;\n        if (len2 < len) {\n            if (len2 < 0.0) {normal.xz = -vec2(equal(lens,invrd.xz))*sign(rd.xz);}\n            else {normal = dir3;}\n            ro += rd*max(len2,0.0);\n            \n            break;\n        }\n        \n        lens -= len;\n        lens = lens*(1.0-mask)+invrd.xz*mask;\n        \n        dist += len;\n        cell += sign(rd.xz)*mask;\n        ro += rd*len;\n        \n        if (ro.y > 20.0) break;\n        \n    }\n    \n    fragColor = vec4(0.0,0.0,uv.y+0.5,1.0);\n    if (normal != vec3(0.0)) {\n\t\tfragColor = shade(ro,rd,normal,dist,fragColor);\n    } else {\n        \n    }\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}