{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4sSfzK",
      "date": "1501466480",
      "viewed": 3069,
      "name": "[SH17C] Physically Based Shading",
      "username": "knarkowicz",
      "description": "Click on menu buttons, use controls, rotate object and learn!",
      "likes": 104,
      "published": 3,
      "flags": 48,
      "tags": [
        "tutorial",
        "text",
        "presentation",
        "pbr",
        "gui",
        "sh17c"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 24,
            "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
            "ctype": "cubemap",
            "channel": 2,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 25,
            "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png",
            "ctype": "cubemap",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 49,
            "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
            "ctype": "texture",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "const float MATH_PI = float( 3.14159 );\n\nconst float MENU_SURFACE    = 0.;\nconst float MENU_METAL      = 1.;\nconst float MENU_DIELECTRIC = 2.;\nconst float MENU_ROUGHNESS  = 3.;\nconst float MENU_BASE_COLOR = 4.;\nconst float MENU_LIGHTING   = 5.;\nconst float MENU_DIFFUSE    = 6.;\nconst float MENU_SPECULAR   = 7.;\nconst float MENU_DISTR      = 8.;\nconst float MENU_FRESNEL    = 9.;\nconst float MENU_GEOMETRY   = 10.;\n\nconst vec3 BASE_COLORS[ 6 ] = vec3[ 6 ]\n(\n    vec3( 0.74 ),\n\tvec3( 0.51, 0.72, 0.81 ),\n \tvec3( 0.66, .85, .42 ),\n\tvec3( 0.87, 0.53, 0.66 ),\n    vec3( 0.51, 0.46, 0.74 ),\n\tvec3( 0.78, 0.71, 0.45 )\n);\n    \nstruct AppState\n{\n    float\tmenuId;\n    float\tmetal;    \n    float   roughness;\n    float   baseColor;\n    float   focus;\n    float   focusObjRot;\n    float   objRot;\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}\n\nvoid LoadState( out AppState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.menuId    = data.x;\n    s.metal     = data.y;\n    s.roughness = data.z;\n    s.baseColor = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.focus     \t= data.x;\n    s.focusObjRot\t= data.y;\n    s.objRot    \t= data.z;\n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nvec3 saturate( vec3 x )\n{\n    return clamp( x, vec3( 0. ), vec3( 1. ) );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid Repeat( inout float p, float w )\n{\n    p = mod( p, w ) - 0.5f * w;\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1. ) * r;\n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Capsule( vec2 p, float r, float c ) \n{\n\treturn mix( length( p.x ) - r, length( vec2( p.x, abs( p.y ) - c ) ) - r, step( c, abs( p.y ) ) );\n}\n\nfloat Arrow( vec2 p, float a, float l, float w ) \n{\n    Rotate( p, a );\n    p.y += l; \n    \n    float body = Capsule( p, w, l );\n    p.y -= w;\n\n    float tip = p.y + l;\n\n    p.y += l + w;\n    Rotate( p, +2. );\n    tip = max( tip, p.y - 2. * w );\n    Rotate( p, -4. );\n    tip = max( tip, p.y - 2. * w );\n    \n    return min( body, tip );\n}\n\nfloat TextSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\n\nvoid Diagram( inout vec3 color, vec2 p, in AppState s )\n{   \n    vec3 surfColor     = vec3( 0.9, 0.84, 0.8 );\n    vec3 lightColor    = vec3( 0.88, 0.65, 0.2 );\n    vec3 baseColor     = BASE_COLORS[ int( s.baseColor ) ];\n    vec3 diffuseColor  = s.metal == 1. ? vec3( 0. ) : baseColor;\n    vec3 specularColor = s.metal == 1. ? baseColor : vec3( 0.7 );\n    \n    p -= vec2( 84., 44. );\n    \n    vec2 t = p - vec2( 18., 4. );\n    float r = Rectangle( t, vec2( 52., 12. ) );\n    color = mix( color, surfColor, Smooth( -r * 2. ) );\n    \n    t.y += s.roughness * sin( t.x );\n    r = Rectangle( t - vec2( 0., 11. ), vec2( 52., 1.2 ) );\n    color = mix( color, surfColor * 0.6, Smooth( -r * 2. ) ); \n    \n    \n    // refraction\n    r = 1e4;\n    t = p - vec2( 18., 15. );\n    for ( int i = 0; i < 3; ++ i )\n    {\n        r = min( r, Arrow( t - vec2( -15. + float( i ) * 15., 0. ), -0.4, 7., .7 ) );\n    }\n    r = min( r, Arrow( t - vec2( 9., -15. ), 2., 4., .7 ) );\n    r = min( r, Arrow( t - vec2( 17., -10. ), 3.8, 18., .7 ) );\n    r = min( r, Arrow( t - vec2( -6., -14. ), 0.9, 3., .7 ) );\n    r = min( r, Arrow( t - vec2( 1., -19. ), 2.9, 18., .7 ) );\n    r = min( r, Arrow( t - vec2( -22., -15. ), 4.5, 2., .7 ) );\n    r = min( r, Arrow( t - vec2( -28., -14. ), 2.6, 14., .7 ) );\n    if ( s.metal != 1. && s.menuId < MENU_SPECULAR )\n    {\n        color = mix( color, diffuseColor, Smooth( -r * 2. ) );   \n    }    \n    \n    // reflection\n    r = 1e4;\n    t = p - vec2( 18., 15. );\n    for ( int i = 0; i < 3; ++ i )\n    {\n        float off = s.roughness * ( 1.5 - float( i ) ) * .45;\n        r = min( r, Arrow( t - vec2( -15. + float( i ) * 15., 2. ), -0.5 * MATH_PI - 0.9 + off, 12., 1. ) );\n    }\n    if ( s.menuId != MENU_DIFFUSE )\n    {\n        color = mix( color, specularColor, Smooth( -r * 2. ) );\n    }\n    \n    // light in\n    r = 1e4;\n    t = p - vec2( 18., 15. );\n    for ( int i = 0; i < 3; ++ i )\n    {\n        r = min( r, Arrow( t - vec2( 12. + float( i ) * 15., 22. ), -0.9, 15., 1. ) );\n    }\n    color = mix( color, lightColor, Smooth( -r * 2. ) );    \n}\n\nfloat RaySphere( vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius )\n{\n\tvec3 oc = rayOrigin - spherePos;\n\t\n\tfloat b = dot( oc, rayDir );\n\tfloat c = dot( oc, oc ) - sphereRadius * sphereRadius;\n\tfloat h = b * b - c;\n\t\n\tfloat t;\n\tif ( h < 0.0 )\n    {\n\t\tt = -1.0;\n    }\n\telse\n    {\n\t\tt = ( -b - sqrt( h ) );\n    }\n\treturn t;\n}\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt( ndotv * ( ndotv - ndotv * r2 ) + r2 );\n\tfloat gl = ndotv * sqrt( ndotl * ( ndotl - ndotl * r2 ) + r2 );\n\treturn 0.5 / max( gv + gl, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = ( ndoth * r2 - ndoth ) * ndoth + 1.0;\n\treturn r2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = specularColor + ( 1. - specularColor ) * pow( ( 1. - vdoth ), 5. );\n\treturn fresnel;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Torus( vec3 p, float sr, float lr )\n{\n\treturn length( vec2( length( p.xz ) - lr, p.y ) ) - sr;\n}\n\nfloat Disc( vec3 p, float r, float t ) \n{\n\tfloat l = length( p.xz ) - r;\n\treturn l < 0. ? abs( p.y ) - t : length( vec2( p.y, l ) ) - t;\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    // ring\n    vec3 t = p;\n    t.y -= -.7;\n    float r = Substract( Disc( t, 0.9, .1 ), Cylinder( t, .7, 2. ) );\n    vec3 t2 = t - vec3( 0., 0., 1.0 );\n    Rotate( t2.xz, 0.25 * MATH_PI );\n    r = Substract( r, Box( t2, vec3( .5 ) ) );\n    r = Union( r, Disc( t + vec3( 0., 0.05, 0. ), 0.85, .05 ) );\n    \n    t = p;\n    Rotate( t.yz, -.3 );\n    \n    // body\n    float b = Sphere( t, .8 );\n    b = Substract( b, Sphere( t - vec3( 0., 0., .5 ), .5 ) );\n    b = Substract( b, Sphere( t - vec3( 0., 0., -.7 ), .3 ) );\n    b = Substract( b, Box( t, vec3( 2., .03, 2. ) ) );\n    b = Union( b, Sphere( t, .7 ) );\n\n    float ret = Union( r, b );\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( nor );\n}\n\nfloat SceneAO( vec3 p, vec3 n, mat3 localToWorld )\n{\n    float ao = 0.0;\n    float s = 1.0;\n    for( int i = 0; i < 6; ++i )\n    {\n        float off = 0.001 + 0.2 * float( i ) / 5.;\n        float t = Scene( n * off + p, localToWorld );\n        ao += ( off - t ) * s;\n        s *= 0.4;\n    }\n    \n    return Smooth( 1.0 - 12.0 * ao );\n}\n\n// St. Peter's Basilica SH\n// https://www.shadertoy.com/view/lt2GRD\nstruct SHCoefficients \n{\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients SH_STPETER = SHCoefficients(\n    vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    vec3(-0.0818750, -0.0321501,  0.0033399 )\n);\n\nvec3 SHIrradiance( vec3 nrm ) \n{\n    const SHCoefficients c = SH_STPETER;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * ( nrm.x * nrm.x - nrm.y * nrm.y ) +\n        c3 * c.l20 * nrm.z * nrm.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\n        2.0 * c1 * c.l21  * nrm.x * nrm.z +\n        2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\n        2.0 * c2 * c.l11  * nrm.x +\n        2.0 * c2 * c.l1m1 * nrm.y +\n        2.0 * c2 * c.l10  * nrm.z\n    );\n}\n\nvec3 EnvBRDFApprox( vec3 specularColor, float roughness, float ndotv )\n{\n    const vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n    vec4 r = roughness * c0 + c1;\n    float a004 = min( r.x * r.x, exp2( -9.28 * ndotv ) ) * r.x + r.y;\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;  \n}\n\nvec3 EnvRemap( vec3 c )\n{\n    return pow( 2. * c, vec3( 2.2 ) );\n}\n\nvoid DrawScene( inout vec3 color, vec2 p, in AppState s )\n{\n    vec3 lightColor = vec3( 2. );\n    vec3 lightDir = normalize( vec3( .7, .9, -.2 ) );\n    \n\tvec3 baseColor     = pow( BASE_COLORS[ int( s.baseColor ) ], vec3( 2.2 ) );\n    vec3 diffuseColor  = s.metal == 1. ? vec3( 0. ) : baseColor;\n    vec3 specularColor = s.metal == 1. ? baseColor : vec3( 0.02 );\n    float roughnessE   = s.roughness * s.roughness;\n    float roughnessL   = max( .01, roughnessE );\n    \n    float a = -iTime * .5;\n    mat3 rot = mat3(\n        vec3( cos( a ), 0., -sin( a ) ),\n\t\tvec3( 0., 1., 0. ),        \n        vec3( sin( a ), 0., cos( a ) )\n        );    \n    \n    p -= vec2( -20., 10. );\n    p *= .011;\n    \n    float yaw = 2.7 - s.objRot;\n    mat3 rotZ = mat3(\n        vec3( cos( yaw ), 0.0, -sin( yaw ) ),\n\t\tvec3( 0.0, 1.0, 0.0 ),        \n        vec3( sin( yaw ), 0.0, cos( yaw ) )\n        );\n    \n    float phi = -0.1;\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotY * rotZ;       \n    \n\tvec3 rayOrigin \t= vec3( 0.0, .5, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );    \n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );        \n        vec3 viewDir = -rayDir;\n        vec3 refl = reflect( rayDir, normal );\n        \n        vec3 diffuse  = vec3( 0. );\n        vec3 specular = vec3( 0. );\n        \n        vec3 halfVec = normalize( viewDir + lightDir );\n        float vdoth = saturate( dot( viewDir, halfVec ) );\n        float ndoth\t= saturate( dot( normal, halfVec ) );\n        float ndotv = saturate( dot( normal, viewDir ) );\n        float ndotl = saturate( dot( normal, lightDir ) );\n        vec3 envSpecularColor = EnvBRDFApprox( specularColor, roughnessE, ndotv );\n        \n        vec3 env1 = EnvRemap( texture( iChannel2, refl ).xyz );\n        vec3 env2 = EnvRemap( texture( iChannel1, refl ).xyz );        \n        vec3 env3 = EnvRemap( SHIrradiance( refl ) );        \n        vec3 env  = mix( env1, env2, saturate( roughnessE * 4. ) );\n        env       = mix( env,  env3, saturate( ( roughnessE - 0.25 ) / 0.75 ) );\n        \n        diffuse += diffuseColor * EnvRemap( SHIrradiance( normal ) );\n        specular += envSpecularColor * env;\n\n\t\tdiffuse  += diffuseColor * saturate( dot( normal, lightDir ) );\n            \n   \t\tvec3 lightF = FresnelTerm( specularColor, vdoth );\n\t\tfloat lightD = DistributionTerm( roughnessL, ndoth );\n\t\tfloat lightV = VisibilityTerm( roughnessL, ndotv, ndotl );\n        specular += lightColor * lightF * ( lightD * lightV * MATH_PI * ndotl );\n        \n        float ao = SceneAO( pos, normal, localToWorld );\n        diffuse *= ao;\n        specular *= saturate( pow( ndotv + ao, roughnessE ) - 1. + ao);\n        \n        color = diffuse + specular;\n        if ( s.menuId == MENU_DIFFUSE )\n        {\n            color = diffuse;\n        }\n        if ( s.menuId == MENU_SPECULAR )\n        {\n            color = specular;\n        }\n        if ( s.menuId == MENU_DISTR )\n        {\n            color = vec3( lightD );\n        }        \n        if ( s.menuId == MENU_FRESNEL )\n        {\n            color = envSpecularColor;\n\t\t}\n        if ( s.menuId == MENU_GEOMETRY )\n        {\n            color = vec3( lightV ) * (4.0f * ndotv * ndotl);\n        }  \n        color = pow( color * .4, vec3( 1. / 2.2 ) );\n    }\n    else\n    {\n        // shadow\n        float planeT = -( rayOrigin.y + 1.2 ) / rayDir.y;\n        if ( planeT > 0.0 )\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = .7;\n            color *= 0.7 + 0.3 * smoothstep( 0.0, 1.0, saturate( length( p + vec3( 0.0, 1.0, -0.5 ) ) - radius ) );\n        }\t\t\n    }\n}\n\nvoid InfoText( inout vec3 color, vec2 p, in AppState s )\n{\n    p -= vec2( 52, 12 );\n    vec2 q = p;\n    if ( s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR )\n    {\n        p.y -= 6.;\n    }\n    if ( s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL )\n    {\n        p.y += 6.;\n    }\n    if ( s.menuId == MENU_SPECULAR )\n    {\n        p.y += 6. * 6.;\n        \n        if ( p.x < 21. && p.y >= 27. && p.y < 30. )\n        {\n            p.y = 0.;\n        }\n        else if ( s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21. )\n        {\n            p.y += 3.;\n        }\n    }\n    \n    vec2 scale = vec2( 3., 6. );\n    vec2 t = floor( p / scale );\n    \n    uint v = 0u;\n    if ( s.menuId == MENU_SURFACE )\n    {\n        v = t.y == 2. ? ( t.x < 4. ? 1702127169u : ( t.x < 8. ? 1768431730u : ( t.x < 12. ? 1852404852u : ( t.x < 16. ? 1752440935u : ( t.x < 20. ? 1970479205u : ( t.x < 24. ? 1667327602u : ( t.x < 28. ? 1768693861u : 7628903u ) ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1937334642u : ( t.x < 8. ? 1717924384u : ( t.x < 12. ? 1952671084u : ( t.x < 16. ? 1684955424u : ( t.x < 20. ? 1717924384u : ( t.x < 24. ? 1952670066u : ( t.x < 28. ? 32u : 0u ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 1868784481u : ( t.x < 8. ? 1852400754u : ( t.x < 12. ? 1869881447u : ( t.x < 16. ? 1701729056u : ( t.x < 20. ? 1931963500u : ( t.x < 24. ? 2002873376u : 0u ) ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 32. ? v : 0u;\n    }\n    if ( s.menuId == MENU_METAL )\n    {\n        v = t.y == 1. ? ( t.x < 4. ? 1635018061u : ( t.x < 8. ? 1852776556u : ( t.x < 12. ? 1914730860u : ( t.x < 16. ? 1701602917u : ( t.x < 20. ? 544437347u : ( t.x < 24. ? 1751607660u : ( t.x < 28. ? 1914729332u : ( t.x < 32. ? 544438625u : 45u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 544432488u : ( t.x < 8. ? 2037149295u : ( t.x < 12. ? 1701868320u : ( t.x < 16. ? 1634497891u : ( t.x < 20. ? 114u : 0u ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 36. ? v : 0u;   \n    }\n    if ( s.menuId == MENU_DIELECTRIC )\n    {\n        v = t.y == 3. ? ( t.x < 4. ? 1818585412u : ( t.x < 8. ? 1920230245u : ( t.x < 12. ? 1914725225u : ( t.x < 16. ? 1701602917u : ( t.x < 20. ? 544437347u : ( t.x < 24. ? 1701868328u : ( t.x < 28. ? 1634497891u : ( t.x < 32. ? 2107762u : 0u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 2. ? ( t.x < 4. ? 543452769u : ( t.x < 8. ? 1935832435u : ( t.x < 12. ? 1634103925u : ( t.x < 16. ? 1931502947u : ( t.x < 20. ? 1953784163u : ( t.x < 24. ? 544436837u : ( t.x < 28. ? 1718182952u : ( t.x < 32. ? 1702065510u : 41u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1751607660u : ( t.x < 8. ? 1634869364u : ( t.x < 12. ? 539915129u : ( t.x < 16. ? 1667592275u : ( t.x < 20. ? 1918987381u : ( t.x < 24. ? 544434464u : ( t.x < 28. ? 1936617315u : ( t.x < 32. ? 1953390964u : 0u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 808333438u : ( t.x < 8. ? 774909234u : ( t.x < 12. ? 13360u : 0u ) ) ) : v;\n        v = t.x >= 0. && t.x < 36. ? v : 0u;    \n    }\n    if ( s.menuId == MENU_ROUGHNESS )\n    {\n        v = t.y == 2. ? ( t.x < 4. ? 1735749458u : ( t.x < 8. ? 544367976u : ( t.x < 12. ? 1718777203u : ( t.x < 16. ? 1936024417u : ( t.x < 20. ? 1830825248u : ( t.x < 24. ? 543519343u : ( t.x < 28. ? 1952539507u : ( t.x < 32. ? 1701995892u : 100u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1818649970u : ( t.x < 8. ? 1702126437u : ( t.x < 12. ? 1768693860u : ( t.x < 16. ? 544499815u : ( t.x < 20. ? 1937334642u : ( t.x < 24. ? 1851858988u : ( t.x < 28. ? 1752440932u : ( t.x < 32. ? 2126709u : 0u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 1920298082u : ( t.x < 8. ? 1919248754u : ( t.x < 12. ? 1717924384u : ( t.x < 16. ? 1952671084u : ( t.x < 20. ? 1936617321u : 0u ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 36. ? v : 0u;\n    }\n    if ( s.menuId == MENU_BASE_COLOR )\n    {\n        v = t.y == 1. ? ( t.x < 4. ? 544370502u : ( t.x < 8. ? 1635018093u : ( t.x < 12. ? 1679848300u : ( t.x < 16. ? 1852401253u : ( t.x < 20. ? 1931506533u : ( t.x < 24. ? 1969448304u : ( t.x < 28. ? 544366956u : ( t.x < 32. ? 1869377379u : 114u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 544370502u : ( t.x < 8. ? 1818585444u : ( t.x < 12. ? 1920230245u : ( t.x < 16. ? 544433001u : ( t.x < 20. ? 1768169517u : ( t.x < 24. ? 1937073766u : ( t.x < 28. ? 1868767333u : ( t.x < 32. ? 7499628u : 0u ) ) ) ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 36. ? v : 0u;\n    }\n    if ( s.menuId == MENU_LIGHTING )\n    {\n        v = t.y == 2. ? ( t.x < 4. ? 1751607628u : ( t.x < 8. ? 1735289204u : ( t.x < 12. ? 544434464u : ( t.x < 16. ? 1869770849u : ( t.x < 20. ? 1634560376u : ( t.x < 24. ? 543450484u : 2128226u ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1634755955u : ( t.x < 8. ? 1769234802u : ( t.x < 12. ? 1679845230u : ( t.x < 16. ? 1969645161u : ( t.x < 20. ? 1629513075u : ( t.x < 24. ? 2122862u : 0u ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 1667592307u : ( t.x < 8. ? 1918987381u : ( t.x < 12. ? 1836016416u : ( t.x < 16. ? 1701736304u : ( t.x < 20. ? 544437358u : 0u ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 28. ? v : 0u;\n    }\n    if ( s.menuId == MENU_DIFFUSE )\n    {\n        v = t.y == 2. ? ( t.x < 4. ? 1818324307u : ( t.x < 8. ? 1668489324u : ( t.x < 12. ? 543517793u : ( t.x < 16. ? 1935832435u : ( t.x < 20. ? 1634103925u : ( t.x < 24. ? 1931502947u : ( t.x < 28. ? 1953784163u : ( t.x < 32. ? 1852404325u : 8295u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1635087189u : ( t.x < 8. ? 981036140u : ( t.x < 12. ? 1835093024u : ( t.x < 16. ? 1953654114u : ( t.x < 20. ? 1146241568u : ( t.x < 24. ? 1713388102u : ( t.x < 28. ? 824196384u : ( t.x < 32. ? 543780911u : 0u ) ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 1702257960u : ( t.x < 8. ? 1914730866u : ( t.x < 12. ? 1696627041u : ( t.x < 16. ? 1937009016u : ( t.x < 20. ? 544106784u : ( t.x < 24. ? 1634869345u : ( t.x < 28. ? 1679844462u : ( t.x < 32. ? 2716265u : 0u ) ) ) ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 36. ? v : 0u;\n    }\n    if ( s.menuId == MENU_SPECULAR )\n    {\n        v = t.y == 8. ? ( t.x < 4. ? 1818649938u : ( t.x < 8. ? 1702126437u : ( t.x < 12. ? 1768693860u : ( t.x < 16. ? 779380839u : ( t.x < 20. ? 1970492704u : ( t.x < 24. ? 2037148769u : 8250u ) ) ) ) ) ) : v;\n        v = t.y == 7. ? ( t.x < 4. ? 1802465091u : ( t.x < 8. ? 1919898669u : ( t.x < 12. ? 1668178290u : ( t.x < 16. ? 1998597221u : ( t.x < 20. ? 1751345512u : ( t.x < 24. ? 1685024032u : 7564389u ) ) ) ) ) ) : v;\n        v = t.y == 6. ? ( t.x < 4. ? 1919117677u : ( t.x < 8. ? 1667327599u : ( t.x < 12. ? 544437349u : ( t.x < 16. ? 1919250472u : ( t.x < 20. ? 1952671078u : ( t.x < 24. ? 1919511840u : 544370546u ) ) ) ) ) ) : v;\n        v = t.y == 5. ? ( t.x < 4. ? 1734960488u : ( t.x < 8. ? 1634563176u : ( t.x < 12. ? 3811696u : 0u ) ) ) : v;\n        v = t.y == 4. ? ( t.x < 4. ? 745285734u : ( t.x < 8. ? 1178413430u : ( t.x < 12. ? 1747744296u : ( t.x < 16. ? 1814578985u : ( t.x < 20. ? 1747744300u : ( t.x < 24. ? 1747469353u : 41u ) ) ) ) ) ) : v;\n        v = t.y == 3. ? ( t.x < 4. ? 538976288u : ( t.x < 8. ? 538976288u : ( t.x < 12. ? 1848128544u : ( t.x < 16. ? 673803447u : ( t.x < 20. ? 695646062u : 0u ) ) ) ) ) : v;\n        v = t.y == 2. ? ( t.x < 4. ? 539828294u : ( t.x < 8. ? 1936028230u : ( t.x < 12. ? 7103854u : 0u ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 539828295u : ( t.x < 8. ? 1836016967u : ( t.x < 12. ? 2037544037u : 0u ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 539828292u : ( t.x < 8. ? 1953720644u : ( t.x < 12. ? 1969383794u : ( t.x < 16. ? 1852795252u : 0u ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 28. ? v : 0u;\n    }  \n    if ( s.menuId == MENU_DISTR )\n    {\n        v = t.y == 1. ? ( t.x < 4. ? 1702109252u : ( t.x < 8. ? 1679846770u : ( t.x < 12. ? 1852401253u : ( t.x < 16. ? 622883685u : ( t.x < 20. ? 543584032u : ( t.x < 24. ? 1919117677u : ( t.x < 28. ? 1667327599u : 544437349u ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 1818649970u : ( t.x < 8. ? 1769235301u : ( t.x < 12. ? 1814062958u : ( t.x < 16. ? 1952999273u : ( t.x < 20. ? 1919903264u : ( t.x < 24. ? 1730175264u : ( t.x < 28. ? 1852143209u : 1919509536u ) ) ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 32. ? v : 0u;\n    }\n    if ( s.menuId == MENU_FRESNEL )\n    {\n        v = t.y == 3. ? ( t.x < 4. ? 1702109254u : ( t.x < 8. ? 1679846770u : ( t.x < 12. ? 1852401253u : ( t.x < 16. ? 1629516645u : ( t.x < 20. ? 1853189997u : ( t.x < 24. ? 1718558836u : 32u ) ) ) ) ) ) : v;\n        v = t.y == 2. ? ( t.x < 4. ? 1818649970u : ( t.x < 8. ? 1702126437u : ( t.x < 12. ? 1768693860u : ( t.x < 16. ? 544499815u : ( t.x < 20. ? 544370534u : ( t.x < 24. ? 1768366177u : 544105846u ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1935832435u : ( t.x < 8. ? 1851880052u : ( t.x < 12. ? 539911523u : ( t.x < 16. ? 1629516873u : ( t.x < 20. ? 1869770864u : ( t.x < 24. ? 1701340001u : 3219571u ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 544370534u : ( t.x < 8. ? 2053206631u : ( t.x < 12. ? 543649385u : ( t.x < 16. ? 1818717793u : ( t.x < 20. ? 29541u : 0u ) ) ) ) ) : v;\n        v = t.x >= 0. && t.x < 28. ? v : 0u;\n    }\n    if ( s.menuId == MENU_GEOMETRY )\n    {\n        v = t.y == 2. ? ( t.x < 4. ? 1702109255u : ( t.x < 8. ? 1679846770u : ( t.x < 12. ? 1852401253u : ( t.x < 16. ? 1931506533u : ( t.x < 20. ? 1868849512u : ( t.x < 24. ? 1735289207u : ( t.x < 28. ? 543584032u : 0u ) ) ) ) ) ) ) : v;\n        v = t.y == 1. ? ( t.x < 4. ? 1919117677u : ( t.x < 8. ? 1667327599u : ( t.x < 12. ? 544437349u : ( t.x < 16. ? 1701864804u : ( t.x < 20. ? 1852400750u : ( t.x < 24. ? 1852776551u : ( t.x < 28. ? 1701344288u : 2126441u ) ) ) ) ) ) ) : v;\n        v = t.y == 0. ? ( t.x < 4. ? 1634890337u : ( t.x < 8. ? 1835362158u : ( t.x < 12. ? 7630437u : 0u ) ) ) : v;\n        v = t.x >= 0. && t.x < 32. ? v : 0u;\n    }\n\n    float c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    vec3 textColor = vec3( .3 );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .45 + .5;\n    float sdf = TextSDF( p, c );\n    if ( c != 0. )\n    {\n        color = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n\n    if ( s.menuId == MENU_SPECULAR )\n    {\n        color = mix( color, textColor, smoothstep( .05, -.05, Capsule( q.yx - vec2( -12.3, 48. ), .3, 26. ) ) );\n    }\n}\n\nvoid MenuText( inout vec3 color, vec2 p, in AppState s )\n{\n    p -= vec2( -160, -1 );\n    \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );\n    \n    float tab = 1.;\n    if ( t.y >= 6. && t.y < 10. )\n    {\n        p.x -= tab * scale.x;\n        t.x -= tab;\n    }\n    if ( t.y >= 0. && t.y < 5. )\n    {\n        p.x -= tab * scale.x;\n        t.x -= tab;\n    }\n    if ( t.y >= 0. && t.y < 3. )\n    {\n        p.x -= tab * scale.x;\n        t.x -= tab;\n    }    \n    \n    uint v = 0u;\n\tv = t.y == 10. ? ( t.x < 4. ? 1718777171u : ( t.x < 8. ? 6644577u : 0u ) ) : v;\n\tv = t.y == 9. ? ( t.x < 4. ? 1635018061u : ( t.x < 8. ? 108u : 0u ) ) : v;\n\tv = t.y == 8. ? ( t.x < 4. ? 1818585412u : ( t.x < 8. ? 1920230245u : 25449u ) ) : v;\n\tv = t.y == 7. ? ( t.x < 4. ? 1735749458u : ( t.x < 8. ? 1936027240u : 115u ) ) : v;\n\tv = t.y == 6. ? ( t.x < 4. ? 1702060354u : ( t.x < 8. ? 1819231008u : 29295u ) ) : v;\n\tv = t.y == 5. ? ( t.x < 4. ? 1751607628u : ( t.x < 8. ? 1735289204u : 0u ) ) : v;\n\tv = t.y == 4. ? ( t.x < 4. ? 1717987652u : ( t.x < 8. ? 6648693u : 0u ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 1667592275u : ( t.x < 8. ? 1918987381u : 0u ) ) : v;\n\tv = t.y == 2. ? ( t.x < 4. ? 1953720644u : ( t.x < 8. ? 1969383794u : 1852795252u ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1936028230u : ( t.x < 8. ? 7103854u : 0u ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1836016967u : ( t.x < 8. ? 2037544037u : 0u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    vec3 textColor = vec3( .3 );\n    if ( t.y == 10. - s.menuId )\n    {\n        textColor = vec3( 0.74, 0.5, 0.12 );\n\t}\n\n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .45 + .5;\n    float sdf = TextSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nvoid DrawMenuControls( inout vec3 color, vec2 p, in AppState s )\n{\n    p -= vec2( -110, 74 );\n    \n\t// radial\n    float c2 = Capsule( p - vec2( 0., -3.5 ), 3., 4. );\n    float c1 = Circle( p + vec2( 0., 7. - 7. * s.metal ), 2.5 );\n    \n    // roughness slider\n    p.y += 15.;\n    c1 = min( c1, Capsule( p.yx - vec2( 0., 20. ), 1., 20. ) );\n    c1 = min( c1, Circle( p - vec2( 40. * s.roughness, 0. ), 2.5 ) );\n        \n    p.y += 8.;\n    c1 = min( c1, Rectangle( p - vec2( 19.5, 0. ), vec2( 21.4, 4. ) ) );\n    color = mix( color, vec3( 0.9 ), Smooth( -c2 * 2. ) );\n\tcolor = mix( color, vec3( 0.3 ), Smooth( -c1 * 2. ) );\n\n    for ( int i = 0; i < 6; ++i )\n    {\n        vec2 o = vec2( i == int( s.baseColor ) ? 2.5 : 3.5 );\n    \tcolor = mix( color, BASE_COLORS[ i ], Smooth( -2. * Rectangle( p - vec2( 2. + float( i ) * 7., 0. ), o ) ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;    \n    p *= 100.;\n    \n    AppState s;\n    LoadState( s );  \n\n    vec3 color = vec3( 1., .98, .94 ) * mix( 1.0, 0.4, Smooth( abs( .5 - uv.y ) ) );\n    float vignette = q.x * q.y * ( 1.0 - q.x ) * ( 1.0 - q.y );\n    vignette = saturate( pow( 32.0 * vignette, 0.05 ) );\n    color *= vignette;\n    \n    DrawScene( color, p, s );\n\tDiagram( color, p, s );\n    InfoText( color, p, s );\n    MenuText( color, p, s );\n    DrawMenuControls( color, p, s );\n\n\tfragColor = vec4( color, 1. );\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 33,
            "src": "/presets/tex00.jpg",
            "ctype": "keyboard",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "// control loop\n\nconst float MENU_SURFACE    = 0.;\nconst float MENU_METAL      = 1.;\nconst float MENU_DIELECTRIC = 2.;\nconst float MENU_ROUGHNESS  = 3.;\nconst float MENU_BASE_COLOR = 4.;\nconst float MENU_LIGHTING   = 5.;\nconst float MENU_DIFFUSE    = 6.;\nconst float MENU_SPECULAR   = 7.;\nconst float MENU_DISTR      = 8.;\nconst float MENU_FRESNEL    = 9.;\nconst float MENU_GEOMETRY   = 10.;\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ    = 2.;\nconst float FOCUS_COLOR  = 3.;\n\nstruct AppState\n{\n    float\tmenuId;\n    float\tmetal;    \n    float   roughness;\n    float   baseColor;\n    float   focus;\n    float   focusObjRot;\n    float   objRot;\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}\n\nvoid LoadState( out AppState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.menuId    = data.x;\n    s.metal     = data.y;\n    s.roughness = data.z;\n    s.baseColor = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.focus     \t= data.x;\n    s.focusObjRot\t= data.y;\n    s.objRot    \t= data.z;\n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nvec4 SaveState( in AppState s, in vec2 fragCoord )\n{\n    vec4 ret = vec4( 0. );\n    StoreValue( vec2( 0., 0. ), vec4( s.menuId, s.metal, s.roughness, s.baseColor ), ret, fragCoord );\n    StoreValue( vec2( 1., 0. ), vec4( s.focus, s.focusObjRot, s.objRot, 0. ), ret, fragCoord );\n    ret = iFrame >= 1 ? ret : vec4( 0. );\n    return ret;\n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {\n\t\tdiscard;    \n    }\n\n    AppState s;\n    LoadState( s );\n    \n\tvec4 q = iMouse / iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n\tm.xz *= iResolution.x / iResolution.y;    \n    m *= 100.;    \n\n    vec4 sliderM = m - vec2( -110, 74 ).xyxy;\n    if ( sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10. )\n    {\n        s.focus = FOCUS_SLIDER;\n    }\n    else if ( sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -30. && sliderM.w < -20. )\n    {\n        s.focus = FOCUS_COLOR;\n    }    \n    else if ( sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -10. && sliderM.w < -4. )\n    {\n        s.metal = 0.;\n        s.menuId = s.menuId == MENU_METAL ? MENU_DIELECTRIC : s.menuId;\n    }\n    else if ( sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -4. && sliderM.w < 6. )\n    {\n        s.metal = 1.;\n        s.menuId = s.menuId == MENU_DIELECTRIC ? MENU_METAL : s.menuId;\n    }    \n    else if ( m.w > -100. && m.w < 40. && abs( m.z + 20. ) < 70. )\n    {\n        if ( s.focus != FOCUS_OBJ )\n        {\n            s.focusObjRot = s.objRot; \n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n\t\ts.focus = 0.;\n    \tvec2 mp = ( m.xy - vec2( -160, -1 ) );\n    \tfloat menuId = mp.x < 40. || ( mp.x < 60. && ( mp.y > 18. && mp.y < 24. ) ) ? 10. - floor( mp.y / 8. ) : -1.;\n        if ( menuId >= 0. && menuId <= 10. )\n        {\n            s.menuId = menuId;\n        }\n        s.metal = menuId == MENU_METAL      ? 1. : s.metal;\n        s.metal = menuId == MENU_DIELECTRIC ? 0. : s.metal;\n    }\n\n    if ( s.focus == FOCUS_SLIDER )\n    {\n    \ts.roughness = saturate( sliderM.x / 40. );    \n    }\n    if ( s.focus == FOCUS_COLOR )\n    {\n    \ts.baseColor = floor( clamp( ( sliderM.x * 5. ) / 32., 0., 5. ) );\n    }    \n    if ( s.focus == FOCUS_OBJ )\n    {\n        s.objRot = s.focusObjRot + .04 * ( m.x - m.z );\n    }\n    \n    fragColor = SaveState( s, fragCoord );\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}