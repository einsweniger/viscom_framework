{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "lstczM",
      "date": "1518290588",
      "viewed": 201,
      "name": "winter sports championship",
      "username": "teriyaki",
      "description": "sosumi",
      "likes": 2,
      "published": 3,
      "flags": 0,
      "tags": [
        "winter",
        "sports"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "#define      PI 3.14159265358979323846264338327950288419716939937511 // mm pie\n#define     TAU 6.28318530717958647692528676655900576839433879875021 // pi * 2\n#define HALF_PI 1.57079632679489661923132169163975144209858469968755 // pi / 2\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.) + 1.) * x);\n}\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p = permute( permute( i.y + vec3(0., i1.y, 1. )) + i.x + vec3(0., i1.x, 1. ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2. * fract(p * C.www) - 1.;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - .85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130. * dot(m, g);\n}\n\n// \u00cd\u00f1igo Qu\u00edlez\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat circle(vec2 uv, vec2 offset, float radius, float noiseishness) {\n  uv -= offset;\n  vec2 pq = vec2(atan(uv.x, uv.y), length(uv));\n  pq.x = pq.x / TAU + .5;\n  float r = radius + snoise(uv + offset + iTime * .21) * noiseishness;\n  float s = 3. / iResolution.y;\n  float t = 1. - sqrt(1. - r*r);\n  return smoothstep(r + s, r - s, pq.y) + smoothstep(r + t, r - t, pq.y);\n}\n\nfloat ring(vec2 uv, vec2 offset, float radius, float noiseishness) {\n  float c0 = circle(uv, offset, radius, noiseishness);\n  float c1 = circle(uv, offset, radius * .84, noiseishness);\n  return c0 - c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n  float n = .0171;\n  float r = .34;\n  float r0 = ring(uv, vec2(-.72, .18), r, n);\n  float r1 = ring(uv, vec2(-.362, -.18), r, n);\n  float r2 = ring(uv, vec2(0., .18), r, n);\n  float r3 = ring(uv, vec2(.362, -.18), r, n);\n  float r4 = ring(uv, vec2(.72, .18), r, n);\n  float m = r0 + r1 + r2 + r3 + r4;\n  float h = atan(uv.x, uv.y) / TAU + .5 - iTime * .1;\n  vec3 col = hsv2rgb(vec3(uv.y * .21 + .66, 1., 1.));\n  fragColor = vec4(col, 1.) * m;\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}