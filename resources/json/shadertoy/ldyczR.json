{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "ldyczR",
      "date": "1520804680",
      "viewed": 177,
      "name": "Fun With Metaballs",
      "username": "BeardThings",
      "description": "This shader was really simple to make but also a lot of fun so I figured I'd share it!",
      "likes": 2,
      "published": 3,
      "flags": 0,
      "tags": [
        "procedural",
        "metaballs",
        "refraction",
        "fun"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 26,
            "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
            "ctype": "cubemap",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Links:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nvec3 Translate(in vec3 p, in vec3 t)\n{\n    return p - t;\n}\n\nfloat Sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\n// Add two shapes together\nfloat Append(in float l, in float r)\n{\n    return min(l, r);\n}\n\n// This is where the magic happens\nfloat SDF(in vec3 p)\n{\n    float s1 = Sphere(Translate(p, vec3(sin(iTime + 4.4321) * 0.5, 0.0, cos(iTime) * 0.3)), 0.3 + sin(iTime)* 0.05);\n    float s2 = Sphere(Translate(p, vec3(cos(iTime + 1.3221131) * 0.5, 0.0, sin(iTime * 1.1) * 0.5)), 0.3 + cos(iTime) * 0.05);\n    float k = 50.0 + sin(iTime) * 5.0;\n    return -log(exp(s1 * -k) + exp(s2 * -k)) / k;\n}\n\nvec3 Norm(in vec3 p)\n{\n    // Calculate the normal by calculating the gradient of the SDF\n    const float E = 0.01;\n    return normalize(vec3(\n        SDF(p + vec3(E, 0, 0)) - SDF(p - vec3(E, 0, 0)),\n        SDF(p + vec3(0, E, 0)) - SDF(p - vec3(0, E, 0)),\n        SDF(p + vec3(0, 0, E)) - SDF(p - vec3(0, 0, E))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenSpace = uv * 2.0 - 1.0;\n    \n    // Origin, move this around for fun ^.^\n    vec3 o = vec3(cos(iTime * 0.05) * 1.5, 0.0, sin(iTime * 0.05) * 1.5);\n    \n    // Create your view basis vectors however you'd like\n    vec3 f = -normalize(o);\n    vec3 u = vec3(0, 1.0, 0);\n    vec3 r = normalize(cross(u, f));\n    \n    float aspect = iResolution.y / iResolution.x;\n    float aperture = 1.0;\n    \n    // Have our forward with an aperture at 1.0 \n    // and transform our vector by it's space on the screen\n    vec3 dir = normalize(f * aperture + r * screenSpace.x + u * screenSpace.y * aspect);\n    \n    // Max step of 16 is fine for a sphere, can be higher for complex scenes\n    const int MaxSteps = 64;\n    \n    // Our final color\n    vec3 fc = texture(iChannel0, dir).rgb * 0.2;\n    \n    float dist = 0.0;\n    for(int i = 0; i < MaxSteps; ++i)\n    {\n        vec3 p = o + dir * dist;\n        float sdf = SDF(p);\n        \n        // If we're close enough to the surface, then count it as \"reached\"\n        const float E = 0.001;\n        if(sdf < E)\n        {\n            vec3 n = Norm(p);\n            \n            vec3 refracted = refract(dir, n, 1.0 / 1.22);\n            vec3 reflectedColor = texture(iChannel0, refracted).rgb;\n            \n            float edge = pow(max(1.0 - dot(-dir, n), 0.0), 1.5 + reflectedColor.g * 10.0);\n            \n            vec3 diff = mix(reflectedColor * 0.7, vec3(0.1, 0.7, 0.2), 0.1);\n            vec3 rim = vec3(0.2 + sin(iTime * 0.7 + 0.54) * 0.2, 0.9, 0.4 + sin(iTime + 321.4321) * 0.1) * edge * 2.0;\n            \n            vec3 h = normalize(-dir + normalize(vec3(-1.0, 0.7, 0.0) - p));\n            vec3 spec = vec3(0.1, 0.7, 0.2) * pow(max(dot(h, n), 0.0), 10.0) * 1.0;\n            \n            fc = diff + spec * 0.2 + rim;\n            break;\n        }\n        dist += sdf;\n    }\n    \n    fragColor = vec4(fc, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}