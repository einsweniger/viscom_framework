{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "Xs3fWr",
      "date": "1524623596",
      "viewed": 72,
      "name": "Surfer Worms",
      "username": "MadEqua",
      "description": "Playing with voronoi cells and sound.",
      "likes": 0,
      "published": 3,
      "flags": 0,
      "tags": [
        "voronoi",
        "waves",
        "sound"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 19,
            "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
            "ctype": "music",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "const float PI = 3.141519;\nconst float TWO_PI = PI * 2.0;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from I\u00f1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvec2 rotate2D(float angle, vec2 uv, vec2 pivot)\n{\n    vec2 newUv = uv - pivot;\n\n    newUv = mat2(cos(angle), -sin(angle), \n                sin(angle), cos(angle)) * newUv;\n    return newUv + pivot;\n}\n\nvec2 scale(vec2 scale, vec2 uv, vec2 pivot)\n{\n\tvec2 newUv = uv - pivot;\n    newUv = mat2(scale.x, 0.0,\n                0.0, scale.y) * newUv;\n    return newUv + pivot;\n}\n\nfloat fetchFft(int start, int end, float power)\n{\n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n   \tfloat fft = 0.0;\n    for(int i = start; i <= end; ++i)\n         fft += texelFetch(iChannel0, ivec2(i, 0), 0).x;\n    return pow(fft / float(end - start + 1), power);\n}\n\nfloat bass()\n{\n    return fetchFft(2, 5, 30.0);\n}\n\nfloat deepBass()\n{\n    return fetchFft(0, 2, 5.0);\n}\n\nfloat high()\n{\n    return fetchFft(250, 350, 1.0);\n}\n\nfloat voronoi(vec2 uv, vec2 size)\n{\n    vec2 iPos = floor(uv);\n    //vec2 fPos = fract(uv);\n    \n    float minDist = 2.0;\n    vec2 closestPoint = vec2(0.0);\n    \n    for(int x = -1; x <= 1; ++x)\n        for(int y = -1; y <= 1; ++y)\n        {\n            vec2 iNeighbour = iPos + vec2(x, y);  \n            vec2 neighbourPoint;\n            \n            neighbourPoint.x = abs(sin(0.6 * iTime + distance(size/2.0, uv)));\n            neighbourPoint.y = abs(sin(0.6 * iTime + 0.5 * distance(size/2.0, uv)));\n            \n            const float HIGH_K = 0.6;\n            neighbourPoint.x += HIGH_K * (high() - 0.5);\n            neighbourPoint.y += HIGH_K * (high() - 0.5);\n            \n            float dist = distance(uv, iNeighbour + neighbourPoint);           \n            if(dist < minDist)\n            {\n                minDist = dist;\n                closestPoint = iNeighbour + neighbourPoint;\n            }            \n        }\n    \n    return minDist + (1.0 - smoothstep(0.07, 0.15, distance(uv, closestPoint)));\n    //return smoothstep(0.1, 0.8, minDist) + (1.0 - smoothstep(0.04, 0.11, distance(uv, closestPoint)));\n}\n\nfloat borderLight(vec2 uv, vec2 size)\n{\n    float d = distance(uv, size * 0.5);\n    return smoothstep(0.7, 1.0, d);\n}\n\nfloat centerLight(vec2 uv, vec2 size)\n{\n    float d = distance(uv, size * 0.5);\n    return 1.0 - smoothstep(0.0, 0.6, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 center = vec2(0.5) * vec2(ratio, 1.0);\n    uv = rotate2D(pow(sin(0.013 * deepBass() + iTime * 0.15), 6.0) * TWO_PI, uv, center);\n    \n    vec2 scaledUv = scale(1.6 + 0.6 * sin(vec2(0.3 * iTime + deepBass() * 0.5)), uv, center);\n    \n    const vec2 TILES = vec2(15.0);\n    scaledUv *= TILES;\n    \n    vec2 size = TILES * vec2(ratio, 1.0);\n    \n    const float SHADOW_DEPTH = 0.08;\n    vec2 shadowDisp = vec2(sin(iTime), cos(iTime)) * SHADOW_DEPTH;\n    \n    float v1 = voronoi(scaledUv, size);\n    float v2 = voronoi(scaledUv + shadowDisp, size);\n         \n    vec3 G = rgb2hsb(vec3(0.0, 255.0, 39.0) / vec3(255.0));\n    vec3 B = rgb2hsb(vec3(10.0, 25.0, 255.0) / vec3(255.0));\n    vec3 W = rgb2hsb(vec3(1.0));\n    vec3 Y = rgb2hsb(vec3(204.0, 115.0, 20.0) / vec3(255.0));\n       \n    vec3 mix1 = mix(G, Y, 0.5 + 0.5 * sin(0.5 * iTime - 6.0 * distance(uv, center)));\n    vec3 mix2 = mix(Y, B, 0.5 + 0.5 * sin(0.7 * iTime - 8.0 * distance(uv, center)));\n    vec3 finalMix = mix(mix1, mix2, 0.5 + 0.5 * sin(iTime * 0.5));\n    \n    vec3 col = vec3(0.0);    \n\tcol = mix(finalMix, col, pow(v1, 0.4 + bass()));\n    col = mix(col, W, v2 * v2);\n    \n    const float HIGHLIGHT_K = 0.35;\n    col.z += HIGHLIGHT_K * bass() * borderLight(uv, vec2(ratio, 1.0));\n    col.z += HIGHLIGHT_K * bass() * centerLight(uv, vec2(ratio, 1.0));\n    \n    col = hsb2rgb(col);\n    col = pow(col, vec3(1.5 + bass()));\n        \n    fragColor = vec4(col, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}