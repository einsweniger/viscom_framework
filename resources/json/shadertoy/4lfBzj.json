{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4lfBzj",
      "date": "1512425931",
      "viewed": 253,
      "name": "Inversions",
      "username": "mla",
      "description": "12 spheres in an icosahedral arrangement, inverted in a sphere.\n\nThe mouse controls the centre of inversion.",
      "likes": 5,
      "published": 3,
      "flags": 1,
      "tags": [
        "spheres",
        "raytrace",
        "inversion"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "struct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n  vec3 color;\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n  vec3 color;\n};\n\nbool invert = true;\n\nSphere invertSphere(Sphere s) {\n  // Use mouse position to determine centre of inversion (for x and y)\n  vec3 icentre = vec3(0.5,0.0,-1.25);\n  // On startup iMouse.x = iMouse.y = 0\n  if (iMouse.x > 0.0) {\n      icentre = vec3(3.0*(iMouse.x-0.5*iResolution.x)/iResolution.x,\n                      3.0*(iMouse.y-0.5*iResolution.y)/iResolution.y,\n                      -1.25);\n    }\n  // Shift origin to sphere centre\n  vec3 p = s.p - icentre;\n  float r = s.r;\n  float c = length(p);\n  // This inverts the sphere (in the origin).\n  float k = 1.0/((c+r)*(c-r));\n  // Shift back\n  return Sphere(r*k, p*k+icentre, s.color);\n}\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r, s.color);\n  return true;\n}\n\nvec3 vertices[12];\nint colors[12];\nvoid setVertices() {\n  float phi = 0.80902;\n  // Three golden rectangle, oriented to\n  // the three axes. \n  vertices[0] = vec3( 0.5, phi,0); //++0 A\n  vertices[1] = vec3( 0.5,-phi,0); //+-0 B\n  vertices[2] = vec3(-0.5, phi,0); //-+0 C\n  vertices[3] = vec3(-0.5,-phi,0); //--0 D\n\n  vertices[4] = vec3(0, 0.5, phi); //0++ B\n  vertices[5] = vec3(0, 0.5,-phi); //0+- D\n  vertices[6] = vec3(0,-0.5, phi); //0-+ C\n  vertices[7] = vec3(0,-0.5,-phi); //0-- A\n\n  vertices[8]  = vec3( phi,0, 0.5); //+0+ D\n  vertices[9]  = vec3( phi,0,-0.5); //+0- C\n  vertices[10] = vec3(-phi,0, 0.5); //-0+ A\n  vertices[11] = vec3(-phi,0,-0.5); //-0- B\n\n  // A nice 4-coloring of icosahedron vertices\n  colors[0] = colors[7] = colors[10] = 0;\n  colors[1] = colors[4] = colors[11] = 1;\n  colors[2] = colors[6] = colors[9] = 2;\n  colors[3] = colors[5] = colors[8] = 3;\n}\n\nvec3 getColor(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(0,1,0);\n  if (i == 3) return vec3(0,0,1);\n  return vec3(1,1,1);\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  float t = 0.5*iTime;\n  mat3 m = mat3(cos(t),0,sin(t),\n                0,1,0,\n                -sin(t),0,cos(t));\n  setVertices();\n  bool found = false;\n  for (int i = 0; i < 12; i++) {\n    Sphere s = Sphere(0.5, m*vertices[i], getColor(colors[i]));\n    Hit hits;\n    if (invert) s = invertSphere(s);\n    if (intersectSphere(s,r,hits) && (!found || hits.t < hit.t)) {\n      hit = hits;\n      found = true;\n    }\n  }\n  return found;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec4 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = hit.color;\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord,\n             in vec3 fragRayOrigin, in vec3 fragRayDir) {\n  fragColor = solve(Ray(fragRayOrigin,fragRayDir));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0,0,-6.0);\n  // \"screen\" coordinate\n  vec3 s = vec3(iResolution.x/iResolution.y * uv.x, uv.y, 0);\n  vec3 d = normalize(s-p); // Direction from camera to screen point\n  mainVR(fragColor,fragCoord,p,d);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}