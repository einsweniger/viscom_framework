{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "XsfyRr",
      "date": "1486635345",
      "viewed": 627,
      "name": "pull/push reconstruction",
      "username": "hornet",
      "description": "Calcs a subset of pixels, then interpolates the scattered data using (two levels of) mipmaps.\nLMB to control discard, right side to see full.\nbufA: image | bufB,C: mip pull downsampling | bufD/Image: push upsampling",
      "likes": 11,
      "published": 3,
      "flags": 32,
      "tags": [
        "interpolation",
        "upsampling",
        "pushpull",
        "scattereddata"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 260,
            "src": "/media/previz/buffer03.png",
            "ctype": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "//\n// push-upsample 2/2 (and output)\n//\n\nvoid gather4rgba( in sampler2D sampler, in vec2 uv, in vec2 texsiz, \n              \t  out vec4 c0, out vec4 c1, out vec4 c2, out vec4 c3 )\n{\n    vec2 ctr = (floor(uv * texsiz) + vec2(0.5,0.5)) / texsiz;\n    vec2 ofs = (step(ctr,uv)*2.0-1.0) / texsiz;\n    vec2 uv0 = ctr;\n    vec2 uv1 = ctr + vec2(ofs.x, 0.0);\n    vec2 uv2 = ctr + vec2(0.0, ofs.y);\n    vec2 uv3 = ctr + ofs;\n    c0 = texture( sampler, uv0 );\n    c1 = texture( sampler, uv1 );\n    c2 = texture( sampler, uv2 );\n    c3 = texture( sampler, uv3 );\n}\n\n//note: bilinear weights are constant since ordering is constant\nconst vec4 upsample_w = vec4(9.0/16.0, 3.0/16.0, 3.0/16.0, 1.0/16.0);\n       \n\nvec3 lin2srgb( vec3 c ) { return pow(c,vec3(1.0/2.4)); }\nvec3 srgb2lin( vec3 c ) { return pow(c,vec3(    2.4)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // DBG\n    //fragColor = vec4( lin2srgb( texture( iChannel0, fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n   \t//fragColor = vec4( lin2srgb( texture( iChannel1, 0.5*fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n    //fragColor = vec4( lin2srgb( texture( iChannel2, 0.25 * fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n    //fragColor = vec4( lin2srgb( texture( iChannel3, 0.5 * fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n    \n    if ( iMouse.z < 0.5 && fragCoord.x > iResolution.x / 2.0 )\n    {\n        fragColor = vec4( lin2srgb( texture( iChannel0, fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n        return;\n    }\n    \n    if ( iMouse.z > 0.5 && iMouse.x / iResolution.x > 0.5 )\n    {\n        fragColor = vec4( lin2srgb( texture( iChannel0, fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n        return;\n    }\n    \n    vec2 uv0 = fragCoord.xy / iChannelResolution[0].xy;\n    vec4 c0 = texture( iChannel0, uv0 );\n    if ( c0.a > 0.0 )\n    {\n        //note: base-alpha always 0 or 1, so return immediately\n        fragColor = c0;\n    }\n\telse\n    {\n        vec2 uv3 = 0.5 * fragCoord.xy / iChannelResolution[3].xy;\n        vec4 g[4];\n        gather4rgba( iChannel3, uv3, iChannelResolution[3].xy, g[0], g[1], g[2], g[3] );\n\n        g[0].a *= upsample_w[0];\n    \tg[1].a *= upsample_w[1];\n    \tg[2].a *= upsample_w[2];\n    \tg[3].a *= upsample_w[3];\n    \tvec4 c = vec4( g[0].rgb * g[0].a +\n\t             \t   g[1].rgb * g[1].a +\n    \t         \t   g[2].rgb * g[2].a +\n\t                   g[3].rgb * g[3].a,\n\t                   g[0].a + g[1].a + g[2].a + g[3].a );\n        if ( c.a > 0.0 )\n        {\n    \t\tc.rgb /= c.a;\n            //fragColor = mix( c, c0, min(1.0,c0.a) );\n            fragColor = c; //note: base-alpha always 0 or 1\n        }\n        else\n            fragColor = c0; //...zero\n    }    \n    fragColor = vec4( lin2srgb(fragColor.rgb), 1.0 );\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 17,
            "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
            "ctype": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 28,
            "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
            "ctype": "texture",
            "channel": 2,
            "sampler": {
              "filter": "nearest",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 29,
            "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv",
            "ctype": "video",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "//\n// Input image generation (and decimation)\n//\n\nvec4 lin2srgb( vec4 c ) { return pow(c,vec4(1.0/2.4)); }\nvec4 srgb2lin( vec4 c ) { return pow(c,vec4(    2.4)); }\n\nconst float cyclet = 12.0;\nconst float checkerduration =  3.0;\n\nvec4 anim_pattern( vec2 in_uv, float aspect )\n{\n        vec2 uv = in_uv * vec2(aspect, 1.0) * 3.0;\n        float t = 0.05 * iTime;\n        vec2 r = vec2( cos(t), sin(t) );\n        uv -= vec2(0.5);\n        uv =  vec2( dot(r, uv), dot(vec2(-r.y, r.x), uv ) );\n        uv += vec2(0.5);\n    \tvec4 c = vec4( texture( iChannel2, uv ).xxx, 1.0 );\n    \n    \t//note: timer\n        if ( in_uv.y < 0.0125 ) \n        {\n            float t = (checkerduration - mod(iTime, cyclet)) / checkerduration;\n            if ( in_uv.x < t )\n            {\n                c = vec4(1,0,0,1);\n            }\n        }\n\t\n        return c;\n}\n\nvec4 renderImage( vec2 uv )\n{\n    float modt = mod(iTime, cyclet);\n    if ( modt < checkerduration )\n    {\n        return anim_pattern( uv, iResolution.x/iResolution.y );\n    }\n    else if ( modt < 2.0 * checkerduration )\n\n    {\n        float t = iTime;\n        vec3 c = 0.5 + 0.5 * vec3( cos(0.39*t), sin(0.81*t), sin(0.83*t) );\n        \n    \t//note: timer\n        if ( uv.y < 0.0125 ) \n        {\n            float t = (2.0*checkerduration - modt) / (2.0*checkerduration);\n            if ( uv.x < t )\n                return vec4(1,0,0,1);\n        }\n        return vec4( c * (0.5 + 0.5*sin( 21.0*uv.y + 11.0*uv.x + 0.75*sin(11.0*uv.x + 4.1*t) )), 1.0 );\n    }\n\telse\n    {\n\t\tvec4 c = vec4( srgb2lin( texture(iChannel0, uv ) ).rgb, 1.0 );\n        \n        //note: timer\n        if ( uv.y < 0.0125 ) \n        {\n            float t = 1.0 - (modt-2.0*checkerduration) / (cyclet-2.0*checkerduration);\n            if ( uv.x < t ) c = vec4(1,0,0,1);\n        }\n\t\treturn c;\n    }\n\n}\n\nvoid img( out vec4 fragColor, in vec2 uv_nm )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = uv_nm * vec2( aspect, 1.0 );\n    \n    vec2 ctr = vec2(0.5*aspect, 0.5 );\n    float r = 0.9 * length(uv - ctr);\n    \n    float bias = (iMouse.z>0.5) ? iMouse.y / iResolution.y : 0.65;\n    r = max( 0.0, r);\n\tfloat importance = r / ((1.0 / bias - 2.0) * (1.0 - r) + 1.0);\n \n    float rnd = textureLod( iChannel1, uv_nm*iResolution.xy/iChannelResolution[1].xy, 0.0 ).x;\n    //float rnd = textureLod( iChannel1, uv_nm*iResolution.xy/iChannelResolution[1].xy + 83.0*fract(1227.0*iTime), 0.0 ).x;\n    bool doDiscard = rnd < importance;\n    \n    //float bayer = texture( iChannel2, uv_nm*iResolution.xy/iChannelResolution[2].xy, -10.0 ).x;\n    //bool doDiscard = bayer < importance;\n    \n    \n    \n    if( doDiscard )\n    {\n\t\tfragColor = vec4(0.0); //note: float-buffer\n    }\n\telse\n    \tfragColor = renderImage( uv_nm );\n    \n    if ( (uv_nm.x < 0.006125 || uv_nm.x > 0.99875) && abs(uv_nm.y-bias)<0.0125 )\n    \tfragColor = vec4(0.06125,0.125,0.7,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_nm = fragCoord.xy / iResolution.xy;\n\timg( fragColor, uv_nm );\n}\n",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 258,
            "channel": 0
          }
        ],
        "code": "//\n// pull-downsample 1/2\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iChannelResolution[0].xy;\n    if ( uv.x > 1.0 || uv.y > 1.0 ) { fragColor = vec4(0.0); return; }\n    \n    //note: manual samples for each texel\n    vec2 ofs = vec2(0.5) / iChannelResolution[0].xy;\n    vec4 c0 = texture( iChannel0, uv + vec2( -ofs.x,  ofs.y) );\n    vec4 c1 = texture( iChannel0, uv + vec2(  ofs.x, -ofs.y) );\n    vec4 c2 = texture( iChannel0, uv + vec2(  ofs.x,  ofs.y) );\n    vec4 c3 = texture( iChannel0, uv + vec2( -ofs.x, -ofs.y) );\n    \n    //note: initial pass does not have to deal with weights!={0,1}\n    vec4 c = vec4(0.0);\n    c.a = c0.a + c1.a + c2.a + c3.a;\n    if ( c.a > 0.0 )\n    {\n        c.rgb += c0.rgb * c0.a;\n        c.rgb += c1.rgb * c1.a;\n        c.rgb += c2.rgb * c2.a;\n        c.rgb += c3.rgb * c3.a;\n        c.rgb /= c.a; //TODO: postpone divide to later passes? http://wwwvis.informatik.uni-stuttgart.de/~kraus/preprints/vmv06_strengert.pdf\n    }\n    \n    fragColor = c;\n}\n",
        "name": "Buf B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 259,
            "channel": 0
          }
        ],
        "code": "//\n// pull-downsample 2/2\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iChannelResolution[0].xy;\n    if ( uv.x > 1.0 || uv.y > 1.0 ) { fragColor = vec4(0.0); return; }\n    \n    //note: manual samples for each texel\n    vec2 ofs = vec2(0.5) / iChannelResolution[0].xy;\n    vec4 c0 = texture( iChannel0, uv + vec2( -ofs.x,  ofs.y) );\n    vec4 c1 = texture( iChannel0, uv + vec2(  ofs.x, -ofs.y) );\n    vec4 c2 = texture( iChannel0, uv + vec2(  ofs.x,  ofs.y) );\n    vec4 c3 = texture( iChannel0, uv + vec2( -ofs.x, -ofs.y) );\n    \n    //note: average valid pixels\n    //\n    //note: clamping does not appear to be essential (possibly more in coarser passes)\n    //note: use \"optimized\" version with fewer calls to min()\n    //      https://wwwcg.in.tum.de/research/research/publications/2009/the-pull-push-algorithm-revisited.html\n    #define OPTIMIZED_CLAMP\n\n\t#if defined( OPTIMIZED_CLAMP )\n    vec4 w = vec4( c0.a, c1.a, c2.a, c3.a );\n    #else\n    vec4 w = vec4( min(1.0, c0.a), min(1.0, c1.a), min(1.0, c2.a), min(1.0, c3.a) );\n    #endif\n    \n    vec4 c = vec4(0.0);\n    float sumw = w[0] + w[1] + w[2] + w[3];\n    if ( sumw > 0.0 )\n    {\n        c.rgb += c0.rgb * w[0];\n        c.rgb += c1.rgb * w[1];\n        c.rgb += c2.rgb * w[2];\n        c.rgb += c3.rgb * w[3];\n        c.a = sumw;\n        #if defined( OPTIMIZED_CLAMP )\n        c.a = min( 1.0, c.a );\n        c.rgb = c.a / sumw * c.rgb;\n        #else\n        c.rgb /= c.a;\n        #endif\n    }\n    \n    fragColor = c;\n}\n",
        "name": "Buf C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 260,
            "channel": 0
          }
        ],
        "code": "//\n// push-upsample 1/2\n//\n\nvoid gather4rgba( in sampler2D sampler, in vec2 uv, in vec2 texsiz, \n              \t  out vec4 c0, out vec4 c1, out vec4 c2, out vec4 c3 )\n{\n    vec2 ctr = (floor(uv * texsiz) + vec2(0.5,0.5)) / texsiz;\n    vec2 ofs = (step(ctr,uv)*2.0-1.0) / texsiz;\n    vec2 uv0 = ctr;\n    vec2 uv1 = ctr + vec2(ofs.x, 0.0);\n    vec2 uv2 = ctr + vec2(0.0, ofs.y);\n    vec2 uv3 = ctr + ofs;\n    c0 = texture( sampler, uv0 );\n    c1 = texture( sampler, uv1 );\n    c2 = texture( sampler, uv2 );\n    c3 = texture( sampler, uv3 );\n}\n\n//note: bilinear weights are constant since ordering is constant\nconst vec4 upsample_w = vec4(9.0/16.0, 3.0/16.0, 3.0/16.0, 1.0/16.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec4 c0 = texture( iChannel0, uv0 );\n\n    vec2 uv1 = 0.5 * fragCoord.xy / iChannelResolution[1].xy;\n    vec4 g[4];\n    gather4rgba( iChannel1, uv1, iChannelResolution[1].xy, g[0], g[1], g[2], g[3] );\n    \n    g[0].a *= upsample_w[0];\n    g[1].a *= upsample_w[1];\n    g[2].a *= upsample_w[2];\n    g[3].a *= upsample_w[3];\n    vec4 c = vec4( g[0].rgb * g[0].a +\n             \t   g[1].rgb * g[1].a +\n             \t   g[2].rgb * g[2].a +\n                   g[3].rgb * g[3].a,\n                   g[0].a + g[1].a + g[2].a + g[3].a );\n    if ( c.a > 0.0 )\n    {\n        c.rgb /= c.a;\n        fragColor = mix( c, c0, min(1.0,c0.a) );\n    }\n    else\n        fragColor = c0;\n}\n",
        "name": "Buf D",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}