{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4llBDr",
      "date": "1511625661",
      "viewed": 194,
      "name": "Mutating Sierpinski",
      "username": "ttg",
      "description": "Fractal rule is mutated as each 3x3 division is performed.",
      "likes": 1,
      "published": 3,
      "flags": 32,
      "tags": [
        "fractal",
        "random",
        "generative",
        "genetic"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "/*\n\nMutating Sierpinski\nCopyright 2017 Theron Tarigo\n\nfractal, random, genetic, generative\n\nFractal rule is mutated as each 3x3 division is performed.\n\n*/\n\n// Passthrough to Buf B\nvoid mainImage( out vec4 f, in vec2 d ) { f = texelFetch(iChannel0, ivec2(d), 0); }\n",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 30,
            "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "/*\n\nMutating Sierpinski\nCopyright 2017 Theron Tarigo\n\nfractal, random, genetic, generative\n\nFractal rule is mutated as each 3x3 division is performed.\n\n*/\n\nvec4 rand(int i) {\n  if (i>256*256) return vec4(0.);\n  return texelFetch(iChannel0, ivec2(i/256,i%256),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  fragColor = vec4(0.);\n  fragCoord += rand((int(fragCoord.y*iResolution.x+iResolution.x)+iFrame)%(256*256)).xy;\n  vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x + 0.5;\n  float v = 1.;\n  if (uv.x<0. || uv.x>1. || uv.y<0. || uv.y>1.) return;\n\n  int[9] f = int[9](0,0,0,0,0,0,0,0,0);\n\n  int d = 0;\n  for (int i = 0; i <= 6; i++) {\n    ivec2 u = ivec2(mod(uv*pow(3.,float(i)),1.)*3.);\n    ivec2 ur = ivec2(uv*pow(3.,float(i))*3.);\n    for (int j = 0; j < 9; j++) {\n      vec4 r = rand(j+9*(32*ur.y+ur.x)+9*9*f[3*u.y+u.x]);\n      if (fract(r.x+iTime*0.01)<0.3/pow(3.,float(i)) ) f[j]+=int(r.y*4.0);\n      f[j] = f[j]%4;\n    }\n    int c = f[3*u.y+u.x];\n    int nd = d;\n    // This little state machine is probably\n    // not the best way to accomplish this\n    if (d==0 && c==3) nd=3;\n    if (d==3 && c==3) nd=0;\n    if (d==0 && c==1) nd=1;\n    if (d==0 && c==2) nd=2;\n    if (d==3 && c==1) nd=2;\n    if (d==3 && c==2) nd=1;\n    d = nd;\n  }\n  if (d==3) fragColor+=1.;\n}\n",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 258,
            "channel": 0
          }
        ],
        "code": "/*\n\nMutating Sierpinski\nCopyright 2017 Theron Tarigo\n\nfractal, random, genetic, generative\n\nFractal rule is mutated as each 3x3 division is performed.\n\n*/\n\nvoid mainImage( out vec4 f, in vec2 d ) {\n    vec4 f0 = texelFetch(iChannel0, ivec2(d), 0);\n    vec4 f1 = texelFetch(iChannel1, ivec2(d), 0);\n    f = mix(f1, f0, 0.002*vec4(1.,2.,3.,4.)*60.*iTimeDelta);\n    if (iMouse.w>0.) f = f0;\n}\n",
        "name": "Buf B",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}