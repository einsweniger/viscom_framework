{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4tSfzh",
      "date": "1514459297",
      "viewed": 311,
      "name": "EGGNOGG+",
      "username": "CaptCM74",
      "description": "[REUPLOADED]\nBased on EGGNOGG+, a NIDHOGG parody/fangame By MADGARDEN.\nhttps://madgarden.itch.io/eggnogg\n\n[Features]\n- Ear-rippin' BYTEBEAT music!\n(Because of texture size limit, The music suddenly stops :/)\n- A WASTE-OF-SPACEFUL binary-coded sprites!",
      "likes": 7,
      "published": 3,
      "flags": 8,
      "tags": [
        "sprite",
        "bytebeat"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 30,
            "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "/********************\n==========================\n\tEGGNOGGPLUS\n\tA shader by CaptCM74\n\t - Based on Madgarden's EGGNOGG+, a parody game of NIDHOGG.\n\t - Features some neat BYTEBEAT music.\n\t - Uses a lot of intergers to save the sprites into array ;-;\n\t - Anyway, you can use this code whatever you want. (But not the sprites for copyright issues.)\n==========================\n*********************/\n\n\n/* Player's Skin */\n\n//16 rows * 2 Frames = 32 indexes\nint playerSkin[32] = int[32](\n    //Frame 1\n    0x0,\n    0x540,\n    0x3E0,\n    0x3F0,\n    0x3F0,\n    0xC3F0,\n    0xC1F0,\n\t0x8C00,\n    0x7C00,\n    0x3000,\n    0x0,\n    0x0,\n    0x0,\n    0xC60,\n    0x6C0,\n    0xCE0,\n    //Frame 2\n    0x0,\n    0xA80,\n    0x7C0,\n    0x7E0,\n    0x7E0,\n    0x37E0,\n    0x33E0,\n    0x2400,\n    0x3C00,\n    0x1800,\n    0x0,\n    0x0,\n    0x0,\n    0xE70,\n    0xC30,\n    0x1838\n);\n\n/* Player's Tunic/Dress/Something */\nint playerOutfit[32] = int[32](\n    //Frame 1\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n\t0x3C0,\n    0x3C0,\n    0x380,\n    0x0,\n    0x7C0,\n    0xEE0,\n    0x0,\n    0x0,\n    0x0,\n    //Frame 2\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x380,\n    0x3C0,\n    0x380,\n    0x0,\n    0x3C0,\n    0x7E0,\n    0x0,\n    0x0,\n    0x0\n);\n\n/* Player's Eye n' Belt */\nint playerMisc[32] = int[32](\n    //Frame 1\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x90,\n    0x90,\n    0x0,\n\t0x0,\n    0x0,\n    0x0,\n    0x380,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    //Frame 2\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x120,\n    0x120,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x380,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0\n);\n\n/* Player Arm */\nint playerArm[] = int[16](\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0,\n\t0x118,\n    0x1F8,\n    0xE0,\n   \t0x0,\n    0x0,\n    0x0,\n    0x0,\n    0x0\n);\n\n/* Sword/Rapier */\nint blade[] = int[5](\n    0x0000,\n    0x0000,\n    0xFFF0,\n    0x0000,\n    0x0000\n);\nint misc[] = int[5](\n    0x4000,\n    0x6000,\n    0x6000,\n    0x6000,\n    0x4000\n);\n\nmat2 rotationMat(float angle)\n{\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 playerPixel(vec2 uv, vec2 pos, float size, vec3 skin, vec3 tunic, vec3 eye,int frame, int flip)\n{\n    vec4 fin = vec4(0.0);\n    \n    ivec2 currentPix = ivec2( (uv/size+pos)*16.0 );\n    //currentPix = 16 - currentPix;\n    \n    currentPix.y = 16 - currentPix.y;\n    if (flip == 0)\n    {\n        currentPix.x = 16 - currentPix.x;\n    }\n    \n    //arm\n    fin = mix(fin,vec4(vec3(skin),1.0), float((playerArm[currentPix.y] & (1 << currentPix.x)) >> currentPix.x) );\n    \n    //skin\n   \tfin = mix(fin,vec4(vec3(skin),1.0), float((playerSkin[(frame*16)+currentPix.y] & (1 << currentPix.x)) >> currentPix.x) );\n    //tunic\n    fin = mix(fin,vec4(vec3(tunic),1.0), float((playerOutfit[(frame*16)+currentPix.y] & (1 << currentPix.x)) >> currentPix.x) );\n    //EYEBAAAAAAALLLS\n    fin = mix(fin,vec4(vec3(eye),1.0), float((playerMisc[(frame*16)+currentPix.y] & (1 << currentPix.x)) >> currentPix.x) );\n    \n    if (currentPix.x > 15 || currentPix.x < 0 || currentPix.y > 15 || currentPix.y < 0)\n    {\n        fin = vec4(0.0);\n    }\n    \n    int swordX = currentPix.x+13;\n\tint swordY = currentPix.y-6;\n    \n    float miscPix;\n    float bladePix;\n    if (flip == 0)\n    {\n        // Blade\n        bladePix = float((blade[swordY] & (1 << (swordX))) >> (swordX));\n        // Misc\n        miscPix = float((misc[swordY] & (1 << (swordX))) >> (swordX));\n    }\n    else\n    {\n        currentPix = ivec2( (uv/size+pos-vec2(0.25,0.0))*16.0 );\n        swordX = currentPix.x+16;\n        \n        // Blade\n        bladePix = float((blade[swordY] & (1 << swordX)) >> swordX);\n        // Misc\n        miscPix = float((misc[swordY] & (1 << (swordX))) >> (swordX));\n    }\n    \n    \n    if (swordX > 15 || swordX < 0 || swordY >= 5 || swordY < 0)\n    {\n        bladePix = 0.0;\n        miscPix = 0.0;\n    }\n    \n    // Blade\n    if (swordX < 15) // Blade gradient\n    {\n\t\tfin = mix(fin,vec4(vec3(float(8-swordX/2)/8.0)+0.3,1.0), bladePix );\n    }\n    else // Green handle\n    {\n        fin = mix(fin,vec4(0.0, 0.25, 0.0, 1.0), bladePix );\n    }\n    \n    // Misc\n    // or Hand-protecter\n    if (sin(float(swordY+swordX+15)*0.9) > 0.9) // Yellow shine\n    {\n        fin = mix(fin,vec4(vec3(1.0, 1.0, 0.0), 1.0), miscPix );\n    }\n    else\n    {\n        fin = mix(fin,vec4(vec3(1.0, 0.49, 0.0), 1.0), miscPix );\n    }\n    \n    return fin;\n}\n\nvec4 playerTwo (vec2 uv,float time)\n{\n    vec4 finalCol = vec4(0.0);\n    vec3 shadowColour = vec3(0.4,0.35,0.25);\n \n    float delta = time*0.9;\n\t//uv.x = 1.0 - uv.x;\n    \n    /*Player one*/\n    int frame = 1;\n    if (cos(delta * 12.0) >= 0.0)\n    {\n        frame = 0;\n    }\n    \n    vec2 p2Pos = vec2( (-4.5) + cos(delta * 12.0)*0.1 , (-1.0) + (max(sin(delta * 24.0), 0.0) * -0.15));\n    \n    //Skin colour\n    vec3 p2Skin = vec3(1.0,0.0,0.0);\n    //Outfit colour\n    vec3 p2Tunic = vec3(0.0,1.0,1.0);\n    //Misc\n    vec3 p2Misc = p2Skin * 0.1;\n    \n    vec4 p2 = playerPixel(uv, p2Pos, 0.3, p2Skin, p2Tunic, p2Misc, frame, 1);\n    //vec4 p1Shadow = playerPixel(uv, p1Pos + vec2(-1.0,1.0), 100.0, shadowColour, shadowColour, shadowColour,1);\n\t\n    //finalCol = mix(finalCol, p1Shadow, p1Shadow.a);\n    finalCol = mix(finalCol, p2, p2.a);\n    \n    return finalCol;\n}\n\nvec4 playerOne (vec2 uv,float time)\n{\n    vec4 finalCol = vec4(0.0);\n    vec3 shadowColour = vec3(0.4,0.35,0.25);\n \n    float delta = time*0.9;\n    \n    /*Player one*/\n    int frame = 1;\n    if (cos(delta * 12.0) >= 0.0)\n    {\n        frame = 0;\n    }\n    \n    vec2 p1Pos = vec2( (-0.3) + cos(delta * 12.0)*0.1 , (-1.0) + (max(sin(delta * 24.0), 0.0) * -0.15));\n        //vec2( (-0.3) + cos(delta * 12.0)*0.1 , (-1.0) + (abs(sin(delta * 12.0)) * -0.15));\n    \n    //Skin colour\n    vec3 p1Skin = vec3(1.0,1.0,0.0);\n    //Outfit colour\n    vec3 p1Tunic = vec3(0.0,1.0,0.0);\n    //Misc\n    vec3 p1Misc = p1Skin * 0.1;\n    \n    vec4 p1 = playerPixel(uv, p1Pos, 0.3, p1Skin, p1Tunic, p1Misc, frame, 0);\n    //vec4 p1Shadow = playerPixel(uv, p1Pos + vec2(-1.0,1.0), 100.0, shadowColour, shadowColour, shadowColour,1);\n\t\n    //finalCol = mix(finalCol, p1Shadow, p1Shadow.a);\n    finalCol = mix(finalCol, p1, p1.a);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = 1.0 / iResolution.xy;\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec2 uvUnit = fragCoord.xy / iResolution.xy;\n    \n    vec4 finalCol = vec4(1.0,0.8,0.8,1.0);\n    vec3 shadowColour = vec3(0.45,0.42,0.3);\n    \n    vec3 skyColA = vec3(0.2,0.65,0.74);\n    vec3 skyColB = vec3(0.2,0.55,0.32);\n    \n    \n    \n    /*\n\t\tSky gradient thing..?\n\t*/\n    vec2 uvRot = uvUnit;\n    mat2 rotationMatrix = rotationMat(iTime * 0.6);\n    \n    uvRot -= 0.5;\n    \tuvRot *= rotationMatrix;\n    uvRot += 0.5;\n    \n    finalCol.xyz = mix(skyColA,skyColB,uvRot.x);\n    \n    /*\n\t\tGround\n\t*/\n    vec4 groundCol = vec4(0.5,0.5,0.5,1.0);\n    \n    if (uvUnit.y < 0.37)\n    {\n        if (uvUnit.y > 0.25)\n        {\n            if (mod(uvUnit.x-0.085, 0.14) > 0.03 || uvUnit.y < 0.35)\n            {\n                finalCol = vec4(vec3(0.0),1.0);\n            }\n        }\n        else if (uvUnit.y > 0.13)\n        {\n            if (uvUnit.y < 0.15 || uvUnit.y > 0.23 || mod(uvUnit.x-0.09, 0.14) < 0.015)\n            {\n\t\t\t\tfinalCol = vec4(vec3(0.1),1.0);\n            }\n            else\n            {\n                if (uvUnit.y < 0.17+rand(floor(uv * 50.0)/10.0)*0.04 || uvUnit.y > 0.23 || mod(uvUnit.x-0.078, 0.14) < 0.04)\n                {\n                    finalCol = vec4(vec3(0.5),1.0);\n                }\n                else\n                {\n            \t\tfinalCol = vec4(vec3(0.8),1.0);\n                }\n            }\n        }\n        else\n        {\n            //Random noise for Wall effect thing\n            float walls = rand(floor(uvUnit * 50.0)/10.0);\n        \tfinalCol = groundCol;\n            \n            finalCol *= min(max(uvUnit.y*1.4+0.3,0.2),1.0);\n            \n            if (walls < 0.3)\n            {\n            \tfinalCol.xyz = vec3(0.0);\n            }\n        }\n    }\n    \n    /*\n\t\tPlayers\n\t*/\n    vec4 p1 = playerOne(uv,iTime);\n    //vec4 p1Shd = playerOne(uv+vec2(pixel.x*(iResolution.x / iResolution.y), pixel.y)*6.0, iTime);\n    \n    vec4 p2 = playerTwo(uv,iTime+108.0);\n    //vec4 p2Shd = playerTwo(uv+vec2(pixel.x*(iResolution.x / iResolution.y), pixel.y)*6.0, (iTime+108.0));\n    \n    //finalCol = mix(finalCol, vec4(shadowColour, 1.0), p1Shd.a);\n    finalCol = mix(finalCol, p1, p1.a);\n    \n    //finalCol = mix(finalCol, vec4(shadowColour, 1.0), p2Shd.a);\n    finalCol = mix(finalCol, p2, p2.a);\n    \n\tfragColor = finalCol;\n}\n\n#define volume 0.08\n//V un-define this for EAR-TEARING TECHNO MUSIC YEAAHH BOII\n//#define TECHNOGGBABYYY\n#define xvalue 0\n#define uvalue 0\n#define vvalue 0\n\n/*\n    EGGNOGG+ bytebeat\n\n    (Glitch machine) Music from EGGNOGG+, a NIDHOGG parody game by MADGARDEN\n\thttps://madgarden.itch.io/eggnogg\n\n    Glitch machine/RPN to Normal bytebeat conversion by CaptCM74.\n\tCheck this out V\n\n\tgoo.gl/AdTkG9\n*/\n\n/*\n\tThe description from original file.... \n\t(Those value is on right above at the define section..)\n\n\t- x is a value from 0 to 5, based on the current room outwards from\n\t\tthe center of the map... starting room is 0... 9 total rooms\n\t- y is a random value set at game start\n\t- u is set to 1 when a player reaches the final room\n\t- v counts up to 255 over 10 seconds once the player leaps into\n\t\tthe EGGNOGG\n*/\n\nint melody(float tick,int x,int u,int v, int prev)\n{\n    int t = int(tick);\n    int composite;\n    \n    //The bytebeat goez here\n    #ifdef TECHNOGGBABYYY\n    /*\n    \t\"TECHNOGG CARNIVAL '92 by Madgarden\"\n\t*/\n    int first = ((t >> 10) * 5);\n\tint melody = ((((((t >> 12) & 2) + 5) & first) + 1) * t);\n\tmelody = ~melody;\n    \n    int key = (melody / (((t >> 16) & 3) + 1)) * 10 / 12 + (t >> 7 & 127);\n    int drum = (9999999 / ((x+1) * 25) / (t%(1<<(15-(x+0)))) + key) ^ (x * x * u);\n    \n    //Key\n    drum *= 2;\n    \n    int arp_key;\n    arp_key = (((t >> 10) & 7) - 3);\n\tarp_key = drum * ((((t >> 15) & 1) * arp_key) * ((t >> 18) & 1) + 1);\n    \n    int technogg = (((t >> 4) & 127) + 79 + x + arp_key) ^ arp_key;\n    \n    //Ending fadeout thing\n    technogg |= v;\n    \n    //filter\n    //technogg = ((technogg & 255) >> 1);\n    \n    composite = technogg;\n    #else\n    /*\n    \t\"EGGNOGGS OF CANADA (classic edition)\"\n\t*/\n    int first = ((t >> 10) * 5);\n    int melody = (((first | (t & 9)) & 5) + 1) * t;\n    int key = melody / (((t >> 16) & 3) + 1);\n    key *= 10;\n    key /= 12;\n    \n    int what = key + ((t >> 7) & 127);\n    int drum = (9999999 / ((x+1) * 25) / (t%(1<<(15-(x+u)))) + key) ^ (x * x);\n    \n    int arp_key = ((t >> 8) & 3);\n    arp_key *= ((t >> 15) & 1);\n    arp_key *= ((t >> 18) & 1);\n    arp_key = drum * (arp_key + 1);\n    \n    int voice = arp_key * 2;\n    voice ^= (voice + ((((t >> 11) & 63) + 15) + x));\n    \n    // Filter\n\t// 255 & 2 / + 2 * 3 / dup <- This DUP means that we have to pass the last sample :(\n    // So we used prev argument.\n    voice &= 255;\n    voice /= 2;\n    voice += prev;\n    voice *= 2;\n    voice /= 3;\n    \n    composite = voice;\n    #endif\n \treturn composite;\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [],
        "outputs": [],
        "code": "#define volume 0.08\n//V un-define this for EAR-TEARING TECHNO MUSIC YEAAHH BOII\n//#define TECHNOGGBABYYY\n#define xvalue 0\n#define uvalue 0\n#define vvalue 0\n\n/*\n    EGGNOGG+ bytebeat\n\n    (Glitch machine) Music from EGGNOGG+, a NIDHOGG parody game by MADGARDEN\n\thttps://madgarden.itch.io/eggnogg\n\n    Glitch machine/RPN to Normal bytebeat conversion by CaptCM74.\n\tCheck this out V\n\n\tgoo.gl/AdTkG9\n*/\n\n/*\n\tThe description from original file.... \n\t(Those value is on right above at the define section..)\n\n\t- x is a value from 0 to 5, based on the current room outwards from\n\t\tthe center of the map... starting room is 0... 9 total rooms\n\t- y is a random value set at game start\n\t- u is set to 1 when a player reaches the final room\n\t- v counts up to 255 over 10 seconds once the player leaps into\n\t\tthe EGGNOGG\n*/\n\nint melody(float tick,int x,int u,int v, int prev)\n{\n    int t = int(tick);\n    int composite;\n    \n    //The bytebeat goez here\n    #ifdef TECHNOGGBABYYY\n    /*\n    \t\"TECHNOGG CARNIVAL '92 by Madgarden\"\n\t*/\n    int first = ((t >> 10) * 5);\n\tint melody = ((((((t >> 12) & 2) + 5) & first) + 1) * t);\n\tmelody = ~melody;\n    \n    int key = (melody / (((t >> 16) & 3) + 1)) * 10 / 12 + (t >> 7 & 127);\n    int drum = (9999999 / ((x+1) * 25) / (t%(1<<(15-(x+0)))) + key) ^ (x * x * u);\n    \n    //Key\n    drum *= 2;\n    \n    int arp_key;\n    arp_key = (((t >> 10) & 7) - 3);\n\tarp_key = drum * ((((t >> 15) & 1) * arp_key) * ((t >> 18) & 1) + 1);\n    \n    int technogg = (((t >> 4) & 127) + 79 + x + arp_key) ^ arp_key;\n    \n    //Ending fadeout thing\n    technogg |= v;\n    \n    //filter\n    //technogg = ((technogg & 255) >> 1);\n    \n    composite = technogg;\n    #else\n    /*\n    \t\"EGGNOGGS OF CANADA (classic edition)\"\n\t*/\n    int first = ((t >> 10) * 5);\n    int melody = (((first | (t & 9)) & 5) + 1) * t;\n    int key = melody / (((t >> 16) & 3) + 1);\n    key *= 10;\n    key /= 12;\n    \n    int what = key + ((t >> 7) & 127);\n    int drum = (9999999 / ((x+1) * 25) / (t%(1<<(15-(x+u)))) + key) ^ (x * x);\n    \n    int arp_key = ((t >> 8) & 3);\n    arp_key *= ((t >> 15) & 1);\n    arp_key *= ((t >> 18) & 1);\n    arp_key = drum * (arp_key + 1);\n    \n    int voice = arp_key * 2;\n    voice ^= (voice + ((((t >> 11) & 63) + 15) + x));\n    \n    // Filter\n\t// 255 & 2 / + 2 * 3 / dup <- This DUP means that we have to pass the last sample :(\n    // So we used prev argument.\n    voice &= 255;\n    voice /= 2;\n    voice += prev;\n    voice *= 2;\n    voice /= 3;\n    \n    composite = voice;\n    #endif\n \treturn composite;\n}\n\nvec2 mainSound( float time )\n{\n    int beat = melody(time * 8000.0,xvalue,uvalue,vvalue, melody((time-(1.0/4096.0)) * 8000.0,xvalue,uvalue,vvalue, 0));\n    float final = float(beat % 256) / 256.0;\n    \n    return vec2(final) * volume; \n}",
        "name": "Sound",
        "description": "",
        "type": "sound"
      }
    ]
  }
}