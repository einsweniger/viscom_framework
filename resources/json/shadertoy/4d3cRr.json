{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "4d3cRr",
      "date": "1519959333",
      "viewed": 241,
      "name": "Yoshi Water Face",
      "username": "ThePopil",
      "description": "Yoshi's face but it's made out of water and there's no gravity, I dunno",
      "likes": 9,
      "published": 3,
      "flags": 0,
      "tags": [
        "reflection",
        "sdf",
        "refraction",
        "water",
        "animation",
        "yoshi"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 16,
            "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
            "ctype": "texture",
            "channel": 1,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 26,
            "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
            "ctype": "cubemap",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "false",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "// Testing values 1 for on, 0 for off\n// ----------------------------------\n// This is basically an easy way to see what part of the shader is the most performance-intensive\n// Spoiler alert, it's the edges of spheres\n#define DRAW_ITERATIONS 0\n\n// If set, the object will be a unit sphere\n// For validating material stuff and all that jazz\n#define SIMPLE_SPHERE 0\n\n// Enables reflection on the material\n#define REFLECT 1\n\n// Enables refraction on the material\n#define REFRACT 1\n\n// Enables transmission in the material\n#define TRANSMISSION 1\n\n\n// Global constants\n// ----------------\nconst float PI = 3.14;\nconst int MARCH_ITERATIONS = 128;\nconst float MAX_DIST = 10.0f;\nconst float EPSILON = 0.02; \t\t// Kind of a cool effect if you crank this up\n\n// Smoothing functions\n// Based on (http://www.iquilezles.org/www/articles/smin/smin.htm)\n// -------------------\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) - k*h*(1.0-h);\n}\n\n\n// Animation functions\n// -------------------\nconst float animPeriod = 5.0;\nconst float animDuration = 2.0;\nvec2 getAnim()\n{\n    // This is 1 during the animation, and 0 otherwise\n    float anim = floor(mod(iTime, animPeriod)/(animPeriod-animDuration));\n    // This goes from 0-1 during the animation\n    float t = (mod(iTime, animPeriod)-(animPeriod-animDuration)) / animDuration;\n    \n    // Ease in / out back\n    float f = t < 0.5 ? 2.0 * t : (1.0 - (2.0*t - 1.0));\n    float animCurve =  t<0.5 ? 0.5*(f*f*f-f*sin(f*PI)):0.5*(1.-(f*f*f-f*sin(f*PI)))+0.5;\n\n\treturn vec2(anim, animCurve);\n}\nvec2 getTongueAnim()\n{\n    // This is 1 during the animation, and 0 otherwise\n    float timeOff = iTime + 0.75;\n    float durOff = animDuration * 0.25;\n    float anim = floor(mod(timeOff, animPeriod)/(animPeriod-durOff));\n    // This goes from 0-1 during the animation\n    float t = max(0., (mod(timeOff, animPeriod)-(animPeriod-durOff)) / durOff);\n    \n    // Ease in out circ\n    float animCurve = t<0.5 ? 0.5*(1.-sqrt(1.-4.*(t*t))):0.5*(sqrt(-((2.*t)-3.)*((2.*t)-1.))+1.);\n\n\treturn vec2(anim, animCurve);\n}\n\n\n\n// SDF Model functions\n// Most taken from (http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm) \n// -------------------\nfloat Sphere(vec3 p, vec3 center, float radius)\n{\n    return length(p-center)-radius;\n}\nfloat Box(vec3 p, vec3 center, vec3 b)\n{\n    p -= center;\n\tvec3 d = abs(p) - b;\n \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat Ellipsoid(vec3 p, vec3 center, vec3 r)\n{\n    // r.x = stretch along x-axis\n    // r.y = stretch along y-axis\n    // r.z = stretch along z-axis\n    return (length((p-center)/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat CylinderYZ(vec3 p, vec3 center, vec2 h)\n{\n    p -= center;\n\tvec2 d = abs(vec2(length(p.yz),p.x)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat Tongue(vec3 p, vec3 center, vec3 a, vec3 b, float r)\n{\n    p.x += (sin(p.z*1.0+(iTime*30.0))/8.0) * max(0.0, -p.z);\n    p -= center;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h) - r;\n}\n\n// World space functions\n// ---------------------\nmat3 xRotation(float a)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(a), sin(a),\n                0.0, -sin(a), cos(a));\n}\n\nvec3 transform(vec3 q)\n{\n    // Wave\n    float speed = iTime < 3.0 ? 3.0+8.0*(3.0-iTime) : 3.0;\n    q.x += sin(q.y*1.0+(iTime*speed))/4.0;\n    q.z += sin(q.y*1.0+(iTime*(speed-1.0)))/4.0;\n    \n    q -= vec3(0.0, 0.0, 1.0);\n    vec2 anim = getAnim();\n    q = xRotation(anim.x * sin(PI * anim.y) * (-PI/8.0))*q;\n    q += vec3(0.0, 0.0, 1.0);\n    \n    return q;\n}\n\n// Returns the distance to the nearest object in the scene\n//\n//  Types:\n//\t 1.0 -> Skin\n// \t 3.0 -> Scales / Tongue\nvec2 sceneMap(vec3 p)\n{\n    float sdf;\n    float temp;\n    \n    #if SIMPLE_SPHERE\n    sdf = Sphere(p, vec3(0.0), 1.0);\n    return vec2(sdf, 1.0);\n    #endif\n    \n    float type = 1.0;\n    vec3 q = p;\n    p = transform(p);\n   \tsdf = Sphere(p, vec3(0.0), 1.0);\n        \n    // Nostrils\n    sdf = smax(sdf, -Ellipsoid(p, vec3(0.18, 0.76, -0.66), vec3(0.1, 0.1, 0.1)), 0.03);\n    sdf = smax(sdf, -Ellipsoid(p, vec3(-0.18, 0.76, -0.66), vec3(0.1, 0.1, 0.1)), 0.03);\n    \n    // Face\n    sdf = smin(sdf, Ellipsoid(p, vec3(0.0, -0.43, 1.2), vec3(1.3, 0.8, 0.8)), 0.03);\n    \n    temp = Ellipsoid(p, vec3(0.0, -0.1, 1.2), vec3(0.9, 0.6, 1.0));\n    sdf = smin(sdf, temp, 0.0);\n    \n    temp = Ellipsoid(p, vec3(0.0, -0.1, 1.2), vec3(0.9, 1.2, 1.0));\n    temp = max(temp, -Box(p, vec3(0.0, 0.5, 1.2), vec3(2.0, 0.6, 2.0)));\n    sdf = smin(sdf, temp, 0.0);\n    \n    sdf = smin(sdf, Ellipsoid(p, vec3(0.0, 0.2, 1.2), vec3(0.74, 0.6, 0.8)), 0.03);\n    \n    // Eyes\n    temp = Ellipsoid(p, vec3(0.28, 0.7, 1.1), vec3(0.4, 0.8, 0.4));\n    temp = min(temp,Ellipsoid(p, vec3(-0.28, 0.7, 1.1), vec3(0.4, 0.8, 0.4)));\n    sdf = smin(sdf, temp, 0.03);\n    \n    // Scales\n    temp = CylinderYZ(p, vec3(0.0, 0.7, 1.7), vec2(0.4, 0.1));\n    temp = min(temp, CylinderYZ(p, vec3(0.0, 0.2, 2.1), vec2(0.4, 0.1)));\n    temp = min(temp, CylinderYZ(p, vec3(0.0, -0.4, 2.05), vec2(0.4, 0.1))); \n    type = temp < sdf ? 3.0 : type;\n    sdf = smin(sdf, temp, 0.1);\n    \n    // Tongue\n    p = q; // Reset transformation\n    vec2 anim = getTongueAnim();\n    float dist = 0.4 + (anim.x * -5.4 * sin(anim.y * PI));\n    temp = Tongue(p, vec3(0.0), vec3(0.0, -0.8, 0.4), vec3(0.0, -0.8, dist), 0.1);\n    type = temp < sdf ? 3.0 : type;\n    sdf = smin(sdf, temp, 0.1);\n    \n    return iTime < 3.0 ? vec2(mix(length(p)-iTime/6.0, sdf, iTime/3.0), type) : vec2(sdf, type);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneMap(vec3(p.x + EPSILON, p.y, p.z)).x - sceneMap(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneMap(vec3(p.x, p.y + EPSILON, p.z)).x - sceneMap(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneMap(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneMap(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n// Main scene light\nconst vec3 light = vec3(2.0, 8.0f, 2.0f);\nconst vec3 light_a = vec3(1.0, 1.0f, 1.0f);\nconst vec3 light_d = vec3(1.0, 1.0f, 1.0f);\nconst vec3 light_s = vec3(1.0, 1.0f, 1.0f);\n\nvec3 phongShading(vec3 p, vec3 n, vec3 e, float type)\n{\n    vec3 mat_color = type == 3.0 ? vec3(0.35, 0.0, 0.0) : vec3(0.0);\n    float mat_a = type == 3.0 ? 0.3 : 0.0;\n    float mat_d = type == 3.0 ? 0.3 : 0.0;\n    float mat_s = 8.55f;\n    float mat_shiny = 16.0f;\n    \n    vec3 s = normalize(light - p);\n    vec3 r = normalize(-s + 2.0 * dot(s, n) * n);\n    vec3 c = normalize(e-p);\n    \n    vec3 amb = mat_color * mat_a * light_a; \n    vec3 dif = mat_color * mat_d * light_d * max(0.0, dot(s, n));\n    vec3 spe = mat_color * mat_s * light_s * pow(max(dot(c, r), 0.0), mat_shiny);\n    \n    return amb + dif + spe;\n}\n\nvec4 march(vec4 ro4, vec4 rd4)\n{\n    vec3 ro = vec3(ro4.x, ro4.y, ro4.z);\n    vec3 rd = normalize(vec3(rd4.x, rd4.y, rd4.z));\n\tfloat t = 0.0;\n    for(int i = 0; i < MARCH_ITERATIONS; i++)\n    {\n    \tvec3 p = ro + rd * t;\n        vec2 map = sceneMap(p);\n        vec4 solution = vec4(map.x, getNormal(p));\n        \n        if(solution.x < EPSILON)\n        {\n            #if DRAW_ITERATIONS\n            float iter = float(i)/float(MARCH_ITERATIONS);\n            return vec4(iter);\n            #endif\n            \n            vec3 n = solution.yzw;\n            vec3 colour = phongShading(p, n, ro, map.y);\n            \n            // Add some noise to directional ray, gives the reflection / refraction\n            // a wavy or spinny look to it\n            rd += texture(iChannel1, vec2(p.x, p.y)).xyz * 0.001;\n            \n            #if REFLECT\n            vec3 reflect = rd - (2.0 * dot(rd, n) * n);\n            vec3 reflect_colour = texture(iChannel0, reflect).rgb;\n            colour += 0.35 * reflect_colour;\n            #endif\n            \n            #if REFRACT\n            float index = 1.33;\n            rd += texture(iChannel1, vec2(rd.y, rd.x)).xyz * 0.05;\n            vec3 refr = refract(rd, n, index);\n            float t2 = 0.001;\n            for(int i = 0; i < MARCH_ITERATIONS; i++)\n            {\n                vec3 p2 = p + refr * t2;\n                vec4 solution2 = vec4(sceneMap(p2).x, getNormal(p2));\n                if(solution2.x > EPSILON)\n        \t\t{\n                    vec3 refr = refract(rd, n, 1.0/index);\n                    break;\n                }\n                t2 += EPSILON + abs(solution2.x * 0.9);\n            }\n            \n            if(refr != vec3(0.0) && map.y == 1.0)\n            {\n                colour += texture(iChannel0, refr).rgb;\n                #if TRANSMISSION\n                colour.g += 0.4 * t2 * t2 * t2 * t2;\n                #endif\n            }\n            else\n            {\n                // Just hacked in a value that I think looks nice,\n                // For the future should find a better way to determine\n                // ratio between reflected and refracted light\n            \tcolour *= 3.0;\n            }\n            #endif\n                \n        \treturn vec4(colour, 1.0);\n        }\n        \n        t += solution.x * 0.95;\n        \n        if (t > MAX_DIST)\n        {\n            #if DRAW_ITERATIONS\n            float iter = float(i)/float(MARCH_ITERATIONS);\n            return vec4(iter);\n            #endif\n            break;\n        }\n    }\n    return texture(iChannel0, rd); // Cubemapping\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Determine camera position\n    vec3 e = vec3(0.0);\n    e.x = 7.0 * cos(iTime / 4.0);\n    e.y = 0.95;\n    e.z = 7.0 * -sin(iTime / 4.0);\n    \n    \n    // Camera's up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Camera's gaze vector, always pointing to the origin in this case\n    // (w vector in camera space)\n    vec3 cw = normalize(-e);\n    \n    // Camera u vector\n    vec3 cu = normalize(cross(cw, up));\n    \n    // Camera v vector\n    vec3 cv = normalize(cross(cw, cu));\n    \n    // Camera to World matrix\n    mat4 C2W = mat4 (cu.x, cv.x, cw.x, e.x,\n                     cu.y, cv.y, cw.y, e.y,\n                     cu.z, cv.z, cw.z, e.z,\n                     0.0,   0.0,  0.0, 1.0);\n    \n   // Set up image plane dimensions\n    vec4 uv = vec4(fragCoord/iResolution.x, -1.0, 1.0);\n    uv.x -= 0.5;\n    uv.y -= (iResolution.y/iResolution.x)/2.0;\n    \n    // Image plane\n    vec4 ro = vec4(vec3(0.0), 1.0);\n    vec4 rd = ro-uv;\n    \n    fragColor = march(ro*C2W, rd*C2W);\n}\n",
        "name": "Image",
        "description": "",
        "type": "image"
      }
    ]
  }
}