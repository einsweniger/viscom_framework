{
  "Shader": {
    "ver": "0.1",
    "info": {
      "id": "Xly3DV",
      "date": "1500050497",
      "viewed": 268,
      "name": "Fast Canny Edge Detection",
      "username": "starea",
      "description": "A naive implementation of the canny edge detector. \nThe unfinished step is to flood fill the edges and connect the dots.\nPress the mouse for comparison with fwidth.",
      "likes": 3,
      "published": 3,
      "flags": 32,
      "tags": [
        "2d",
        "filter",
        "detection",
        "edge",
        "image",
        "gaussian",
        "outline",
        "canny"
      ],
      "hasliked": 0
    },
    "renderpass": [
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 1,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 2,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          },
          {
            "id": 260,
            "src": "/media/previz/buffer03.png",
            "ctype": "buffer",
            "channel": 3,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 37,
            "channel": 0
          }
        ],
        "code": "#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\n#define B(X,Y) (tap(iChannel1,vec2(X,Y)))\n#define C(X,Y) (tap(iChannel2,vec2(X,Y)))\n#define D(X,Y) (tap(iChannel3,vec2(X,Y)))\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = D(uv.x, uv.y); \n    //(min(fwidth(texture(iChannel0, fragCoord.xy / iResolution.xy))*7.0\n    if (iMouse.z > 0.0) col = vec3(pow( length(fwidth(texture(iChannel1, uv) * 7.0)), 2.0));\n\tfragColor = vec4(col, 1.0);\n}",
        "name": "Image",
        "description": "",
        "type": "image"
      },
      {
        "inputs": [
          {
            "id": 5,
            "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
            "ctype": "texture",
            "channel": 0,
            "sampler": {
              "filter": "mipmap",
              "wrap": "repeat",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 257,
            "channel": 0
          }
        ],
        "code": "/** \n * Canny Edge Detection by Ruofei Du (DuRuofei.com)\n * Step 1A: Apply (Horizontal) Gaussian filter to smooth the image in order to remove the noise\n * Link to demo: https://www.shadertoy.com/view/Xly3DV\n * starea @ ShaderToy, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n *\n * Reference: \n * [1] Canny, J., A Computational Approach To Edge Detection, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679\u2013698, 1986.\n * [2] Canny edge detector, Wikipedia. https://en.wikipedia.org/wiki/Canny_edge_detector\n *\n * Related & Better Implementation:\n * [1] https://www.shadertoy.com/view/4ssXDS\n * [2] stduhpf's Canny filter (3pass): https://www.shadertoy.com/view/MsyXzt\nhttp://duruofei.com/Public/course/CMSC733/Du_Ruofei_PS1.pdf\n * \n **/\nconst int mSize = 5;\nconst int kSize = (mSize - 1) / 2;\nconst float sigma = 2.0;\nconst float GAMMA = 2.2; \nfloat kernel[mSize];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    for (int i = -kSize; i <= kSize; ++i) {\n        col += kernel[kSize+i] * pow(\n                    texture(iChannel0, (fragCoord.xy+ vec2(float(i),0.0) ) / iResolution.xy).rgb\n                  , vec3(GAMMA));\n    }\n    \n    fragColor = vec4(pow(col / Z, vec3(1.0 / GAMMA)), 1.0);\n}",
        "name": "Buf A",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 257,
            "src": "/media/previz/buffer00.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "nearest",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 258,
            "channel": 0
          }
        ],
        "code": "/** \n * Canny Edge Detection by Ruofei Du (DuRuofei.com)\n * Step 1B: Apply (Vertical) Gaussian filter to smooth the image in order to remove the noise\n *          Meanwhile, convert the smoothed image to gray scale\n * Link to demo: https://www.shadertoy.com/view/Xly3DV\n * starea @ ShaderToy, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n *\n * Reference: \n * [1] Canny, J., A Computational Approach To Edge Detection, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679\u2013698, 1986.\n * [2] Canny edge detector, Wikipedia. https://en.wikipedia.org/wiki/Canny_edge_detector\n *\n * Related & Better Implementation:\n * [1] stduhpf's Canny filter (3pass): https://www.shadertoy.com/view/MsyXzt\n **/\nconst int mSize = 5;\nconst int kSize = (mSize - 1) / 2;\nconst float sigma = 2.0;\nconst float GAMMA = 2.2; \nfloat kernel[mSize];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    for (int i = -kSize; i <= kSize; ++i) {\n        col += kernel[kSize+i] * pow(\n                    texture(iChannel0, (fragCoord.xy+ vec2(0.0, float(i)) ) / iResolution.xy).rgb\n                  , vec3(GAMMA));\n    }\n    \n    col = pow(col / Z, vec3(1.0 / GAMMA));\n    float gray = dot(col, vec3(0.2126, 0.7152, 0.0722));\n    fragColor = vec4(vec3(gray), 1.0);\n}",
        "name": "Buf B",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 258,
            "src": "/media/previz/buffer01.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 259,
            "channel": 0
          }
        ],
        "code": "/** \n * Canny Edge Detection by Ruofei Du (DuRuofei.com)\n * Step 2: Find the intensity gradients of the image\n * Link to demo: https://www.shadertoy.com/view/Xly3DV\n * starea @ ShaderToy, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n *\n * Reference: \n * [1] Canny, J., A Computational Approach To Edge Detection, IEEE Trans. Pattern Analysis and Machine Intelligence, 8(6):679\u2013698, 1986.\n * [2] Canny edge detector, Wikipedia. https://en.wikipedia.org/wiki/Canny_edge_detector\n *\n * Related & Better Implementation:\n * [1] stduhpf's Canny filter (3pass): https://www.shadertoy.com/view/MsyXzt\n **/\n#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float dX = dFdx( texture(iChannel0, uv).r );\n    float dY = dFdy( texture(iChannel0, uv).r );\n    float magnitude = length(vec2(dX, dY)); \n    vec3 col = vec3(dX / magnitude, dY / magnitude, magnitude); \n\tfragColor = vec4(col, 1.0);\n}",
        "name": "Buf C",
        "description": "",
        "type": "buffer"
      },
      {
        "inputs": [
          {
            "id": 259,
            "src": "/media/previz/buffer02.png",
            "ctype": "buffer",
            "channel": 0,
            "sampler": {
              "filter": "linear",
              "wrap": "clamp",
              "vflip": "true",
              "srgb": "false",
              "internal": "byte"
            },
            "published": 1
          }
        ],
        "outputs": [
          {
            "id": 260,
            "channel": 0
          }
        ],
        "code": "#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dXdYMag = texture(iChannel0, uv).rgb;\n    \n    vec3 X = texture(iChannel0, uv + dXdYMag.xy ).rgb;\n    vec3 Y = texture(iChannel0, uv - dXdYMag.xy ).rgb;\n    \n    if (dXdYMag.z > 15.0 / 255.0 && dXdYMag.z > X.z && dXdYMag.z > Y.z) \n        fragColor = vec4(vec3(1.0), 1.0);\n    else\n\t    fragColor = vec4(vec3(0.0), 1.0);\n}",
        "name": "Buf D",
        "description": "",
        "type": "buffer"
      }
    ]
  }
}